<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de An√°lise de Opera√ß√£o</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- ADICIONADO: Plugin para mostrar labels nos gr√°ficos -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <!-- Carregando a biblioteca XLSX aqui para garantir que esteja dispon√≠vel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        :root {
            /* Original Palette */
            --primary-color: #374151; /* gray-700 */
            --secondary-color: #4B5563; /* gray-600 */
            --accent-color: #3B82F6; /* blue-500 */
            --accent-hover-color: #2563EB; /* blue-600 */
            --danger-color: #EF4444; /* red-500 */
            --danger-hover-color: #DC2626; /* red-600 */
            --background-color: #111827; /* gray-900 */
            --card-bg-color: #1F2937; /* gray-800 */
            --text-color: #D1D5DB; /* gray-300 */
            --text-color-header: #FFFFFF; /* white */

            /* Original Chart Colors (usados como refer√™ncia para o JS) */
            --chart-grid-color: rgba(107, 114, 128, 0.3); /* gray-500 with opacity */
            --chart-label-color: #D1D5DB; /* gray-300 (mesma cor do text-color) */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
        }
        .tab-button {
            transition: all 0.3s ease;
        }
        .tab-button.active {
            border-color: var(--accent-color);
            color: var(--accent-color);
            background-color: var(--card-bg-color);
            /* text-shadow removed */
        }
        
        .file-drop-zone {
            transition: all 0.3s ease;
            border-color: var(--secondary-color);
        }
        .file-drop-zone.dragover {
            border-color: var(--accent-color);
            background-color: #2c3a4f; /* Um pouco mais claro no dragover */
             /* box-shadow removed */
        }
        .loader {
            border-top-color: var(--accent-color);
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .btn-primary {
            background-color: var(--accent-color);
            color: white; /* Cor original */
            font-weight: normal; /* Peso original */
            transition: background-color 0.3s ease; /* Transi√ß√£o original */
            /* box-shadow removed */
            border: none; /* Borda removida */
             padding: 0.5rem 1rem; /* Re-add padding if needed */
             border-radius: 0.375rem; /* Re-add border-radius if needed */
        }
        .btn-primary:hover {
            background-color: var(--accent-hover-color);
            /* box-shadow removed */
        }
        .btn-danger {
            background-color: var(--danger-color);
             color: white; /* Cor original */
            font-weight: normal; /* Peso original */
            transition: background-color 0.3s ease; /* Transi√ß√£o original */
             /* box-shadow removed */
             border: none; /* Borda removida */
             padding: 0.5rem 1rem; /* Re-add padding if needed */
             border-radius: 0.375rem; /* Re-add border-radius if needed */
        }
        .btn-danger:hover {
            background-color: var(--danger-hover-color);
            /* box-shadow removed */
        }
        /* Custom styles for Chart.js dark theme */
        .chart-container {
            position: relative;
            height: 300px;
        }
        /* Tooltip de informa√ß√£o dos gr√°ficos */
        .chart-info-tooltip {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 20px;
            height: 20px;
            background-color: var(--accent-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            z-index: 10;
            transition: all 0.3s ease;
        }
        .chart-info-tooltip:hover {
            background-color: var(--accent-hover-color);
            transform: scale(1.1);
        }
        
        .tooltip-card {
            position: absolute;
            top: 30px;
            right: 0;
            width: 320px;
            background-color: var(--card-bg-color);
            border: 1px solid var(--secondary-color);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .chart-info-tooltip:hover .tooltip-card {
            opacity: 1;
            visibility: visible;
        }
        
        .tooltip-card h4 {
            color: var(--text-color-header);
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .tooltip-card .formula {
            background-color: var(--background-color);
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--accent-color);
        }

        /* Style for inputs */
        input[type="date"], input[type="text"], input[type="time"], input[type="number"], select, input[type="month"] {
            background-color: var(--primary-color);
            border-color: var(--secondary-color);
            color: var(--text-color);
            border-width: 1px; /* Garantir que a borda seja vis√≠vel */
             padding: 0.5rem 0.75rem; /* Add padding for better appearance */
             border-radius: 0.375rem; /* Add border-radius */
        }
        input[type="date"]:focus, input[type="text"]:focus, input[type="time"]:focus, input[type="number"]:focus, select:focus, input[type="month"]:focus {
             border-color: var(--accent-color); /* Destaca a borda ao focar */
             box-shadow: 0 0 0 1px var(--accent-color); /* Add focus ring matching accent */
             outline: none; /* Remove o outline padr√£o */
        }

        input[type="date"]::-webkit-calendar-picker-indicator,
        input[type="month"]::-webkit-calendar-picker-indicator {
            filter: invert(1); /* Filtro original */
        }
        .mov-sub-tab.active {
            color: var(--accent-color);
            border-color: var(--accent-color);
            /* text-shadow removed */
        }
        /* Modal styles */
        .modal-backdrop {
            background-color: rgba(0,0,0,0.6); /* Cor original */
        }
        /* Feedback message styles - manter como estava */
        #feedback-message-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .feedback-message {
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            max-width: 90%;
            text-align: center;
            transform: translateY(20px);
        }
        .feedback-message.show {
            opacity: 1;
            transform: translateY(0);
        }
        .feedback-message.success { background-color: #10B981; } /* green-500 */
        .feedback-message.error { background-color: #EF4444; } /* red-500 */
        .feedback-message.warning { background-color: #F59E0B; } /* amber-500 */
        .feedback-message.info { background-color: #3B82F6; } /* blue-500 */

        /* Estilos para Sub-abas */
        .sub-tabs-container {
            margin-bottom: 1.5rem;
        }
        .sub-tabs-nav {
            border-bottom: 1px solid #374151; /* gray-700 */
        }
        .sub-tab-btn {
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
            color: #9CA3AF; /* gray-400 */
            font-weight: 500;
            font-size: 0.875rem;
            padding: 0.5rem 0.25rem;
            margin-bottom: -1px;
            background: none;
            border-left: none;
            border-right: none;
            border-top: none;
            cursor: pointer;
        }
        .sub-tab-btn:hover {
            color: #D1D5DB; /* gray-300 */
            border-bottom-color: #6B7280; /* gray-500 */
        }
        .sub-tab-btn.active {
            color: #3B82F6; /* blue-500 */
            border-bottom-color: #3B82F6; /* blue-500 */
        }
        .sub-tab-content {
            display: block;
        }
        .sub-tab-content.hidden {
            display: none;
        }

    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>

<body class="p-4 md:p-8">

    <!-- Container principal com fundo original -->
    <div class="max-w-7xl mx-auto bg-gray-900 rounded-2xl shadow-lg p-6 md:p-8 border border-gray-700">
        <header class="mb-6 border-b border-gray-700 pb-4">
            <h1 class="text-3xl font-bold text-gray-100">Sistema de An√°lise de Opera√ß√£o</h1>
            <p class="text-gray-400 mt-1">Importe suas bases de dados para gerar insights.</p>
        </header>

        <!-- Abas de Navega√ß√£o -->
         <div class="border-b border-gray-700 mb-6">
            <nav class="-mb-px flex flex-wrap space-x-6" aria-label="Tabs">
                <button id="tab-btn-importacao" class="tab-button active whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">
                    Importa√ß√£o
                </button>

                <button id="tab-btn-operacao" class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-500">
                    Indicadores de Opera√ß√£o
                </button>
                 <button id="tab-btn-absenteismo" class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-500">
                    Absente√≠smo
                </button>
                 <button id="tab-btn-movimentacoes" class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-500">
                    Hist√≥rico mensal de opera√ß√£o empilhadeira
                </button>
                 <button id="tab-btn-regras" class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-500">
                    Regras
                </button>
            </nav>
        </div>


        <!-- Conte√∫do das Abas -->
        <main>
            <!-- Aba de Importa√ß√£o -->
            <div id="tab-content-importacao">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">

                    <!-- Card de Importa√ß√£o de Expedi√ß√£o -->
                    <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Importar Arquivo Expedi√ß√£o</h2>
                        <p class="text-sm text-gray-400 mb-4">Selecione ou arraste um arquivo .csv ou .xlsx.</p>
                        <div id="expedicao-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-700/50">
                            <input type="file" id="expedicao-file-input" class="hidden" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                            <p id="expedicao-file-label" class="text-gray-400">Arraste e solte ou clique aqui.</p>
                        </div>
                         <div id="expedicao-file-info" class="mt-4 text-center hidden">
                            <p class="text-sm text-gray-300 font-medium"></p>
                            <button id="expedicao-remove-file-btn" class="mt-2 text-xs text-red-400 hover:text-red-500">Remover Arquivo</button>
                        </div>
                        <div id="expedicao-loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-600 h-12 w-12 mx-auto mt-4 hidden"></div>
                    </div>

                     <!-- Card de Importa√ß√£o de Absente√≠smo -->
                     <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Importar Arquivos de Absente√≠smo</h2>
                        <p class="text-sm text-gray-400 mb-4">Importe m√∫ltiplos relat√≥rios di√°rios (um arquivo por dia).</p>
                        <div id="absenteismo-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-700/50">
                            <input type="file" id="absenteismo-file-input" class="hidden" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel" multiple>
                            <p id="absenteismo-file-label" class="text-gray-400">Arraste e solte m√∫ltiplos arquivos ou clique aqui.</p>
                        </div>
                        <div id="absenteismo-files-list" class="mt-4 hidden">
                            <h3 class="text-sm font-medium text-gray-300 mb-2">Arquivos selecionados:</h3>
                            <div id="absenteismo-files-container" class="space-y-2 max-h-32 overflow-y-auto">
                                <!-- Lista de arquivos ser√° inserida aqui -->
                            </div>
                            <div class="flex justify-between mt-4">
                                <button id="absenteismo-remove-all-btn" class="text-xs text-red-400 hover:text-red-500">Remover Todos</button>
                                <button id="process-absenteismo-files-btn" class="btn-primary py-2 px-4 rounded-lg text-sm">Processar Arquivos</button>
                            </div>
                        </div>
                         <div id="absenteismo-preview-container" class="hidden mt-4">
                            <h3 class="text-sm font-medium text-gray-300 mb-2">Dados processados:</h3>
                            <div id="absenteismo-preview-list" class="space-y-2 max-h-40 overflow-y-auto bg-gray-700 p-3 rounded">
                                <!-- Preview dos dados processados -->
                            </div>
                            <div class="flex justify-center mt-4">
                               <button id="save-absenteismo-btn" class="btn-primary py-2 px-4 rounded-lg">
                                 Salvar no Hist√≥rico
                                </button>
                            </div>
                        </div>
                        <div id="absenteismo-loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-600 h-12 w-12 mx-auto mt-4 hidden"></div>
                         <div id="absenteismo-feedback" class="mt-4 text-center"></div>
                    </div>

                    <!-- Card de Gerenciamento de Dados de Absente√≠smo -->
                    <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Gerenciar Dados de Absente√≠smo</h2>
                        <p class="text-sm text-gray-400 mb-4">Visualize e gerencie os dados importados por per√≠odo.</p>
                        
                        <div class="flex justify-between items-center mb-4">
                            <div class="flex gap-2">
                                <button id="refresh-absenteismo-list-btn" class="btn-primary py-2 px-4 rounded-lg text-sm">
                                    üîÑ Atualizar Lista
                                </button>
                                <button id="clear-all-absenteismo-btn" class="bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded-lg text-sm">
                                    üóëÔ∏è Limpar Tudo
                                </button>
                            </div>
                            <div class="flex gap-2">
                                <label class="flex items-center text-sm text-gray-300">
                                    <input type="checkbox" id="keep-old-data-checkbox" class="mr-2" checked>
                                    Manter dados antigos ao importar novos
                                </label>
                            </div>
                        </div>
                        
                        <div id="absenteismo-data-list" class="space-y-3">
                            <div class="text-center text-gray-400 text-sm py-4">
                                Carregando dados...
                            </div>
                        </div>
                    </div>

                    <!-- Card de Importa√ß√£o de Empilhadeira -->
                     <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Importar Mov. Empilhadeira</h2>
                        <p class="text-sm text-gray-400 mb-4">Selecione ou arraste o arquivo.</p>
                        <div id="empilhadeira-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-700/50">
                            <input type="file" id="empilhadeira-file-input" class="hidden" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                            <p id="empilhadeira-file-label" class="text-gray-400">Arraste e solte ou clique aqui.</p>
                        </div>
                         <div id="empilhadeira-file-info" class="mt-4 text-center hidden">
                            <p class="text-sm text-gray-300 font-medium"></p>
                            <button id="empilhadeira-remove-file-btn" class="mt-2 text-xs text-red-400 hover:text-red-500">Remover Arquivo</button>
                        </div>
                        <div id="empilhadeira-loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-600 h-12 w-12 mx-auto mt-4 hidden"></div>
                    </div>

                </div>
            </div>



            <!-- Aba de Indicadores de Opera√ß√£o -->
            <div id="tab-content-operacao" class="hidden">
                <!-- FILTRO DE TURNO ATUALIZADO -->
                <div class="mb-6 bg-gray-800 p-4 rounded-lg border border-gray-700 shadow-md">
                    <label for="mov-turno-filter" class="block text-sm font-medium text-gray-300">Comparar 1¬∞ Turno com:</label>
                    <select id="mov-turno-filter" class="mt-1 block w-full md:w-1/4 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                        <option value="2¬∞ TURNO" selected>2¬∞ Turno</option>
                        <option value="todos">Todos os Turnos (Total)</option>
                    </select>
                </div>
                <!-- FIM FILTRO -->

                <!-- Sub-abas para Opera√ß√£o -->
                <div class="sub-tabs-container mb-6">
                    <div class="sub-tabs-nav border-b border-gray-200">
                        <nav class="-mb-px flex space-x-8">
                            <button class="sub-tab-btn active whitespace-nowrap py-2 px-1 border-b-2 border-blue-500 font-medium text-sm text-blue-600" 
                                    data-target="logistica">
                                Opera√ß√£o log√≠stica
                            </button>
                            <button class="sub-tab-btn whitespace-nowrap py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-400 hover:text-gray-300 hover:border-gray-500" 
                                    data-target="expedicao">
                                Opera√ß√£o Expedi√ß√£o
                            </button>
                            <button class="sub-tab-btn whitespace-nowrap py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-400 hover:text-gray-300 hover:border-gray-500" 
                                    data-target="picking">
                                Opera√ß√£o Picking
                            </button>
                            <button class="sub-tab-btn whitespace-nowrap py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-400 hover:text-gray-300 hover:border-gray-500" 
                                    data-target="empilhadeira">
                                Opera√ß√£o Empilhadeira
                            </button>
                        </nav>
                    </div>
                </div>

                <!-- Conte√∫do das Sub-abas -->
                <div id="logistica" class="sub-tab-content">
                    <div id="logistica-placeholder" class="text-center py-12 text-gray-500">
                        <svg class="mx-auto h-12 w-12" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 14.25v2.25m3-4.5v4.5m3-6.75v6.75m3-9v9M6 20.25h12A2.25 2.25 0 0 0 20.25 18V5.25A2.25 2.25 0 0 0 18 3H6A2.25 2.25 0 0 0 3.75 5.25v12.75A2.25 2.25 0 0 0 6 20.25Z" />
                        </svg>
                        <h3 class="mt-2 text-sm font-medium text-gray-200">Carregue os arquivos de Expedi√ß√£o e Mov. Empilhadeira</h3>
                        <p class="mt-1 text-sm text-gray-400">Os gr√°ficos de indicadores aparecer√£o aqui.</p>
                    </div>
                    <div id="logistica-charts-container" class="hidden space-y-8">
                        <!-- Charts da Opera√ß√£o log√≠stica ser√£o renderizados aqui -->
                    </div>
                </div>

                <div id="expedicao" class="sub-tab-content hidden">
                    <div id="expedicao-placeholder" class="text-center py-12 text-gray-500">
                        <svg class="mx-auto h-12 w-12" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M20.25 6.375c0 2.278-3.694 4.125-8.25 4.125S3.75 8.653 3.75 6.375m16.5 0c0 2.278-3.694 4.125-8.25 4.125S3.75 8.653 3.75 6.375m16.5 0c0-2.278-3.694-4.125-8.25-4.125S3.75 4.097 3.75 6.375v11.25c0 2.278 3.694 4.125 8.25 4.125s8.25-1.847 8.25-4.125V6.375Z" />
                        </svg>
                        <h3 class="mt-2 text-sm font-medium text-gray-200">Opera√ß√£o Expedi√ß√£o</h3>
                        <p class="mt-1 text-sm text-gray-400">Conte√∫do em desenvolvimento.</p>
                    </div>
                    <div id="expedicao-charts-container" class="hidden space-y-8">
                        <!-- Charts da Opera√ß√£o Expedi√ß√£o ser√£o renderizados aqui -->
                    </div>
                </div>

                <div id="picking" class="sub-tab-content hidden">
                    <div id="picking-placeholder" class="text-center py-12 text-gray-500">
                        <svg class="mx-auto h-12 w-12" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184" />
                        </svg>
                        <h3 class="mt-2 text-sm font-medium text-gray-200">Opera√ß√£o Picking</h3>
                        <p class="mt-1 text-sm text-gray-400">Conte√∫do em desenvolvimento.</p>
                    </div>
                    <div id="picking-charts-container" class="hidden space-y-8">
                        <!-- Charts da Opera√ß√£o Picking ser√£o renderizados aqui -->
                    </div>
                </div>

                <div id="empilhadeira" class="sub-tab-content hidden">
                    <div id="empilhadeira-placeholder" class="text-center py-12 text-gray-500">
                        <svg class="mx-auto h-12 w-12" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 18.75a1.5 1.5 0 0 1-3 0m3 0a1.5 1.5 0 0 1-3 0m3 0h6m-9 0H3.375a1.125 1.125 0 0 1-1.125-1.125V14.25m6.75 4.5v-3a1.5 1.5 0 0 1 1.5-1.5h3a1.5 1.5 0 0 1 1.5 1.5v3m-6 0V9a1.5 1.5 0 0 1 1.5-1.5h3A1.5 1.5 0 0 1 16.5 9v3.75" />
                        </svg>
                        <h3 class="mt-2 text-sm font-medium text-gray-200">Opera√ß√£o Empilhadeira</h3>
                        <p class="mt-1 text-sm text-gray-400">Conte√∫do em desenvolvimento.</p>
                    </div>
                    <div id="empilhadeira-charts-container" class="hidden space-y-8">
                        <!-- Charts da Opera√ß√£o Empilhadeira ser√£o renderizados aqui -->
                    </div>
                </div>

                 <div id="operacao-placeholder" class="text-center py-12 text-gray-500 hidden">
                     <svg class="mx-auto h-12 w-12" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                         <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 14.25v2.25m3-4.5v4.5m3-6.75v6.75m3-9v9M6 20.25h12A2.25 2.25 0 0 0 20.25 18V5.25A2.25 2.25 0 0 0 18 3H6A2.25 2.25 0 0 0 3.75 5.25v12.75A2.25 2.25 0 0 0 6 20.25Z" />
                    </svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-200">Carregue os arquivos de Expedi√ß√£o e Mov. Empilhadeira</h3>
                    <p class="mt-1 text-sm text-gray-400">Os gr√°ficos de indicadores aparecer√£o aqui.</p>
                </div>
                <!-- Container modificado para space-y -->
                <div id="operacao-charts-container" class="hidden space-y-8">
                    <!-- Charts will be rendered here -->
                </div>
            </div>


            <!-- Aba de Absente√≠smo -->
            <div id="tab-content-absenteismo" class="hidden">
                <div class="mb-4">
                    <label for="absenteismo-date-filter" class="block text-sm font-medium text-gray-300">Filtrar por Data:</label>
                    <input type="date" id="absenteismo-date-filter" name="absenteismo-date-filter" class="mt-1 block w-full md:w-1/4 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                </div>
                <div id="absenteismo-table-container">
                    <!-- Tabela de hist√≥rico ser√° inserida aqui -->
                </div>
                <div id="absenteismo-placeholder" class="text-center py-12 text-gray-500">
                    <svg class="mx-auto h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                         <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-200">Hist√≥rico de Absente√≠smo</h3>
                    <p class="mt-1 text-sm text-gray-400">Selecione uma data ou salve novos dados.</p>
                </div>
            </div>

            <!-- Aba de Movimenta√ß√µes de Empilhadeira -->
            <div id="tab-content-movimentacoes" class="hidden">
                 <!-- Filtro de Operadores -->
                 <div class="mb-6 bg-gray-800 p-4 rounded-lg border border-gray-700 shadow-md">
                    <h3 class="text-sm font-medium text-gray-300 mb-3">Filtrar Operadores</h3>
                    <div class="flex flex-wrap gap-2" id="operator-quick-filter">
                        <!-- Quick filter buttons will be populated here -->
                        <p class="text-sm text-gray-400">Carregue dados de movimenta√ß√£o para ver filtros dispon√≠veis.</p>
                    </div>
                 </div>
                 
                 <div id="movimentacoes-dashboard-content">
                    <!-- Conte√∫do ser√° preenchido via JS -->
                 </div>
                 <div id="movimentacoes-placeholder" class="text-center py-12 text-gray-500">
                    <svg class="mx-auto h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                       <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1" />
                    </svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-200">Nenhum dado para exibir</h3>
                    <p class="mt-1 text-sm text-gray-400">Importe o arquivo de movimenta√ß√µes para come√ßar.</p>
                 </div>
            </div>

             <!-- Aba de Regras -->
            <div id="tab-content-regras" class="hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <!-- Formul√°rio para Downtime -->
                    <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Cadastrar Regra de Downtime</h2>
                        <form id="form-regra-downtime">
                            <div class="mb-4">
                                <label for="motivo-downtime" class="block text-sm font-medium text-gray-300">Motivo</label>
                                <input type="text" id="motivo-downtime" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" required>
                            </div>
                            <div class="mb-4">
                                <label for="tempo-downtime" class="block text-sm font-medium text-gray-300">Tempo Total no M√™s (HH:MM)</label>
                                <input type="text" id="tempo-downtime" placeholder="Ex: 30:00 para 30 horas" pattern="[0-9]+:[0-5][0-9]" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" required>
                                <p class="text-xs text-gray-400 mt-1">Formato: HH:MM (pode ultrapassar 24h, ex: 30:15 para 30h e 15min)</p>
                            </div>
                            <button type="submit" class="btn-primary py-2 px-4 rounded-lg w-full">Salvar Regra</button> <!-- Removed font-bold -->
                        </form>
                        <div id="downtime-feedback" class="mt-4 text-center"></div>
                    </div>
                     <!-- Formul√°rio para Meta -->
                    <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                         <h2 class="text-xl font-semibold text-gray-200 mb-4">Cadastrar Meta por Atividade</h2>
                        <form id="form-meta">
                            <div class="mb-4">
                                <label for="meta-atividade-nome" class="block text-sm font-medium text-gray-300">Nome da Atividade</label>
                                <input type="text" id="meta-atividade-nome" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" required>
                            </div>
                            <div class="flex gap-4 mb-4">
                                <div class="flex-1">
                                    <label for="meta-atividade-valor" class="block text-sm font-medium text-gray-300">Valor da Meta</label>
                                    <input type="number" id="meta-atividade-valor" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" required min="0" step="any">
                                </div>
                                <div class="flex-1">
                                    <label for="meta-atividade-unidade" class="block text-sm font-medium text-gray-300">Unidade</label>
                                    <select id="meta-atividade-unidade" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                        <option value="/ Hr">/ Hr</option>
                                        <option value="/ Min">/ Min</option>
                                    </select>
                                </div>
                            </div>
                             <button type="submit" class="btn-primary py-2 px-4 rounded-lg w-full">Salvar Meta</button> <!-- Removed font-bold -->
                        </form>
                        <div id="meta-feedback" class="mt-4 text-center"></div>
                    </div>
                </div>
                 <!-- Lista de regras salvas -->
                <div class="mt-8 bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                     <h2 class="text-xl font-semibold text-gray-200 mb-4">Regras de Downtime Salvas</h2>
                     <div id="regras-downtime-list-container">
                         <!-- A lista de regras ser√° inserida aqui -->
                     </div>
                </div>
                <!-- Lista de metas salvas -->
                <div class="mt-8 bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                     <h2 class="text-xl font-semibold text-gray-200 mb-4">Metas por Atividade Salvas</h2>
                     <div id="regras-meta-list-container">
                         <!-- A lista de metas ser√° inserida aqui -->
                     </div>
                </div>
                <!-- Filtro de Operadores para Hist√≥rico Mensal -->
                <div class="mt-8 bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                     <h2 class="text-xl font-semibold text-gray-200 mb-4">Operadores Vis√≠veis no Hist√≥rico Mensal de Empilhadeira</h2>
                     <p class="text-sm text-gray-400 mb-4">Selecione os operadores que devem aparecer no hist√≥rico mensal. Operadores n√£o selecionados ser√£o ocultados.</p>
                     <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Selecionar Operadores</label>
                        <div id="operator-filter-container" class="bg-gray-700 p-4 rounded-md max-h-60 overflow-y-auto">
                            <div class="flex items-center mb-3">
                                <input type="checkbox" id="select-all-operators" class="mr-2 h-4 w-4 rounded border-gray-600 bg-gray-700 text-blue-600 focus:ring-blue-500">
                                <label for="select-all-operators" class="text-sm text-gray-300 font-medium">Selecionar Todos</label>
                            </div>
                            <div id="operator-checkboxes" class="space-y-2">
                                <!-- Operator checkboxes will be populated here -->
                                <p class="text-sm text-gray-400">Carregue dados de movimenta√ß√£o para ver os operadores dispon√≠veis.</p>
                            </div>
                        </div>
                     </div>
                     <button id="save-operator-filter-btn" class="btn-primary py-2 px-4 rounded-lg w-full">Salvar Filtro de Operadores</button>
                     <div id="operator-filter-feedback" class="mt-4 text-center"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modal para Lan√ßar Downtime -->
    <div id="downtime-modal" class="fixed inset-0 z-50 flex items-center justify-center hidden modal-backdrop">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border border-gray-700"> <!-- Background original -->
             <h2 class="text-xl font-semibold text-gray-200 mb-4">Lan√ßar Downtime para <span id="modal-operator-name" class="font-bold text-blue-400"></span></h2> <!-- Cor original -->
             <form id="form-lancar-downtime">
                 <input type="hidden" id="modal-operator-id">
                 <div class="mb-4">
                     <label for="modal-downtime-reason" class="block text-sm font-medium text-gray-300">Motivo</label>
                     <select id="modal-downtime-reason" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" required></select>
                 </div>
                 <div id="modal-downtime-list" class="mb-4 space-y-2 max-h-40 overflow-y-auto p-2 bg-gray-700 rounded"> <!-- Cor original -->
                    <!-- Lan√ßamentos de downtime ser√£o listados aqui -->
                 </div>
                 <div class="flex justify-end gap-4 mt-6">
                    <button type="button" id="modal-close-btn" class="px-4 py-2 rounded-lg text-gray-300 hover:bg-gray-600">Fechar</button> <!-- Cor original -->
                    <button type="submit" class="btn-primary py-2 px-4 rounded-lg">Adicionar Downtime</button> <!-- Removed font-bold -->
                 </div>
             </form>
        </div>
    </div>

    <!-- Feedback Message Container -->
    <div id="feedback-message-container"></div>


    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, enableIndexedDbPersistence, collection, doc, writeBatch, query, getDocs, where, addDoc, onSnapshot, deleteDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        document.addEventListener('DOMContentLoaded', () => {

            // --- Firebase Initialization ---
            // Firebase JS SDK v7.20.0 and later, measurementId is optional
            const firebaseConfig = {
                apiKey: "AIzaSyB08BJEhc0dUyixg7ojVsfMq4vJ8vtqn4U",
                authDomain: "teste-30bbd.firebaseapp.com",
                projectId: "teste-30bbd",
                storageBucket: "teste-30bbd.firebasestorage.app",
                messagingSenderId: "295398939050",
                appId: "1:295398939050:web:6da4cfd8a41b9f2a7df3d3",
                measurementId: "G-F6X87CW0TB"
            };

            // Use environment variable for App ID
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Use provided appId or a default

            // --- App State ---
            
            // *** EXPLICA√á√ïES DOS C√ÅLCULOS DOS GR√ÅFICOS (GLOBAL) ***
            const chartExplanations = {
                expMensal: `
                    <h4>üìä Expedi√ß√£o Mensal</h4>
                    <div class="formula">Total de Itens Expedidos no M√™s</div>
                    <p><strong>C√°lculo:</strong> Soma de todos os itens expedidos registrados no per√≠odo mensal selecionado.</p>
                    <p><strong>% Crescimento:</strong> Compara√ß√£o com o m√™s anterior para identificar tend√™ncias.</p>
                `,
                movMensais: `
                    <h4>üöõ Movimenta√ß√µes de Empilhadeira</h4>
                    <div class="formula">Total de Movimenta√ß√µes √önicas por Dia</div>
                    <p><strong>C√°lculo:</strong> Contagem de movimenta√ß√µes de empilhadeira por operador √∫nico por dia, separadas por turno.</p>
                    <p><strong>Filtros:</strong> Exclui registros marcados como "VERIFICAR" e aplica filtro de operadores configurado na aba Regras.</p>
                    <p><strong>‚öôÔ∏è Configura√ß√£o:</strong> Para definir quais operadores s√£o inclu√≠dos, v√° em Regras ‚Üí Operadores Vis√≠veis.</p>
                `,
                mediaExpDia: `
                    <h4>üì¶ M√©dia Di√°ria de Expedi√ß√£o</h4>
                    <div class="formula">Quantidade Expedida √∑ Horas Normais de Expedi√ß√£o</div>
                    <p><strong>C√°lculo:</strong> Total de itens expedidos dividido pelas horas trabalhadas do setor (descontando downtime).</p>
                    <p><strong>Per√≠odo:</strong> M√©dia calculada por dia √∫til para an√°lise de produtividade.</p>
                `,
                mediaMovDia: `
                    <h4>üîÑ M√©dia Di√°ria de Movimenta√ß√µes</h4>
                    <div class="formula">Movimenta√ß√µes √önicas √∑ Horas Trabalhadas</div>
                    <p><strong>C√°lculo:</strong> N√∫mero de movimenta√ß√µes √∫nicas por operador dividido pelas horas efetivamente trabalhadas.</p>
                    <p><strong>Base:</strong> Considera apenas dias √∫teis e exclui pausas/downtime.</p>
                    <p><strong>Filtros:</strong> Aplica filtro de operadores configurado na aba Regras.</p>
                    <p><strong>‚öôÔ∏è Configura√ß√£o:</strong> Para definir quais operadores s√£o inclu√≠dos, v√° em Regras ‚Üí Operadores Vis√≠veis.</p>
                `,
                tempoMedioMovimentacao: `
                    <h4>‚è±Ô∏è Tempo M√©dio de Movimenta√ß√£o</h4>
                    <div class="formula">M√©dia do Campo "Tempo" por Turno</div>
                    <p><strong>C√°lculo:</strong> M√©dia aritm√©tica dos tempos registrados nas movimenta√ß√µes por turno (1¬∞T vs 2¬∞T).</p>
                    <p><strong>Convers√£o:</strong> Valores decimais convertidos para formato HH:MM:SS.</p>
                    <p><strong>Filtros:</strong> Exclui registros com valida√ß√£o "VERIFICAR" e aplica filtro de operadores configurado na aba Regras.</p>
                    <p><strong>‚öôÔ∏è Configura√ß√£o:</strong> Para definir quais operadores s√£o inclu√≠dos no c√°lculo, v√° em Regras ‚Üí Operadores Vis√≠veis.</p>
                `,
                horasPrevistas: `
                    <h4>‚è∞ Horas Previstas vs Realizadas</h4>
                    <div class="formula">Horas Previstas vs Horas Normais</div>
                    <p><strong>Horas Previstas:</strong> Planejamento de horas de trabalho por setor.</p>
                    <p><strong>Horas Realizadas:</strong> Horas efetivamente trabalhadas (normais + extras - downtime).</p>
                    <p><strong>Compara√ß√£o:</strong> Identifica desvios entre planejado e executado.</p>
                `,
                downtimePorMotivo: `
                    <h4>‚è∏Ô∏è Pausas por Motivo</h4>
                    <div class="formula">% Pausas = (Horas de Pausa √∑ 184:48h) √ó 100</div>
                    <p><strong>Base de C√°lculo:</strong> 184:48h √© a m√©dia mensal de horas por colaborador.</p>
                    <p><strong>Categorias:</strong> Pausa t√©cnica, manuten√ß√£o, falta de sistema, etc.</p>
                    <p><strong>Objetivo:</strong> Identificar principais causas de interrup√ß√µes.</p>
                `,
                horasAbsenteismo: `
                    <h4>üè• Absente√≠smo por Setor</h4>
                    <div class="formula">Total de Horas de Aus√™ncia por M√™s</div>
                    <p><strong>C√°lculo:</strong> Soma das horas de absente√≠smo registradas por setor (faltas, atestados, etc.).</p>
                    <p><strong>Fonte:</strong> Relat√≥rios di√°rios de absente√≠smo processados pelo sistema.</p>
                    <p><strong>An√°lise:</strong> Permite identificar setores com maior √≠ndice de aus√™ncias.</p>
                `,
                quantidadePessoasPicking: `
                    <h4>üë• Quantidade de Pessoas - Picking</h4>
                    <div class="formula">Horas Normais Totais √∑ Maior Hora Prevista Individual</div>
                    <p><strong>C√°lculo:</strong> Divis√£o das horas normais totais do setor pela maior hora prevista individual do m√™s.</p>
                    <p><strong>Objetivo:</strong> Estimar quantas pessoas trabalharam efetivamente no per√≠odo.</p>
                `,
                pickingPorHrPessoa: `
                    <h4>üìä Picking por Hr/Pessoa</h4>
                    <div class="formula">Quantidade Expedida √∑ Horas Normais Picking</div>
                    <p><strong>C√°lculo:</strong> Total de itens do picking dividido pelas horas normais (com desconto de downtime).</p>
                    <p><strong>Produtividade:</strong> Indica efici√™ncia da opera√ß√£o de picking por hora trabalhada.</p>
                `,
                quantidadePessoasExpedicao: `
                    <h4>üë• Quantidade de Pessoas - Expedi√ß√£o</h4>
                    <div class="formula">Horas Normais Totais √∑ Maior Hora Prevista Individual</div>
                    <p><strong>C√°lculo:</strong> Divis√£o das horas normais totais do setor pela maior hora prevista individual do m√™s.</p>
                    <p><strong>Objetivo:</strong> Estimar quantas pessoas trabalharam efetivamente no per√≠odo.</p>
                `,
                expedicaoPorHrPessoa: `
                    <h4>üì¶ Expedi√ß√£o por Hr/Pessoa</h4>
                    <div class="formula">Quantidade Expedida √∑ Horas Normais Expedi√ß√£o</div>
                    <p><strong>C√°lculo:</strong> Total de itens expedidos dividido pelas horas normais (com desconto de downtime).</p>
                    <p><strong>Produtividade:</strong> Indica efici√™ncia da opera√ß√£o de expedi√ß√£o por hora trabalhada.</p>
                `
            };
            
            // === FUN√á√ÉO DE DEBUG PARA VERIFICAR ESTADO DOS DADOS ===
            window.debugDados = function() {
                console.log("=== DEBUG ESTADO DOS DADOS ===");
                console.log("expedicaoData:", expedicaoData.length, "registros");
                console.log("movimentacoesData:", movimentacoesData.length, "registros");
                console.log("absenteismoData:", absenteismoData.length, "registros");
                console.log("operacaoElements:", operacaoElements);
                console.log("metasPorAtividade:", metasPorAtividade);
                console.log("===========================");
                
                if (expedicaoData.length > 0) {
                    console.log("Exemplo expedi√ß√£o:", expedicaoData[0]);
                }
                if (movimentacoesData.length > 0) {
                    console.log("Exemplo movimenta√ß√£o:", movimentacoesData[0]);
                    console.log("Movimenta√ß√µes com tempo v√°lido:", movimentacoesData.filter(m => m.tempo && m.tempo !== '').length);
                }
                if (absenteismoData.length > 0) {
                    console.log("Exemplo absente√≠smo:", absenteismoData[0]);
                }
                
                // Verificar containers de gr√°ficos
                const containers = {
                    logistica: document.getElementById('logistica-charts-container'),
                    tempoMedio: document.getElementById('tempoMedioMovimentacao'),
                    operacao: operacaoElements?.chartsContainer
                };
                console.log("Containers de gr√°ficos:", containers);
                
                return {
                    expedicao: expedicaoData.length,
                    movimentacoes: movimentacoesData.length,
                    absenteismo: absenteismoData.length
                };
            };

            // === FUN√á√ÉO PARA FOR√áAR REC√ÅLCULO ===
            window.forcarRecalculo = function() {
                console.log("üîÑ For√ßando rec√°lculo dos indicadores...");
                if (operacaoElements && operacaoElements.chartsContainer) {
                    calcularIndicadoresOperacao();
                } else {
                    console.error("‚ùå operacaoElements n√£o dispon√≠vel para rec√°lculo");
                    console.log("Tentando reinicializar elementos da opera√ß√£o...");
                    // Tentar reinicializar elementos
                    if (document.getElementById('indicadores-operacao')) {
                        switchTab('operacao');
                        setTimeout(() => calcularIndicadoresOperacao(), 1000);
                    }
                }
            };
            
            // === FUN√á√ÉO PARA TESTAR COM DADOS DE EXEMPLO ===
            window.testarComDadosExemplo = function() {
                console.log("üß™ Criando dados de exemplo para teste...");
                
                // Dados de exemplo para movimenta√ß√µes
                const dadosExemplo = [];
                const hoje = new Date();
                
                for (let i = 0; i < 100; i++) {
                    const data = new Date(hoje.getFullYear(), hoje.getMonth() - Math.floor(Math.random() * 6), Math.floor(Math.random() * 28) + 1);
                    dadosExemplo.push({
                        data: data,
                        tempo: Math.random() * 10 + 1, // 1 a 11 minutos
                        turno: Math.random() > 0.5 ? '1¬∞ TURNO' : '2¬∞ TURNO',
                        validacao: Math.random() > 0.9 ? 'VERIFICAR' : 'OK'
                    });
                }
                
                console.log("Dados de exemplo criados:", dadosExemplo.length, "registros");
                
                // Backup dos dados originais
                const backupMovimentacoes = [...movimentacoesData];
                
                // Usar dados de exemplo
                movimentacoesData.length = 0;
                movimentacoesData.push(...dadosExemplo);
                
                console.log("Testando com dados de exemplo...");
                calcularIndicadoresOperacao();
                
                // Restaurar dados originais ap√≥s 10 segundos
                setTimeout(() => {
                    movimentacoesData.length = 0;
                    movimentacoesData.push(...backupMovimentacoes);
                    console.log("Dados originais restaurados");
                }, 10000);
            };

            let app, db, auth;
            let isFirebaseInitialized = false;
            let firebaseInitPromise = null; // Promise para aguardar inicializa√ß√£o
            
            // === TRATAMENTO DE ERROS GLOBAIS ===
            // Capturar erros n√£o cr√≠ticos e evitar spam no console
            window.addEventListener('error', function(event) {
                const errorMessage = event.message || '';
                const errorSource = event.filename || '';
                
                // Filtrar erros conhecidos n√£o cr√≠ticos
                const nonCriticalErrors = [
                    'message channel closed before a response was received',
                    'Non-Error promise rejection captured',
                    'ResizeObserver loop limit exceeded',
                    'Extension context invalidated'
                ];
                
                const isNonCritical = nonCriticalErrors.some(pattern => 
                    errorMessage.toLowerCase().includes(pattern.toLowerCase())
                );
                
                if (isNonCritical) {
                    console.debug('üîá Erro n√£o cr√≠tico filtrado:', errorMessage);
                    event.preventDefault();
                    return false;
                }
                
                // Permitir que erros cr√≠ticos sejam exibidos
                console.error('‚ùå Erro capturado:', errorMessage, 'em:', errorSource);
            });
            
            // Capturar promise rejections n√£o tratadas
            window.addEventListener('unhandledrejection', function(event) {
                const reason = event.reason || '';
                const reasonStr = reason.toString ? reason.toString() : String(reason);
                
                // Filtrar rejections n√£o cr√≠ticas
                if (reasonStr.includes('message channel closed') || 
                    reasonStr.includes('Extension context')) {
                    console.debug('üîá Promise rejection n√£o cr√≠tica filtrada:', reasonStr);
                    event.preventDefault();
                    return false;
                }
                
                console.error('‚ùå Promise rejection n√£o tratada:', reason);
            });
            
            // Fun√ß√£o auxiliar para aguardar inicializa√ß√£o do Firebase
            async function waitForFirebaseInit() {
                if (isFirebaseInitialized) return true;
                
                // Aguardar at√© 10 segundos pela inicializa√ß√£o
                let attempts = 0;
                const maxAttempts = 50; // 10 segundos (50 * 200ms)
                
                while (!isFirebaseInitialized && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    attempts++;
                }
                
                return isFirebaseInitialized;
            }
            let userId = null; // To store the authenticated user ID
            let expedicaoData = [];
            let movimentacoesData = [];
            let absenteismoData = []; // Store parsed absenteismo data temporarily
            let absenteismoFileDate = null;
            let unsubDowntime, unsubMetas;
            let metasPorAtividade = {};
            let downtimeRules = []; // AGORA VAI GUARDAR AS REGRAS (DA ABA REGRAS)
            // operatorPerformanceData removido - Dashboard exclu√≠do
            let charts = {}; // To hold chart instances
            let movViewMode = 'mensal'; // 'mensal' ou 'ultimos30dias' - Estado da visualiza√ß√£o de movimenta√ß√µes
            let selectedOperators = []; // Lista de operadores selecionados para aparecer no hist√≥rico mensal
            let hiddenOperators = new Set(); // Operadores atualmente ocultos no filtro r√°pido

            // --- Global Element Variables ---
            let tabs, expedicaoElements, absenteismoElements, regrasElements, movimentacoesElements, operacaoElements;

             // --- Feedback Message Function ---
            function showFeedback(message, type = 'info', duration = 3000) {
                const container = document.getElementById('feedback-message-container');
                if (!container) {
                    console.error("Feedback container not found!");
                    return;
                }

                const feedbackDiv = document.createElement('div');
                feedbackDiv.className = `feedback-message ${type}`;
                feedbackDiv.textContent = message;
                container.appendChild(feedbackDiv);

                // Trigger reflow to enable transition for showing
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                         feedbackDiv.classList.add('show');
                    });
                });


                // Set timeout to remove the message
                setTimeout(() => {
                    feedbackDiv.classList.remove('show');
                    // Remove the element from the DOM after the transition ends
                    feedbackDiv.addEventListener('transitionend', () => {
                         // Double check parentNode before removal
                        if (feedbackDiv.parentNode === container) {
                            container.removeChild(feedbackDiv);
                        }
                    }, { once: true });
                 }, duration);
            }


            // --- ALL FUNCTIONS ARE DEFINED BELOW ---
            
            // *** CORRE√á√ÉO: Definindo as cores padr√£o do Chart.js UMA VEZ ***
            Chart.defaults.color = '#D1D5DB'; // Cor do texto (eixos, legendas)
            Chart.defaults.borderColor = 'rgba(107, 114, 128, 0.3)'; // Cor das grades
            
            // *** INICIALIZA√á√ÉO SEGURA DO CHART.JS ***
            function initializeChartJS() {
                try {
                    // Verificar se Chart.js est√° dispon√≠vel
                    if (typeof Chart === 'undefined') {
                        console.error("‚ùå Chart.js n√£o carregado");
                        return false;
                    }
                    
                    // Registrar plugin DataLabels se dispon√≠vel
                    if (window.ChartDataLabels) {
                        Chart.register(ChartDataLabels);
                        console.log("‚úÖ ChartDataLabels plugin registrado com sucesso");
                    } else {
                        console.warn("‚ö†Ô∏è Plugin ChartDataLabels n√£o encontrado - continuando sem labels");
                    }
                    
                    return true;
                } catch (error) {
                    console.error("‚ùå Erro ao inicializar Chart.js:", error);
                    return false;
                }
            }
            
            // Tentar inicializar Chart.js
            const chartInitialized = initializeChartJS();


            async function initializeFirebase() {
                try {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);

                    // *** CORRE√á√ÉO ROBUSTA IndexedDB: Tratar erros de corrup√ß√£o e reinicializar ***
                    try {
                        await enableIndexedDbPersistence(db);
                        console.log("Firebase persistence enabled.");
                    } catch (error) {
                        if (error.code == 'failed-precondition') {
                            console.warn("Firebase persistence failed (multiple tabs open?):", error.message);
                            // Esta √© uma falha esperada se o usu√°rio tiver v√°rios tabs abertos
                        } else if (error.message && error.message.includes('IndexedDB database data')) {
                            // Erro de corrup√ß√£o do IndexedDB - oferece solu√ß√£o ao usu√°rio
                            console.error("IndexedDB corrompido detectado:", error.message);
                            
                            const userResponse = confirm(
                                "Detectamos um problema com o armazenamento local (IndexedDB corrompido).\n\n" +
                                "Para corrigir:\n" +
                                "‚Ä¢ Clique OK para tentar limpar os dados e recarregar\n" +
                                "‚Ä¢ Ou feche todas as abas deste site e reabra\n\n" +
                                "Deseja limpar os dados locais agora?"
                            );
                            
                            if (userResponse) {
                                try {
                                    // Tenta limpar os dados do IndexedDB
                                    if ('indexedDB' in window) {
                                        // Lista poss√≠veis bancos Firebase
                                        const firebaseDbs = [
                                            'firestore/' + firebaseConfig.projectId + '/default',
                                            'firebase-app-check-database',
                                            'firebase-messaging-database'
                                        ];
                                        
                                        for (const dbName of firebaseDbs) {
                                            try {
                                                await new Promise((resolve, reject) => {
                                                    const deleteReq = indexedDB.deleteDatabase(dbName);
                                                    deleteReq.onsuccess = () => resolve();
                                                    deleteReq.onerror = () => reject(deleteReq.error);
                                                    deleteReq.onblocked = () => {
                                                        console.warn(`Dele√ß√£o do banco ${dbName} bloqueada`);
                                                        resolve(); // Continue mesmo se bloqueado
                                                    };
                                                });
                                                console.log(`Banco ${dbName} limpo com sucesso`);
                                            } catch (dbError) {
                                                console.warn(`Erro ao limpar banco ${dbName}:`, dbError);
                                            }
                                        }
                                    }
                                    
                                    // Limpa localStorage relacionado ao Firebase
                                    Object.keys(localStorage).forEach(key => {
                                        if (key.startsWith('firebase:') || key.includes('firestore')) {
                                            localStorage.removeItem(key);
                                        }
                                    });
                                    
                                    showFeedback("Dados locais limpos. Recarregando p√°gina...", "success");
                                    setTimeout(() => window.location.reload(), 1500);
                                    return; // Interrompe execu√ß√£o
                                    
                                } catch (cleanupError) {
                                    console.error("Erro ao limpar dados:", cleanupError);
                                    showFeedback("Erro na limpeza. Recarregue manualmente a p√°gina.", "error");
                                }
                            } else {
                                showFeedback("Feche todas as abas e reabra o site para resolver o problema.", "warning");
                            }
                        } else {
                            console.error("Firebase persistence failed to enable (outro erro IndexedDB):", error.message);
                            showFeedback("Persist√™ncia local (offline) falhou: " + error.message, "warning");
                        }
                    }
                    // *** FIM DA CORRE√á√ÉO ROBUSTA ***

                     // Use provided token or sign in anonymously
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) { // Check if token is non-empty
                        await signInWithCustomToken(auth, __initial_auth_token);
                        console.log("Firebase initialized and user signed in with custom token.");
                    } else {
                        await signInAnonymously(auth);
                        console.log("Firebase initialized and user signed in anonymously.");
                    }

                    // Wait for auth state to be confirmed before getting user ID
                    await new Promise(resolve => {
                        const unsubscribe = auth.onAuthStateChanged(user => {
                            if (user) {
                                userId = user.uid;
                            } else {
                                // Handle anonymous user ID generation if needed, or rely on rules
                                userId = `anon_${crypto.randomUUID()}`; // Example for anonymous
                            }
                            unsubscribe();
                            resolve();
                        });
                    });

                    isFirebaseInitialized = true;
                    console.log("Using User ID:", userId); // Log the user ID
                    console.log("Using App ID:", appId);   // Log the app ID


                    // Load data associated with the user/app
                    loadAbsenteismoHistory(); // Load initial history for today
                    listenForDowntimeUpdates();
                    listenForMetasUpdates();
                    loadOperatorFilter(); // Load saved operator filter
                    
                    // *** MODIFICADO: Carregamento autom√°tico simplificado ***
                    console.log("üîÑ Verificando disponibilidade de dados...");
                    checkDataAvailability();

                } catch (error) {
                    console.error("Critical Firebase Initialization Error:", error);
                     showFeedback("Erro cr√≠tico ao inicializar o banco de dados. Funcionalidades de salvar/carregar podem n√£o funcionar.", "error", 5000);
                }
            }

            // *** NOVA FUN√á√ÉO: Verificar disponibilidade de dados ***
            function checkDataAvailability() {
                console.log("üìÇ Verificando status dos dados...");
                
                // Verificar info dos dados no localStorage
                const expedicaoInfo = localStorage.getItem('expedicaoDataInfo');
                const movimentacoesInfo = localStorage.getItem('movimentacoesDataInfo');
                
                if (expedicaoInfo && movimentacoesInfo) {
                    const expInfo = JSON.parse(expedicaoInfo);
                    const movInfo = JSON.parse(movimentacoesInfo);
                    
                    console.log(`üìä Status dos dados:`);
                    console.log(`- Expedi√ß√£o: ${expInfo.count} registros (${expInfo.lastUpdate})`);
                    console.log(`- Movimenta√ß√µes: ${movInfo.count} registros (${movInfo.lastUpdate})`);
                    
                    if (expInfo.hasData && movInfo.hasData) {
                        console.log("‚úÖ Dados dispon√≠veis - calculando indicadores...");
                        // Se h√° dados dispon√≠veis mas as vari√°veis est√£o vazias, mostrar instru√ß√µes
                        if (expedicaoData.length === 0 || movimentacoesData.length === 0) {
                            showFeedback("Dados encontrados! Por favor, reimporte os arquivos para visualizar os gr√°ficos.", "info", 8000);
                        }
                    } else {
                        console.log("üì≠ Nenhum dado v√°lido encontrado");
                    }
                } else {
                    console.log("üì≠ Nenhuma informa√ß√£o de dados encontrada no localStorage");
                    showFeedback("Para visualizar os gr√°ficos, fa√ßa upload dos arquivos de Expedi√ß√£o e Movimenta√ß√µes.", "info", 6000);
                }
            }

            // --- Firestore Path Helper ---
            // Helper to get correct Firestore paths
            function getFirestorePath(collectionName, isPublic = false) {
                 if (!isFirebaseInitialized || !userId || !appId) { // Ensure Firebase is initialized and both userId and appId are available
                    console.error("Firebase not initialized or User ID/App ID not available for Firestore path.");
                    console.log("Debug - isFirebaseInitialized:", isFirebaseInitialized, "userId:", userId, "appId:", appId);
                    showFeedback("Erro: Firebase n√£o inicializado ou IDs indispon√≠veis.", "error");
                    return null; // Or handle appropriately
                }
                if (isPublic) {
                    // Public data path
                    return `artifacts/${appId}/public/data/${collectionName}`;
                } else {
                    // Private user data path (default)
                    return `artifacts/${appId}/users/${userId}/${collectionName}`;
                }
            }


            function switchTab(targetTab) {
                Object.values(tabs).forEach(tab => {
                    if (tab.btn && tab.content) { // Check if elements exist
                        tab.btn.classList.remove('active');
                        tab.content.classList.add('hidden');
                    }
                });
                if (tabs[targetTab] && tabs[targetTab].btn && tabs[targetTab].content) { // Check target exists
                    tabs[targetTab].btn.classList.add('active');
                    tabs[targetTab].content.classList.remove('hidden');

                    // If switching to 'Indicadores de Opera√ß√£o', attempt to calculate/render charts
                    if(targetTab === 'operacao' && operacaoElements && operacaoElements.chartsContainer) { // Check if elements are ready
                         if (expedicaoData.length > 0 && movimentacoesData.length > 0) {
                            calcularIndicadoresOperacao();
                         } else {
                             // Ensure placeholder is shown if data isn't ready
                             operacaoElements.chartsContainer.classList.add('hidden');
                             operacaoElements.placeholder.classList.remove('hidden');
                         }
                    }
                } else {
                    console.error(`Tab or elements for "${targetTab}" not found.`);
                }
            }


            function setupFileInput(elements, fileHandler) {
                // Ensure elements exist before adding listeners
                if (!elements || !elements.dropZone || !elements.fileInput || !elements.removeBtn) {
                    console.error("Missing elements for file input setup:", elements);
                    return;
                }
                elements.dropZone.addEventListener('click', () => elements.fileInput.click());
                elements.dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    elements.dropZone.classList.add('dragover');
                });
                elements.dropZone.addEventListener('dragleave', () => elements.dropZone.classList.remove('dragover'));
                elements.dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    elements.dropZone.classList.remove('dragover');
                    if (e.dataTransfer.files.length) {
                        elements.fileInput.files = e.dataTransfer.files;
                        fileHandler(e.dataTransfer.files[0]);
                    }
                });
                elements.fileInput.addEventListener('change', (e) => {
                     if (e.target.files.length) {
                        fileHandler(e.target.files[0]);
                    }
                });
                elements.removeBtn.addEventListener('click', () => {
                    elements.fileInput.value = ''; // Clear the file input
                    // Reset UI elements safely, checking they exist first
                    if (elements.fileInfo) elements.fileInfo.classList.add('hidden');
                    if (elements.dropZone) elements.dropZone.classList.remove('hidden');
                    if (elements.fileLabel) elements.fileLabel.classList.remove('hidden');

                    if (elements.previewContainer) elements.previewContainer.classList.add('hidden');
                    if (elements.feedback) elements.feedback.innerHTML = '';


                    // Clear relevant data and update dependent UI sections
                    if (elements === expedicaoElements) {
                        console.log("üóëÔ∏è Limpando dados de expedi√ß√£o");
                        expedicaoData = [];
                        if (operacaoElements && operacaoElements.chartsContainer && operacaoElements.placeholder) {
                            operacaoElements.chartsContainer.classList.add('hidden');
                            operacaoElements.placeholder.classList.remove('hidden');
                        }
                    } else if (elements === movimentacoesElements) {
                        console.log("üóëÔ∏è Limpando dados de movimenta√ß√µes");
                        movimentacoesData = [];
                        if (movimentacoesElements && movimentacoesElements.dashboardContent && movimentacoesElements.placeholder) {
                            movimentacoesElements.dashboardContent.innerHTML = '';
                            movimentacoesElements.placeholder.classList.remove('hidden');
                        }
                        if (operacaoElements && operacaoElements.chartsContainer && operacaoElements.placeholder) {
                            operacaoElements.chartsContainer.classList.add('hidden');
                            operacaoElements.placeholder.classList.remove('hidden');
                        }
                         // Dashboard foi removido - c√≥digo limpo
                    }
                });
            }

            function showFileInfo(elements, file) {
                // Check if elements exist before manipulating them
                if (!elements || !elements.fileInfoP || !elements.dropZone || !elements.fileInfo || !elements.fileLabel) {
                    console.error("Missing elements for showFileInfo:", elements);
                    return;
                }
                elements.fileInfoP.textContent = `Arquivo selecionado: ${file.name}`;
                elements.dropZone.classList.add('hidden');
                elements.fileInfo.classList.remove('hidden');
                elements.fileLabel.classList.add('hidden');
            }

            // --- Setup Multiple File Input for Absente√≠smo ---
            function setupMultipleFileInput(elements) {
                if (!elements || !elements.dropZone || !elements.fileInput) {
                    console.error("Missing elements for multiple file input setup:", elements);
                    return;
                }

                let selectedFiles = [];

                // Click to select files
                elements.dropZone.addEventListener('click', () => elements.fileInput.click());

                // Drag and drop
                elements.dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    elements.dropZone.classList.add('dragover');
                });
                elements.dropZone.addEventListener('dragleave', () => elements.dropZone.classList.remove('dragover'));
                elements.dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    elements.dropZone.classList.remove('dragover');
                    if (e.dataTransfer.files.length) {
                        handleMultipleFiles(Array.from(e.dataTransfer.files));
                    }
                });

                // File input change
                elements.fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length) {
                        handleMultipleFiles(Array.from(e.target.files));
                    }
                });

                // Remove all files
                elements.removeAllBtn.addEventListener('click', () => {
                    selectedFiles = [];
                    elements.fileInput.value = '';
                    updateFilesList();
                    elements.previewContainer.classList.add('hidden');
                    elements.feedback.innerHTML = '';
                });

                // Process files button
                elements.processBtn.addEventListener('click', () => {
                    console.log(`Bot√£o clicado! Arquivos selecionados: ${selectedFiles.length}`);
                    if (selectedFiles.length > 0) {
                        console.log('Iniciando processamento...');
                        processMultipleAbsenteismoFiles(selectedFiles);
                    } else {
                        console.log('Nenhum arquivo selecionado!');
                    }
                });

                function handleMultipleFiles(files) {
                    // Add new files to selected files (avoid duplicates by name)
                    files.forEach(file => {
                        if (!selectedFiles.some(f => f.name === file.name)) {
                            selectedFiles.push(file);
                        }
                    });
                    updateFilesList();
                }

                function updateFilesList() {
                    if (selectedFiles.length === 0) {
                        elements.filesList.classList.add('hidden');
                        return;
                    }

                    elements.filesList.classList.remove('hidden');
                    elements.filesContainer.innerHTML = '';

                    selectedFiles.forEach((file, index) => {
                        const fileItem = document.createElement('div');
                        fileItem.className = 'flex justify-between items-center bg-gray-600 p-2 rounded text-sm';
                        fileItem.innerHTML = `
                            <span class="text-gray-200">${file.name}</span>
                            <button class="text-red-400 hover:text-red-500 text-xs" onclick="removeFile(${index})">Remover</button>
                        `;
                        elements.filesContainer.appendChild(fileItem);
                    });
                }

                // Make removeFile function global for onclick access
                window.removeFile = function(index) {
                    selectedFiles.splice(index, 1);
                    updateFilesList();
                };
            }

            // --- Process Multiple Absente√≠smo Files ---
            let processedAbsenteismoData = []; // Store all processed data

            async function processMultipleAbsenteismoFiles(files) {
                console.log(`Iniciando processamento de ${files.length} arquivo(s)`);
                absenteismoElements.loader.classList.remove('hidden');
                absenteismoElements.feedback.innerHTML = '';
                absenteismoElements.previewList.innerHTML = '';
                processedAbsenteismoData = [];

                let successCount = 0;
                let errorCount = 0;

                for (const file of files) {
                    console.log(`Processando arquivo: ${file.name}`);
                    try {
                        const data = await parseAbsenteismoFile(file);
                        processedAbsenteismoData.push(...data);
                        successCount++;
                        console.log(`Arquivo ${file.name} processado com sucesso: ${data.length} registros`);

                        // Add to preview
                        const previewItem = document.createElement('div');
                        previewItem.className = 'text-sm text-green-400';
                        previewItem.innerHTML = `‚úì ${file.name}: ${data.length} registros processados`;
                        absenteismoElements.previewList.appendChild(previewItem);

                    } catch (error) {
                        errorCount++;
                        console.error(`Erro ao processar arquivo ${file.name}:`, error);
                        const errorItem = document.createElement('div');
                        errorItem.className = 'text-sm text-red-400';
                        errorItem.innerHTML = `‚úó ${file.name}: ${error.message}`;
                        absenteismoElements.previewList.appendChild(errorItem);
                    }
                }

                absenteismoElements.loader.classList.add('hidden');

                if (successCount > 0) {
                    absenteismoElements.previewContainer.classList.remove('hidden');
                    absenteismoElements.feedback.innerHTML = `
                        <p class="text-green-400 text-sm">
                            ${successCount} arquivo(s) processado(s) com sucesso. 
                            Total: ${processedAbsenteismoData.length} registros.
                        </p>
                    `;
                    if (errorCount > 0) {
                        absenteismoElements.feedback.innerHTML += `
                            <p class="text-yellow-400 text-sm">${errorCount} arquivo(s) com erro.</p>
                        `;
                    }
                } else {
                    absenteismoElements.feedback.innerHTML = `
                        <p class="text-red-400 text-sm">Nenhum arquivo foi processado com sucesso.</p>
                    `;
                }
            }

            // --- Parse Single Absente√≠smo File (extracted from original function) ---
            async function parseAbsenteismoFile(file) {
                return new Promise((resolve, reject) => {
                    console.log(`Iniciando processamento do arquivo: ${file.name}`);
                    console.log(`üîÑ VERS√ÉO ATUALIZADA v2.0 - ${new Date().getTime()} - PROCURANDO DATA NA C4`);
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            console.log(`Lendo dados do arquivo: ${file.name}`);
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const sheetName = workbook.SheetNames[0];
                            console.log(`Nome da planilha: ${sheetName}`);
                            const worksheet = workbook.Sheets[sheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                            console.log(`Dados extra√≠dos, ${jsonData.length} linhas encontradas`);

                            if (jsonData.length < 2) {
                                reject(new Error('Arquivo vazio ou sem dados v√°lidos.'));
                                return;
                            }

                            const headers = jsonData[0];
                            console.log(`Cabe√ßalhos encontrados:`, headers);
                            console.log(`Primeira linha completa:`, jsonData[1]);
                            console.log(`Segunda linha (se existir):`, jsonData[2]);
                            console.log(`Linha 4 (onde deve estar a data):`, jsonData[3]);
                            
                            // A data est√° sempre na c√©lula C4 (linha 4, coluna C = √≠ndice [3][2])
                            let reportDateValue = null;
                            if (jsonData.length > 3 && jsonData[3] && jsonData[3][2]) {
                                reportDateValue = jsonData[3][2];
                                console.log(`Data encontrada na c√©lula C4:`, reportDateValue, `Tipo: ${typeof reportDateValue}`);
                            } else {
                                console.error('Estrutura do arquivo:', {
                                    headers: headers,
                                    totalRows: jsonData.length,
                                    linha4: jsonData[3]
                                });
                                reject(new Error('Data n√£o encontrada na c√©lula C4. Verifique se o arquivo tem o formato correto.'));
                                return;
                            }

                            let reportDate;

                            if (typeof reportDateValue === 'number') {
                                reportDate = new Date((reportDateValue - 25569) * 86400 * 1000);
                                console.log(`Data convertida de n√∫mero:`, reportDate);
                            } else if (typeof reportDateValue === 'string') {
                                console.log(`üéØ NOVA VERS√ÉO v2.0 - Processando string: "${reportDateValue}"`);
                                
                                // M√©todo mais direto: extrair qualquer data DD/MM/AAAA da string
                                const allDateMatches = reportDateValue.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/g);
                                console.log(`üìÖ Datas encontradas na string:`, allDateMatches);
                                
                                if (allDateMatches && allDateMatches.length >= 2) {
                                    // Extrair data inicial e final do per√≠odo
                                    const dataInicial = allDateMatches[0];
                                    const dataFinal = allDateMatches[1];
                                    console.log(`üéØ Per√≠odo encontrado: ${dataInicial} a ${dataFinal}`);
                                    
                                    // Usar a primeira data como refer√™ncia para o relat√≥rio
                                    const [day, month, year] = dataInicial.split('/');
                                    reportDate = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day)));
                                    console.log(`‚úÖ Data criada:`, reportDate);
                                    console.log(`üìù String final da data: ${reportDate.toISOString().split('T')[0]}`);
                                    
                                    // Calcular dias √∫teis do per√≠odo espec√≠fico
                                    const [dayFinal, monthFinal, yearFinal] = dataFinal.split('/');
                                    const dataFinalObj = new Date(Date.UTC(parseInt(yearFinal), parseInt(monthFinal) - 1, parseInt(dayFinal)));
                                    
                                    // Armazenar per√≠odo para uso posterior
                                    window.periodoDados = {
                                        dataInicial: new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day))),
                                        dataFinal: dataFinalObj,
                                        ano: parseInt(year),
                                        mes: parseInt(month)
                                    };
                                    
                                    console.log(`üìä Per√≠odo armazenado:`, window.periodoDados);
                                    
                                } else if (allDateMatches && allDateMatches.length === 1) {
                                    // S√≥ uma data encontrada
                                    const firstDate = allDateMatches[0];
                                    console.log(`üéØ Usando primeira data encontrada: ${firstDate}`);
                                    
                                    const [day, month, year] = firstDate.split('/');
                                    reportDate = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day)));
                                    console.log(`‚úÖ Data criada:`, reportDate);
                                    console.log(`üìù String final da data: ${reportDate.toISOString().split('T')[0]}`);
                                    
                                    // Armazenar per√≠odo simples
                                    window.periodoDados = {
                                        dataInicial: reportDate,
                                        dataFinal: reportDate,
                                        ano: parseInt(year),
                                        mes: parseInt(month)
                                    };
                                    
                                    console.log(`üìä Per√≠odo simples armazenado:`, window.periodoDados);
                                } else {
                                    console.error(`‚ùå Nenhuma data encontrada no formato DD/MM/AAAA em: "${reportDateValue}"`);
                                    reject(new Error(`Formato de data n√£o reconhecido: ${reportDateValue}`));
                                    return;
                                }
                            } else {
                                reject(new Error('Formato de data inv√°lido.'));
                                return;
                            }

                            if (isNaN(reportDate.getTime())) {
                                reject(new Error('Data inv√°lida no arquivo.'));
                                return;
                            }

                            console.log(`Data final processada: ${reportDate.toISOString().split('T')[0]}`);

                            const processedData = [];
                            // Come√ßar a processar dados a partir da linha que cont√©m os dados reais
                            // Vamos procurar pela linha que cont√©m cabe√ßalhos de dados (provavelmente ap√≥s as informa√ß√µes iniciais)
                            let dataStartRow = -1;
                            
                            console.log('üîç Procurando linha de in√≠cio dos dados...');
                            for (let i = 0; i < jsonData.length; i++) {
                                const row = jsonData[i];
                                console.log(`Linha ${i}:`, row);
                                if (row && row[1]) {
                                    const cellValue = String(row[1]).toLowerCase();
                                    // Procurar especificamente por "Colaborador" no cabe√ßalho (coluna 1)
                                    if (cellValue.includes('colaborador')) {
                                        dataStartRow = i + 1; // Dados come√ßam na pr√≥xima linha
                                        console.log(`‚úÖ Dados dos colaboradores come√ßam na linha ${dataStartRow}`);
                                        break;
                                    }
                                }
                            }
                            
                            // Se n√£o encontrou cabe√ßalho espec√≠fico, assumir que dados come√ßam na linha 6 (ap√≥s informa√ß√µes gerais)
                            if (dataStartRow === -1) {
                                dataStartRow = 6;
                                console.log(`‚ö†Ô∏è Assumindo que dados come√ßam na linha ${dataStartRow}`);
                            }
                            
                            console.log(`üìä Processando dados da linha ${dataStartRow} at√© ${jsonData.length - 1}...`);
                            
                            for (let i = dataStartRow; i < jsonData.length; i++) {
                                try {
                                    const row = jsonData[i];
                                    console.log(`Processando linha ${i}:`, row);
                                
                                    // DEBUG: Mostrar estrutura da planilha apenas na primeira linha v√°lida
                                    if (i === dataStartRow) {
                                        console.log('=== DEBUG ESTRUTURA DA PLANILHA ===');
                                        console.log('Total de colunas:', row ? row.length : 'ROW √â NULL');
                                        if (row && Array.isArray(row)) {
                                            for (let col = 0; col < row.length; col++) {
                                                console.log(`Coluna ${col}: "${row[col]}" (tipo: ${typeof row[col]})`);
                                            }
                                        } else {
                                            console.log('‚ö†Ô∏è ROW n√£o √© um array v√°lido:', row);
                                        }
                                        console.log('=====================================');
                                    }
                                    
                                    // Verifica√ß√£o b√°sica se a linha existe
                                    if (!row || !Array.isArray(row)) {
                                        console.log(`‚ùå Linha ${i} √© null/undefined ou n√£o √© array, pulando...`);
                                        continue;
                                    }
                                
                                // Os nomes dos colaboradores est√£o na coluna 1 (√≠ndice 1)
                                // Verificar se a linha tem dados v√°lidos de colaborador
                                if (!row || !row[1] || 
                                    (row[1] && String(row[1]).trim() === '') || 
                                    (row[1] && String(row[1]).includes('C√≥d. Externo')) ||
                                    (row[1] && String(row[1]).includes('Colaborador')) ||
                                    (row[1] && String(row[1]).includes('Total Geral')) ||
                                    (row[1] && String(row[1]).includes('P√°gina')) ||
                                    (row[1] && String(row[1]).includes('Relat√≥rio')) ||
                                    (row[0] && String(row[0]).includes('CPF/CNPJ')) ||
                                    (row[0] && String(row[0]).includes('Per√≠odo')) ||
                                    typeof row[0] === 'number') {
                                    console.log(`‚ùå Linha ${i} n√£o √© um colaborador v√°lido, pulando...`);
                                    continue;
                                }

                                // === NOVA L√ìGICA: DADOS MENSAIS ACUMULADOS ===
                                // Calcular dias √∫teis do m√™s at√© a data do relat√≥rio
                                const anoRelatorio = reportDate.getUTCFullYear();
                                const mesRelatorio = reportDate.getUTCMonth() + 1;
                                const diaRelatorio = reportDate.getUTCDate();
                                
                                console.log(`üóìÔ∏è DEBUG DATA: reportDate=${reportDate.toISOString()}, ano=${anoRelatorio}, m√™s=${mesRelatorio}, dia=${diaRelatorio}`);
                                
                                const diasUteisNoMes = calcularDiasUteis(anoRelatorio, mesRelatorio, diaRelatorio);
                                
                                // Estruturar dados mensais (n√£o mais di√°rios)
                                const registro = {
                                    // Usar primeiro dia do m√™s como refer√™ncia
                                    data: `${anoRelatorio}-${mesRelatorio.toString().padStart(2, '0')}-01`,
                                    mesAno: `${anoRelatorio}-${mesRelatorio.toString().padStart(2, '0')}`,
                                    colaborador: row[1] || '', // Nome na coluna 1
                                    cargo: row[3] || '', // Cargo na coluna 3
                                    locaisDeTrabalho: row[4] || '', // Local na coluna 4
                                    horasPrevistas: row[5] || '', // Horas previstas na coluna 5
                                    horasNormaisTrabalhadas: row[6] || '', // Horas normais na coluna 6
                                    horasExtras: row[7] || '', // Horas extras na coluna 7
                                    horasTotaisTrabalhadas: row[8] || '', // Total na coluna 8
                                    totalAbsenteismo: row[15] || '', // Total de Absente√≠smo na coluna 15 (ACUMULADO DO M√äS)
                                    diasUteisNoMes: diasUteisNoMes, // Quantidade de dias √∫teis at√© a data
                                    dataRelatorio: reportDate.toISOString().split('T')[0], // Data real do relat√≥rio
                                    observacoes: `Dados acumulados at√© ${reportDate.toLocaleDateString()} (${diasUteisNoMes} dias √∫teis)`
                                };
                                
                                    console.log(`‚úÖ Colaborador processado (MENSAL):`, registro);
                                    processedData.push(registro);
                                    
                                } catch (lineError) {
                                    console.error(`‚ùå Erro ao processar linha ${i} do arquivo ${file.name}:`, lineError);
                                    console.log(`üîç Dados da linha problem√°tica:`, jsonData[i]);
                                    
                                    // Continuar processamento das outras linhas
                                    continue;
                                }
                            }

                            console.log(`üéØ Processamento conclu√≠do. ${processedData.length} registros processados para ${file.name}`);
                            console.log(`üìã Dados finais:`, processedData);
                            resolve(processedData);
                        } catch (error) {
                            console.error(`Erro ao processar arquivo ${file.name}:`, error);
                            reject(new Error(`Erro ao processar arquivo: ${error.message}`));
                        }
                    };
                    reader.onerror = () => {
                        console.error(`Erro ao ler o arquivo ${file.name}`);
                        reject(new Error('Erro ao ler o arquivo'));
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            // --- Indicadores de Opera√ß√£o Functions ---
            async function calcularIndicadoresOperacao() {
                console.log("üîß INICIANDO calcularIndicadoresOperacao...");
                
                 // Ensure elements are available
                 if (!operacaoElements || !operacaoElements.chartsContainer || !operacaoElements.placeholder) {
                     console.error("‚ùå Operacao elements not ready for calculating indicators.");
                     console.error("operacaoElements:", operacaoElements);
                     return;
                 }
                 
                console.log("‚úÖ Elementos operacao prontos");
                
                // *** ADICIONADO: Ler o filtro de turno ***
                const selectedTurno = operacaoElements.turnoFilter.value;
                console.log("üéØ Turno selecionado:", selectedTurno);

                 // *** DEBUG: Verificar dados dispon√≠veis ***
                 console.log("=== DEBUG CALCULAR INDICADORES ===");
                 console.log("expedicaoData.length:", expedicaoData.length);
                 console.log("movimentacoesData.length:", movimentacoesData.length);
                 console.log("absenteismoData.length:", absenteismoData.length);
                 
                 // Debug dados movimenta√ß√µes se existirem
                 if (movimentacoesData.length > 0) {
                     console.log("Exemplo movimenta√ß√£o:", movimentacoesData[0]);
                     console.log("Campos tempo encontrados:", movimentacoesData.filter(m => m.tempo).length);
                 }
                 
                 console.log("=====================================");

                 if (expedicaoData.length === 0 && movimentacoesData.length === 0) {
                     console.warn("‚ö†Ô∏è Nenhum dado dispon√≠vel para calcular indicadores:");
                     console.warn("- Expedi√ß√£o:", expedicaoData.length, "registros");
                     console.warn("- Movimenta√ß√µes:", movimentacoesData.length, "registros");
                     operacaoElements.chartsContainer.classList.add('hidden');
                     
                     // Mostrar placeholder personalizado
                     operacaoElements.placeholder.classList.remove('hidden');
                     operacaoElements.placeholder.innerHTML = `
                         <div class="flex items-center justify-center h-96 text-gray-400">
                             <div class="text-center">
                                 <div class="text-6xl mb-4">üìä</div>
                                 <h3 class="text-2xl font-semibold mb-2">Dados necess√°rios para an√°lise</h3>
                                 <p class="text-lg mb-4">Carregue os dados para visualizar os indicadores de opera√ß√£o</p>
                                 <div class="space-y-2 text-sm">
                                     <div class="flex items-center justify-center space-x-2">
                                         <span class="w-3 h-3 bg-blue-500 rounded-full"></span>
                                         <span>Dados de Expedi√ß√£o (aba Importar Dados)</span>
                                     </div>
                                     <div class="flex items-center justify-center space-x-2">
                                         <span class="w-3 h-3 bg-orange-500 rounded-full"></span>
                                         <span>Dados de Movimenta√ß√µes de Empilhadeira (aba Importar Dados)</span>
                                     </div>
                                 </div>
                                 <button onclick="switchTab('importar'); showFeedback('Navegue para a aba Importar Dados para carregar os arquivos', 'info', 3000)" 
                                         class="mt-6 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                                     Ir para Importar Dados
                                 </button>
                             </div>
                         </div>
                     `;
                     return;
                 }
                 
                 // Continuar mesmo com apenas um tipo de dados (para permitir gr√°ficos parciais)
                 if (expedicaoData.length === 0) {
                     console.warn("‚ö†Ô∏è Sem dados de expedi√ß√£o - apenas gr√°ficos de movimenta√ß√µes ser√£o gerados");
                 }
                 if (movimentacoesData.length === 0) {
                     console.warn("‚ö†Ô∏è Sem dados de movimenta√ß√µes - apenas gr√°ficos de expedi√ß√£o ser√£o gerados");
                 }

                // Gerenciar placeholders: esconder o original e mostrar loading na sub-aba
                operacaoElements.placeholder.classList.add('hidden');
                operacaoElements.chartsContainer.classList.add('hidden'); // Manter original oculto
                
                const logisticaPlaceholderEl = document.getElementById('logistica-placeholder');
                const logisticaContainerEl = document.getElementById('logistica-charts-container');
                
                if (logisticaPlaceholderEl && logisticaContainerEl) {
                    logisticaPlaceholderEl.classList.add('hidden');
                    logisticaContainerEl.classList.remove('hidden');
                    logisticaContainerEl.innerHTML = '<div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-600 h-12 w-12 mx-auto"></div>';
                }

                 // --- Fetching data needs correct paths ---
                const absenteismoPath = getFirestorePath('absenteismo');
                // const downtimesPath = getFirestorePath('downtimes_lancados'); // N√ÉO MAIS USADO AQUI
                
                // *** MUDAN√áA: AGORA USA AS REGRAS DE DOWNTIME (junto com dados de absente√≠smo) ***
                // downtimeRules (REGRAS) j√° est√° em mem√≥ria (via listener)
                
                if (!absenteismoPath) {
                     showFeedback("Erro: N√£o foi poss√≠vel obter os caminhos do banco de dados.", "error");
                     operacaoElements.chartsContainer.innerHTML = '<p class="text-red-400 text-center">Erro ao acessar o banco de dados.</p>';
                    return;
                }

                // Fetch data using the correct paths
                // REMOVIDO: fetch de allDowntimes (lan√ßados)
                
                // *** FOR√áA RELOAD DOS DADOS PARA EVITAR CACHE ***
                console.log('üîÑ Recarregando dados de absente√≠smo...');
                const timestamp = Date.now();
                console.log(`‚è∞ Timestamp da consulta: ${timestamp}`);
                
                const allAbsenteismo = await getFirestoreCollection(absenteismoPath);
                
                // *** DEBUG: Verificar dados de absente√≠smo ap√≥s carregar ***
                console.log("allAbsenteismo.length:", allAbsenteismo.length);
                
                // *** FILTRAGEM POR DATA ATUAL ***
                // S√≥ processa dados dos √∫ltimos 2 meses para evitar dados antigos
                // *** PROCESSAMENTO DE TODOS OS DADOS (N√ÉO APENAS 2 MESES) ***
                console.log(`üóìÔ∏è Processando TODOS os dados de absente√≠smo dispon√≠veis (n√£o apenas √∫ltimos 2 meses)`);
                
                const absenteismoFiltrado = allAbsenteismo.filter(item => {
                    if (!item.data) {
                        console.log(`ÔøΩ Ignorando dado sem data: ${item.colaborador || 'sem nome'}`);
                        return false;
                    }
                    // Aceitar qualquer data v√°lida (n√£o filtrar por m√™s)
                    const [ano, mes, dia] = item.data.split('-');
                    const anoNum = parseInt(ano);
                    const mesNum = parseInt(mes);
                    
                    // Validar se √© uma data v√°lida
                    const dataValida = anoNum >= 2024 && anoNum <= 2026 && mesNum >= 1 && mesNum <= 12;
                    if (!dataValida) {
                        console.log(`üö´ Ignorando data inv√°lida: ${item.data} (${item.colaborador})`);
                    }
                    return dataValida;
                });
                
                console.log(`üìä Dados ap√≥s filtro: ${absenteismoFiltrado.length} de ${allAbsenteismo.length} registros`);
                
                // *** DEBUG: Mostrar todas as datas encontradas ***
                const datasUnicas = [...new Set(absenteismoFiltrado.map(item => item.data))].sort();
                console.log(`üìÖ Datas √∫nicas nos dados filtrados: ${datasUnicas.join(', ')}`);
                
                const mesesUnicos = [...new Set(absenteismoFiltrado.map(item => {
                    if (!item.data) return null;
                    const [ano, mes] = item.data.split('-');
                    return `${ano}-${mes}`;
                }).filter(Boolean))].sort();
                console.log(`üìÜ Meses √∫nicos nos dados filtrados: ${mesesUnicos.join(', ')}`);
                
                // Usar os dados filtrados
                const allAbsenteismoAtual = absenteismoFiltrado;
                
                // --- AGGREGATION ---
                const monthlyAgg = {};
                
                // *** NOVO: Mapa para lookup de setor por operador/data ***
                const operatorSectorMap = new Map(); // Chave: "YYYY-MM-DD_OperadorNome" -> "PICKING" | "EXPEDI√á√ÉO" | "OPERADOR DE EMPILHADEIRA 1¬∞ TURNO" | "OUTRO"

                const processExpedicaoForIndicators = (data) => {
                     console.log("üîç DEBUG AGREGA√á√ÉO: Processando dados de expedi√ß√£o baseado na Coluna M...");
                     let registrosProcessados = 0;
                     let registrosIgnorados = 0;
                     
                     data.forEach(item => {
                        // ATUALIZADO: Usar mesRef (Coluna M) e anoRef (Coluna N) para agrega√ß√£o mensal
                        const mesRef = item.mesRef; // Vindo da Coluna M
                        const anoRef = item.anoRef || 2025; // Vindo da Coluna N ou padr√£o 2025
                        
                        if (mesRef && typeof mesRef === 'number' && mesRef >= 1 && mesRef <= 12) {
                            // Chave para total mensal (Gr√°fico expMensal) baseada nas Colunas M e N
                            const monthKey = `${anoRef}-${String(mesRef).padStart(2, '0')}`;
                            
                            if (!monthlyAgg[monthKey]) initMonthAgg(monthKey);
                            
                            // Somar Quantidade (Q) para o total mensal
                            monthlyAgg[monthKey].expedicaoTotal += item.quantidade; 
                            registrosProcessados++;
                            
                            // Para m√©dia di√°ria, usar a data de envio se dispon√≠vel, sen√£o usar o primeiro dia do m√™s
                            if (item.dataEnvio instanceof Date && !isNaN(item.dataEnvio)) {
                                monthlyAgg[monthKey].expedicaoDias.add(item.dataEnvio.getUTCDate());
                            } else {
                                // Se n√£o h√° data de envio v√°lida, usar o dia 1 do m√™s
                                monthlyAgg[monthKey].expedicaoDias.add(1);
                            }
                        } else {
                            registrosIgnorados++;
                            if (registrosIgnorados <= 5) {
                                console.log(`‚ùå Registro ignorado - M√™s inv√°lido:`, { mesRef, anoRef, quantidade: item.quantidade });
                            }
                        }
                    });
                    
                    console.log(`‚úÖ Agrega√ß√£o completa: ${registrosProcessados} processados, ${registrosIgnorados} ignorados`);
                };


                const processMovimentacoesForIndicators = (data) => {
                     // *** FILTRAR: Aplicar filtro de operadores salvos ANTES da agrega√ß√£o ***
                     const dataFiltrada = data.filter(item => {
                        const operatorName = item.responsavel || 'Desconhecido';
                        // Se nenhum operador selecionado, mostrar todos
                        if (selectedOperators.length === 0) return true;
                        // Mostrar apenas operadores selecionados
                        return selectedOperators.includes(operatorName);
                     });
                     
                     if (selectedOperators.length > 0) {
                        console.log(`üéØ Filtro de operadores aplicado em processMovimentacoesForIndicators`);
                        console.log(`üìä Movimenta√ß√µes antes do filtro: ${data.length}`);
                        console.log(`üìä Movimenta√ß√µes ap√≥s filtro: ${dataFiltrada.length}`);
                     }
                     
                     dataFiltrada.forEach(item => {
                        const year = item.ano;
                        const month = item.mes;
                        const turno = item.turno; // Already processed

                        // *** VALIDATION for monthly count ***
                        if (typeof year !== 'number' || isNaN(year) || typeof month !== 'number' || isNaN(month) || month < 1 || month > 12 || !turno) {
                            // console.warn("Skipping indicator aggregation due to invalid year/month/turno:", item); // Optional: See skipped items
                            return; // Skip if essential fields for monthly count are invalid
                        }
                        // *** END VALIDATION ***

                        const monthKey = `${year}-${String(month).padStart(2, '0')}`;

                        if (!monthlyAgg[monthKey]) initMonthAgg(monthKey);

                        // *** L√ìGICA DO FILTRO ATUALIZADA ***
                        // AGORA AGREGA T1 E T2 SEPARADAMENTE
                        const isTurno1 = (turno === '1¬∞ TURNO');
                        const isTurno2 = (turno === '2¬∞ TURNO');

                        // Agrega para Todos (T1 + T2)
                        if (isTurno1 || isTurno2) {
                            monthlyAgg[monthKey].movimentacoesTotal_Todos++;
                            if (item.data instanceof Date && !isNaN(item.data)) {
                                monthlyAgg[monthKey].movimentacaoDias_Todos.add(item.data.getUTCDate());
                            }
                        }
                        
                        // Agrega por turno espec√≠fico
                        if (isTurno1) {
                            monthlyAgg[monthKey].movimentacoesTotal_T1++;
                            if (item.data instanceof Date && !isNaN(item.data)) {
                                monthlyAgg[monthKey].movimentacaoDias_T1.add(item.data.getUTCDate());
                            }
                        } else if (isTurno2) {
                            monthlyAgg[monthKey].movimentacoesTotal_T2++;
                            if (item.data instanceof Date && !isNaN(item.data)) {
                                monthlyAgg[monthKey].movimentacaoDias_T2.add(item.data.getUTCDate());
                            }
                        }
                    });
                };

                 const initMonthAgg = (key) => {
                     monthlyAgg[key] = {
                        expedicaoTotal: 0,
                        expedicaoDias: new Set(),
                        // ADICIONADOS
                        movimentacoesTotal_T1: 0,
                        movimentacaoDias_T1: new Set(),
                        movimentacoesTotal_T2: 0,
                        movimentacaoDias_T2: new Set(),
                        movimentacoesTotal_Todos: 0,
                        movimentacaoDias_Todos: new Set(),
                        
                        // *** MUDAN√áA AQUI ***
                        horasPrevistasPickingMin: 0, 
                        horasPrevistasExpedicaoMin: 0,
                        horasPrevistasOpEmpMin: 0,
                        
                        // *** NOVOS: Horas Normais e Downtime ***
                        horasNormaisPickingMin: 0,
                        horasNormaisExpedicaoMin: 0,
                        horasNormaisOpEmpMin: 0,
                        
                        // *** NOVOS: Horas de Absente√≠smo por setor ***
                        horasAbsenteismoPickingMin: 0,
                        horasAbsenteismoExpedicaoMin: 0,
                        horasAbsenteismoOpEmpMin: 0,
                        
                        // *** NOVOS: Contagem de dias √∫teis por setor (baseado em absente√≠smo) ***
                        diasUteisPicking: new Set(),
                        diasUteisExpedicao: new Set(),
                        diasUteisOpEmp: new Set(),
                        
                        // *** NOVO: Controle para dados mensais (evita duplica√ß√£o) ***
                        dadosProcessados: new Set(),
                    };
                };

                processExpedicaoForIndicators(expedicaoData);
                processMovimentacoesForIndicators(movimentacoesData);

                 // *** NOVA L√ìGICA: DADOS MENSAIS ACUMULADOS ***
                 console.log('üìä Processando dados de absente√≠smo mensal...');
                 
                 // Identificar todos os meses que ser√£o sobrescritos
                 const mesesParaLimpar = new Set();
                 allAbsenteismoAtual.forEach(item => {
                     if (item.data && item.mesAno) {
                         mesesParaLimpar.add(item.mesAno);
                     }
                 });
                 
                 // Limpar dados anteriores dos meses que ser√£o atualizados
                 mesesParaLimpar.forEach(mesAno => {
                     limparDadosAbsenteismoMensal(mesAno, monthlyAgg);
                 });
                 console.log(`üóëÔ∏è Dados limpos para os meses: ${Array.from(mesesParaLimpar).join(', ')}`);

                 // Aggregate absenteism data (SOMA DE HORAS PREVISTAS)
                allAbsenteismoAtual.forEach(item => {
                    if (!item.data || !item.colaborador) return; // Ensure 'data' and 'colaborador' fields exist (YYYY-MM-DD)
                    const [year, month, day] = item.data.split('-');
                    const monthKey = `${year}-${month}`;
                    
                    // Tenta encontrar o m√™s na agrega√ß√£o. Se n√£o existir, cria um novo.
                    if (!monthlyAgg[monthKey]) {
                        // Verifica se a chave √© v√°lida (ex: 2025-10)
                        const [y, m] = monthKey.split('-');
                        if (!isNaN(parseInt(y)) && !isNaN(parseInt(m)) && m >= 1 && m <= 12) {
                             initMonthAgg(monthKey);
                        } else {
                            // console.warn("Skipping absenteism aggregation for invalid monthKey:", monthKey);
                            return; // Pula se a chave (data) for inv√°lida
                        }
                    }

                    const locais = String(item.locaisDeTrabalho || '').toUpperCase();
                    const minutosPrevistos = timeStringToMinutes(item.horasPrevistas); // MUDAN√áA AQUI
                    const minutosNormais = timeStringToMinutes(item.horasNormaisTrabalhadas); // NOVO
                    const minutosAbsenteismo = timeStringToMinutes(item.totalAbsenteismo); // NOVO: Total de Absente√≠smo
                    
                    // *** DEBUG: Log dos valores sendo processados ***
                    if (monthKey === '2025-10') {
                        console.log(`DEBUG ${item.colaborador} - ${item.data}: Previstas="${item.horasPrevistas}" -> ${minutosPrevistos}min, Normais="${item.horasNormaisTrabalhadas}" -> ${minutosNormais}min, Absente√≠smo="${item.totalAbsenteismo}" -> ${minutosAbsenteismo}min, Local="${locais}"`);
                    }
                    
                    const mapKey = `${item.data}_${item.colaborador}`; // Chave para o lookup

                    // *** NOVA L√ìGICA: DADOS MENSAIS ACUMULADOS ***
                    // Em vez de somar diariamente, tratamos como dados √∫nicos do m√™s
                    // que devem sobrescrever dados anteriores do mesmo m√™s/colaborador
                    
                    const chaveUnica = `${monthKey}_${item.colaborador}_${locais}`;
                    
                    // Verifica se j√° existe dados para este colaborador/setor no m√™s
                    if (!monthlyAgg[monthKey].dadosProcessados) {
                        monthlyAgg[monthKey].dadosProcessados = new Set();
                    }
                    
                    // Se j√° processamos este colaborador neste setor neste m√™s, pula (evita duplica√ß√£o)
                    if (monthlyAgg[monthKey].dadosProcessados.has(chaveUnica)) {
                        console.log(`‚ö†Ô∏è Dados j√° processados para ${item.colaborador} em ${locais} no m√™s ${monthKey}, pulando...`);
                        return; // Pula para o pr√≥ximo item
                    }
                    
                    // Marca como processado
                    monthlyAgg[monthKey].dadosProcessados.add(chaveUnica);
                    
                    // NOVO: Usa diasUteisNoMes do pr√≥prio registro em vez de calcular dias individuais
                    const diasUteisDoMes = item.diasUteisNoMes || 1;
                    
                    let setorMapeado = false;
                    
                    // Primeiro, tenta mapeamento espec√≠fico
                    if (locais.includes('PICKING')) {
                        // SOBRESCREVEMOS em vez de somar (dados mensais √∫nicos)
                        monthlyAgg[monthKey].horasPrevistasPickingMin += minutosPrevistos;
                        monthlyAgg[monthKey].horasNormaisPickingMin += minutosNormais;
                        monthlyAgg[monthKey].horasAbsenteismoPickingMin += minutosAbsenteismo; // Dados mensais acumulados
                        
                        // Adiciona apenas os dias √∫teis reais do m√™s
                        for (let d = 1; d <= diasUteisDoMes; d++) {
                            monthlyAgg[monthKey].diasUteisPicking.add(d.toString().padStart(2, '0'));
                        }
                        
                        operatorSectorMap.set(mapKey, "PICKING");
                        setorMapeado = true;
                        console.log(`üìä PICKING: +${minutosAbsenteismo}min absente√≠smo (${diasUteisDoMes} dias √∫teis)`);
                    }
                    if (locais.includes('EXPEDI√á√ÉO')) { 
                        monthlyAgg[monthKey].horasPrevistasExpedicaoMin += minutosPrevistos;
                        monthlyAgg[monthKey].horasNormaisExpedicaoMin += minutosNormais;
                        monthlyAgg[monthKey].horasAbsenteismoExpedicaoMin += minutosAbsenteismo; // Dados mensais acumulados
                        
                        // Adiciona apenas os dias √∫teis reais do m√™s
                        for (let d = 1; d <= diasUteisDoMes; d++) {
                            monthlyAgg[monthKey].diasUteisExpedicao.add(d.toString().padStart(2, '0'));
                        }
                        
                        operatorSectorMap.set(mapKey, "EXPEDI√á√ÉO");
                        setorMapeado = true;
                        console.log(`üìä EXPEDI√á√ÉO: +${minutosAbsenteismo}min absente√≠smo (${diasUteisDoMes} dias √∫teis)`);
                    }
                    if (locais.includes('OPERADOR DE EMPILHADEIRA 1¬∞ TURNO')) { 
                        monthlyAgg[monthKey].horasPrevistasOpEmpMin += minutosPrevistos;
                        monthlyAgg[monthKey].horasNormaisOpEmpMin += minutosNormais;
                        monthlyAgg[monthKey].horasAbsenteismoOpEmpMin += minutosAbsenteismo; // Dados mensais acumulados
                        
                        // Adiciona apenas os dias √∫teis reais do m√™s
                        for (let d = 1; d <= diasUteisDoMes; d++) {
                            monthlyAgg[monthKey].diasUteisOpEmp.add(d.toString().padStart(2, '0'));
                        }
                        
                        operatorSectorMap.set(mapKey, "OPERADOR DE EMPILHADEIRA");
                        setorMapeado = true;
                        console.log(`üìä OP. EMPILHADEIRA: +${minutosAbsenteismo}min absente√≠smo (${diasUteisDoMes} dias √∫teis)`);
                    }
                });

                // *** DEBUG: Mostrar totais acumulados ap√≥s processamento - TODOS OS MESES ***
                console.log('=== TOTAIS ACUMULADOS POR SETOR (TODOS OS MESES) ===');
                const mesesEncontrados = Object.keys(monthlyAgg).sort();
                console.log(`üìÖ Meses processados: ${mesesEncontrados.join(', ')}`);
                
                mesesEncontrados.forEach(mes => {
                    const agg = monthlyAgg[mes];
                    console.log(`\nüìä M√äS: ${mes}`);
                    console.log('PICKING:');
                    console.log('- Horas Previstas:', agg.horasPrevistasPickingMin, 'min (', (agg.horasPrevistasPickingMin/60).toFixed(2), 'h )');
                    console.log('- Horas Normais:', agg.horasNormaisPickingMin, 'min (', (agg.horasNormaisPickingMin/60).toFixed(2), 'h )');
                    console.log('- Horas Absente√≠smo:', agg.horasAbsenteismoPickingMin, 'min (', (agg.horasAbsenteismoPickingMin/60).toFixed(2), 'h )');
                    console.log('EXPEDI√á√ÉO:');
                    console.log('- Horas Previstas:', agg.horasPrevistasExpedicaoMin, 'min (', (agg.horasPrevistasExpedicaoMin/60).toFixed(2), 'h )');
                    console.log('- Horas Normais:', agg.horasNormaisExpedicaoMin, 'min (', (agg.horasNormaisExpedicaoMin/60).toFixed(2), 'h )');
                    console.log('- Horas Absente√≠smo:', agg.horasAbsenteismoExpedicaoMin, 'min (', (agg.horasAbsenteismoExpedicaoMin/60).toFixed(2), 'h )');
                    console.log('OP_EMP:');
                    console.log('- Horas Previstas:', agg.horasPrevistasOpEmpMin, 'min (', (agg.horasPrevistasOpEmpMin/60).toFixed(2), 'h )');
                    console.log('- Horas Normais:', agg.horasNormaisOpEmpMin, 'min (', (agg.horasNormaisOpEmpMin/60).toFixed(2), 'h )');
                    console.log('- Horas Absente√≠smo:', agg.horasAbsenteismoOpEmpMin, 'min (', (agg.horasAbsenteismoOpEmpMin/60).toFixed(2), 'h )');
                });
                console.log('===============================================');


                // --- IN√çCIO: Nova L√≥gica de C√°lculo de Downtime (Req 1 e 2) ---
                
                // --- Agrega√ß√£o para Gr√°fico de Downtime (Req 2) ---
                const downtimePorMotivoMin = {};
                
                // --- Agrega√ß√£o para Desconto (Req 1) ---
                // (Total de minutos de downtime por setor, baseado nas REGRAS)
                const downtimeTotalMinPorSetor = {
                    PICKING: 0,
                    EXPEDI√á√ÉO: 0,
                    OP_EMP: 0,
                    GERAL: 0 // Para regras que se aplicam a todos
                };
                
                // 1. Processar REGRAS de downtime
                console.log('=== DEBUG REGRAS DE DOWNTIME ===');
                console.log('downtimeRules:', downtimeRules);
                console.log('Quantidade de regras:', downtimeRules.length);
                
                if (downtimeRules.length === 0) {
                    console.warn('‚ö†Ô∏è ATEN√á√ÉO: Nenhuma regra de downtime configurada!');
                    console.warn('‚ö†Ô∏è Horas normais = Horas da Coluna G (sem desconto)');
                    console.warn('‚ö†Ô∏è Para aplicar desconto, configure regras de downtime.');
                }
                
                downtimeRules.forEach(rule => {
                    console.log('Processando regra:', rule);
                    const motivo = rule.motivo;
                    const tempoMin = timeStringToMinutes(rule.tempo);
                    const motivoUpper = motivo.toUpperCase();
                    
                    console.log(`- Motivo: ${motivo}, Tempo: ${rule.tempo}, Minutos: ${tempoMin}`);

                    // Req 2: Acumular total por motivo
                    if (!downtimePorMotivoMin[motivo]) {
                        downtimePorMotivoMin[motivo] = 0;
                    }
                    downtimePorMotivoMin[motivo] += tempoMin;

                    // Req 1: Acumular total por setor
                    // (Esta l√≥gica assume que o nome do motivo indica o setor)
                    if (motivoUpper.includes('PICKING')) {
                        downtimeTotalMinPorSetor.PICKING += tempoMin;
                        console.log(`  -> Adicionado ${tempoMin} min ao PICKING`);
                    } else if (motivoUpper.includes('EXPEDI√á√ÉO') || motivoUpper.includes('EXPEDICAO')) {
                        downtimeTotalMinPorSetor.EXPEDI√á√ÉO += tempoMin;
                        console.log(`  -> Adicionado ${tempoMin} min √† EXPEDI√á√ÉO`);
                    } else if (motivoUpper.includes('EMPILHADEIRA') || motivoUpper.includes('OP EMP')) {
                        downtimeTotalMinPorSetor.OP_EMP += tempoMin;
                        console.log(`  -> Adicionado ${tempoMin} min ao OP_EMP`);
                    } else {
                        // Se n√£o for espec√≠fico, √© GERAL (ex: Caf√©, Banheiro)
                        downtimeTotalMinPorSetor.GERAL += tempoMin;
                        console.log(`  -> Adicionado ${tempoMin} min ao GERAL`);
                    }
                });
                
                console.log('Totais por setor:');
                console.log('- PICKING:', downtimeTotalMinPorSetor.PICKING, 'min');
                console.log('- EXPEDI√á√ÉO:', downtimeTotalMinPorSetor.EXPEDI√á√ÉO, 'min');
                console.log('- OP_EMP:', downtimeTotalMinPorSetor.OP_EMP, 'min');
                console.log('- GERAL:', downtimeTotalMinPorSetor.GERAL, 'min');
                
                const totalDowntime = downtimeTotalMinPorSetor.PICKING + downtimeTotalMinPorSetor.EXPEDI√á√ÉO + downtimeTotalMinPorSetor.OP_EMP + downtimeTotalMinPorSetor.GERAL;
                if (totalDowntime === 0) {
                    console.warn('‚ö†Ô∏è TOTAL DE DOWNTIME = 0 MINUTOS');
                    console.warn('‚ö†Ô∏è NENHUM DESCONTO SER√Å APLICADO √ÄS HORAS NORMAIS');
                } else {
                    console.log(`‚úÖ Total de downtime configurado: ${totalDowntime} min (${(totalDowntime/60).toFixed(2)}h)`);
                }
                console.log('===================================');

                // 2. Calcular "Taxa Di√°ria" de Downtime (Req 1)
                
                // Calcular o total de dias √∫teis trabalhados EM TODOS OS MESES para cada setor
                let totalDiasUteisPicking = 0;
                let totalDiasUteisExpedicao = 0;
                let totalDiasUteisOpEmp = 0;

                Object.values(monthlyAgg).forEach(agg => {
                    totalDiasUteisPicking += agg.diasUteisPicking.size;
                    totalDiasUteisExpedicao += agg.diasUteisExpedicao.size;
                    totalDiasUteisOpEmp += agg.diasUteisOpEmp.size;
                });
                
                // (Evitar divis√£o por zero)
                // *** CORRE√á√ÉO: Calcular downtime por dia e multiplicar pelos dias de absente√≠smo ***
                const DIAS_UTEIS_BASE_MENSAL = 21; // Base para calcular downtime por dia

                // Downtime por dia (dividindo o total por 21 dias base)
                const downtimePorDiaPicking = (downtimeTotalMinPorSetor.PICKING + downtimeTotalMinPorSetor.GERAL) / DIAS_UTEIS_BASE_MENSAL;
                const downtimePorDiaExpedicao = (downtimeTotalMinPorSetor.EXPEDI√á√ÉO + downtimeTotalMinPorSetor.GERAL) / DIAS_UTEIS_BASE_MENSAL;
                const downtimePorDiaOpEmp = (downtimeTotalMinPorSetor.OP_EMP + downtimeTotalMinPorSetor.GERAL) / DIAS_UTEIS_BASE_MENSAL;

                console.log('=== DEBUG DOWNTIME POR DIA ===');
                console.log('Downtimes totais:');
                console.log('- PICKING + GERAL:', downtimeTotalMinPorSetor.PICKING + downtimeTotalMinPorSetor.GERAL, 'min');
                console.log('- EXPEDI√á√ÉO + GERAL:', downtimeTotalMinPorSetor.EXPEDI√á√ÉO + downtimeTotalMinPorSetor.GERAL, 'min');
                console.log('- OP_EMP + GERAL:', downtimeTotalMinPorSetor.OP_EMP + downtimeTotalMinPorSetor.GERAL, 'min');
                console.log('Downtime por dia (√∑21):');
                console.log('- Picking:', downtimePorDiaPicking, 'min/dia');
                console.log('- Expedi√ß√£o:', downtimePorDiaExpedicao, 'min/dia');
                console.log('- Op. Emp:', downtimePorDiaOpEmp, 'min/dia');
                console.log('===============================');


                // 3. Aplicar desconto de downtime √†s Horas Normais (Req 1)
                Object.keys(monthlyAgg).forEach(monthKey => {
                    const agg = monthlyAgg[monthKey];
                    
                    // *** NOVA L√ìGICA: Baseada nos dias √∫teis totais do m√™s ***
                    console.log(`=== AN√ÅLISE DETALHADA DO M√äS ${monthKey} ===`);
                    
                    // Obter ano e m√™s para calcular dias √∫teis
                    const [ano, mes] = monthKey.split('-').map(Number);
                    
                    // Calcular dias √∫teis totais do m√™s (m√™s completo)
                    const ultimoDiaDoMes = new Date(ano, mes, 0).getDate(); // √öltimo dia do m√™s
                    const diasUteisTotaisDoMes = calcularDiasUteis(ano, mes, ultimoDiaDoMes);
                    
                    console.log(`üìä Dias √∫teis totais do m√™s ${mes}/${ano}: ${diasUteisTotaisDoMes}`);
                    
                    // Se n√£o h√° dias registrados, pular o desconto
                    if (diasUteisTotaisDoMes === 0) {
                        console.log('Nenhum dia √∫til calculado para este m√™s, pulando desconto.');
                        return;
                    }
                    
                    // *** VERIFICAR SE H√Å DOWNTIME PARA APLICAR ***
                    const totalDowntimeConfigurado = (downtimeTotalMinPorSetor.PICKING + downtimeTotalMinPorSetor.EXPEDI√á√ÉO + downtimeTotalMinPorSetor.OP_EMP + downtimeTotalMinPorSetor.GERAL);
                    if (totalDowntimeConfigurado === 0) {
                        console.log(`‚ö†Ô∏è SEM DOWNTIME CONFIGURADO para ${monthKey} - Horas normais = Coluna G (sem desconto)`);
                        return;
                    }
                    
                    // *** CALCULAR DESCONTO CORRETO ***
                    // NOVA F√ìRMULA: (Downtime Total √∑ 21 dias base) √ó Dias √öteis do M√™s
                    const DIAS_BASE = 21; // Base padr√£o para c√°lculo de downtime
                    
                    const descontoDowntimePicking = ((downtimeTotalMinPorSetor.PICKING + downtimeTotalMinPorSetor.GERAL) / DIAS_BASE) * diasUteisTotaisDoMes;
                    const descontoDowntimeExpedicao = ((downtimeTotalMinPorSetor.EXPEDI√á√ÉO + downtimeTotalMinPorSetor.GERAL) / DIAS_BASE) * diasUteisTotaisDoMes;
                    const descontoDowntimeOpEmp = ((downtimeTotalMinPorSetor.OP_EMP + downtimeTotalMinPorSetor.GERAL) / DIAS_BASE) * diasUteisTotaisDoMes;

                    // Aplicar o desconto (Math.max para n√£o negativar)
                    console.log(`=== DESCONTO DOWNTIME PARA ${monthKey} ===`);
                    console.log('Downtime totais configurados:');
                    console.log('- Picking + Geral:', (downtimeTotalMinPorSetor.PICKING + downtimeTotalMinPorSetor.GERAL), 'min (', ((downtimeTotalMinPorSetor.PICKING + downtimeTotalMinPorSetor.GERAL)/60).toFixed(2), 'h)');
                    console.log('- Expedi√ß√£o + Geral:', (downtimeTotalMinPorSetor.EXPEDI√á√ÉO + downtimeTotalMinPorSetor.GERAL), 'min (', ((downtimeTotalMinPorSetor.EXPEDI√á√ÉO + downtimeTotalMinPorSetor.GERAL)/60).toFixed(2), 'h)');
                    console.log('- Op. Emp + Geral:', (downtimeTotalMinPorSetor.OP_EMP + downtimeTotalMinPorSetor.GERAL), 'min (', ((downtimeTotalMinPorSetor.OP_EMP + downtimeTotalMinPorSetor.GERAL)/60).toFixed(2), 'h)');
                    console.log(`*** NOVA F√ìRMULA CORRETA ***`);
                    console.log(`Base de c√°lculo: ${DIAS_BASE} dias`);
                    console.log(`Dias √∫teis do m√™s ${mes}/${ano}: ${diasUteisTotaisDoMes} dias`);
                    console.log(`F√ìRMULA: (Downtime Total √∑ ${DIAS_BASE} dias) √ó ${diasUteisTotaisDoMes} dias √∫teis do m√™s`);
                    console.log('Antes do desconto (Horas Normais da Coluna G):');
                    console.log('- Picking:', (agg.horasNormaisPickingMin / 60).toFixed(2), 'horas');
                    console.log('- Expedi√ß√£o:', (agg.horasNormaisExpedicaoMin / 60).toFixed(2), 'horas');
                    console.log('- Op. Empilhadeira:', (agg.horasNormaisOpEmpMin / 60).toFixed(2), 'horas');
                    console.log('Descontos calculados (por m√™s):');
                    console.log('- Picking:', (descontoDowntimePicking / 60).toFixed(2), 'horas');
                    console.log('- Expedi√ß√£o:', (descontoDowntimeExpedicao / 60).toFixed(2), 'horas');
                    console.log('- Op. Empilhadeira:', (descontoDowntimeOpEmp / 60).toFixed(2), 'horas');
                    
                    agg.horasNormaisPickingMin = Math.max(0, agg.horasNormaisPickingMin - descontoDowntimePicking);
                    agg.horasNormaisExpedicaoMin = Math.max(0, agg.horasNormaisExpedicaoMin - descontoDowntimeExpedicao);
                    agg.horasNormaisOpEmpMin = Math.max(0, agg.horasNormaisOpEmpMin - descontoDowntimeOpEmp);
                    
                    console.log('Ap√≥s o desconto (Horas Normais Finais):');
                    console.log('- Picking:', (agg.horasNormaisPickingMin / 60).toFixed(2), 'horas');
                    console.log('- Expedi√ß√£o:', (agg.horasNormaisExpedicaoMin / 60).toFixed(2), 'horas');
                    console.log('- Op. Empilhadeira:', (agg.horasNormaisOpEmpMin / 60).toFixed(2), 'horas');
                    console.log('*** RESULTADO: Coluna G - (Downtime √∑ 21) √ó Dias √öteis do M√™s ***');
                    console.log('=====================================');
                });
                
                // *** DEBUG: Verificar se dados foram preservados ap√≥s desconto ***
                console.log('=== VERIFICA√á√ÉO FINAL DOS DADOS AP√ìS DOWNTIME ===');
                Object.keys(monthlyAgg).forEach(monthKey => {
                    const agg = monthlyAgg[monthKey];
                    if (agg.horasNormaisPickingMin > 0 || agg.horasNormaisExpedicaoMin > 0 || agg.horasNormaisOpEmpMin > 0) {
                        console.log(`M√™s ${monthKey}:`);
                        console.log(`- Picking: ${(agg.horasNormaisPickingMin / 60).toFixed(2)}h`);
                        console.log(`- Expedi√ß√£o: ${(agg.horasNormaisExpedicaoMin / 60).toFixed(2)}h`);
                        console.log(`- Op. Emp: ${(agg.horasNormaisOpEmpMin / 60).toFixed(2)}h`);
                    }
                });
                console.log('================================================');
                
                // --- FIM: Nova L√≥gica de C√°lculo de Downtime ---
                

                const sortedMonths = Object.keys(monthlyAgg).sort();
                
                // *** DEBUG: VERIFICAR MESES DISPON√çVEIS PARA GR√ÅFICOS ***
                console.log('üîç === DEBUG DADOS PARA GR√ÅFICOS ===');
                console.log('üìÖ Meses ordenados encontrados:', sortedMonths);
                console.log('üìä Total de meses:', sortedMonths.length);
                
                sortedMonths.forEach(mes => {
                    const dados = monthlyAgg[mes];
                    console.log(`üìà ${mes}: Exp=${dados.expedicaoTotal}, HorasPrevPicking=${(dados.horasPrevistasPickingMin/60).toFixed(1)}h, HorasNormPicking=${(dados.horasNormaisPickingMin/60).toFixed(1)}h`);
                });
                console.log('=====================================');

                // ... rest of chart data preparation and rendering remains the same ...
                const monthsLabels = sortedMonths.map(key => {
                     const [year, month] = key.split('-');
                      // Format label as 'M√™s/Ano' using UTC date
                     return new Date(Date.UTC(year, month - 1)).toLocaleString('pt-BR', { month: 'short', year: '2-digit', timeZone: 'UTC' });
                });
                
                console.log('üè∑Ô∏è Labels dos meses:', monthsLabels);

                // --- Prepare Chart Data ---
                 const expData = sortedMonths.map(k => (monthlyAgg[k].expedicaoTotal || 0));
                
                // *** NOVOS ARRAYS DE DADOS DE MOVIMENTA√á√ÉO ***
                const movData_T1 = sortedMonths.map(k => (monthlyAgg[k].movimentacoesTotal_T1 || 0));
                const movData_T2 = sortedMonths.map(k => (monthlyAgg[k].movimentacoesTotal_T2 || 0));
                const movData_Todos = sortedMonths.map(k => (monthlyAgg[k].movimentacoesTotal_Todos || 0));
                
                 // Average items shipped per day the shipping department worked
                const mediaExpDiaData = sortedMonths.map(k => monthlyAgg[k].expedicaoDias.size > 0 ? (monthlyAgg[k].expedicaoTotal || 0) / monthlyAgg[k].expedicaoDias.size : 0);
                
                // *** NOVOS ARRAYS DE M√âDIA DI√ÅRIA DE MOVIMENTA√á√ÉO ***
                const mediaMovDiaData_T1 = sortedMonths.map(k => monthlyAgg[k].movimentacaoDias_T1.size > 0 ? (monthlyAgg[k].movimentacoesTotal_T1 || 0) / monthlyAgg[k].movimentacaoDias_T1.size : 0);
                const mediaMovDiaData_T2 = sortedMonths.map(k => monthlyAgg[k].movimentacaoDias_T2.size > 0 ? (monthlyAgg[k].movimentacoesTotal_T2 || 0) / monthlyAgg[k].movimentacaoDias_T2.size : 0);
                const mediaMovDiaData_Todos = sortedMonths.map(k => monthlyAgg[k].movimentacaoDias_Todos.size > 0 ? (monthlyAgg[k].movimentacoesTotal_Todos || 0) / monthlyAgg[k].movimentacaoDias_Todos.size : 0);
                
                // *** TORNAR VARI√ÅVEIS GLOBAIS PARA USO NOS GR√ÅFICOS DA EXPEDI√á√ÉO (SER√Å COMPLETADO DEPOIS) ***
                window.monthsLabels = monthsLabels;
                window.expData = expData;


                const crescimentoExpData = sortedMonths.map((k, i) => {
                    if (i === 0) return 0; // No growth for the first month
                    const prevKey = sortedMonths[i-1];
                    const atual = monthlyAgg[k].expedicaoTotal;
                    const anterior = monthlyAgg[prevKey]?.expedicaoTotal; // Use optional chaining
                    // Handle cases where previous month might be zero or missing
                    if (anterior === undefined || anterior === null) return (atual > 0 ? Infinity : 0); // Or handle as needed
                    return anterior > 0 ? ((atual / anterior) - 1) * 100 : (atual > 0 ? Infinity : 0); // Avoid division by zero, show Infinity if growing from 0
                }).map(val => isFinite(val) ? val : 100); // Replace Infinity with 100% or another indicator if preferred
                
                // *** L√ìGICA DE COR PARA CRESCIMENTO ***
                const corPositiva = '#10B981'; // Verde (igual expedi√ß√£o)
                const corNegativa = '#EF4444'; // Vermelho (cor de perigo)
                // (crescimentoExpColors is no longer needed here, will be calculated in datalabels options)


                // *** MUDAN√áA AQUI: Total de horas PREVISTAS ***
                const horasPrevistasPickingData = sortedMonths.map(k => (monthlyAgg[k].horasPrevistasPickingMin || 0) / 60);
                const horasPrevistasExpedicaoData = sortedMonths.map(k => (monthlyAgg[k].horasPrevistasExpedicaoMin || 0) / 60);
                const horasPrevistasOpEmpData = sortedMonths.map(k => (monthlyAgg[k].horasPrevistasOpEmpMin || 0) / 60); // NOVO
                
                // *** NOVO: Total de horas NORMAIS (COM DESCONTO DE DOWNTIME) ***
                const horasNormaisPickingData = sortedMonths.map(k => (monthlyAgg[k].horasNormaisPickingMin || 0) / 60);
                const horasNormaisExpedicaoData = sortedMonths.map(k => (monthlyAgg[k].horasNormaisExpedicaoMin || 0) / 60);
                const horasNormaisOpEmpData = sortedMonths.map(k => (monthlyAgg[k].horasNormaisOpEmpMin || 0) / 60);
                
                // *** NOVO: Total de horas de ABSENTE√çSMO por setor ***
                const horasAbsenteismoPickingData = sortedMonths.map(k => (monthlyAgg[k].horasAbsenteismoPickingMin || 0) / 60);
                const horasAbsenteismoExpedicaoData = sortedMonths.map(k => (monthlyAgg[k].horasAbsenteismoExpedicaoMin || 0) / 60);
                const horasAbsenteismoOpEmpData = sortedMonths.map(k => (monthlyAgg[k].horasAbsenteismoOpEmpMin || 0) / 60);
                
                // *** NOVO: Calcular TEMPO M√âDIO DE MOVIMENTA√á√ÉO por turno ***
                console.log('üïê === DEBUG TEMPO M√âDIO DE MOVIMENTA√á√ÉO ===');
                console.log(`üìä Total movimenta√ß√µes brutas: ${movimentacoesData.length}`);
                
                if (movimentacoesData.length > 0) {
                    console.log('Exemplo movimenta√ß√£o bruta:', movimentacoesData[0]);
                    console.log('Campos dispon√≠veis:', Object.keys(movimentacoesData[0]));
                    
                    // Analisar campos de tempo
                    const comTempo = movimentacoesData.filter(m => m.tempo != null && m.tempo !== '' && m.tempo !== undefined);
                    console.log(`üìä Movimenta√ß√µes com campo 'tempo': ${comTempo.length}`);
                    if (comTempo.length > 0) {
                        console.log('Exemplo tempo:', comTempo[0].tempo, typeof comTempo[0].tempo);
                    }
                    
                    // Analisar campos de turno
                    const comTurno = movimentacoesData.filter(m => m.turno && m.turno !== '');
                    console.log(`üìä Movimenta√ß√µes com campo 'turno': ${comTurno.length}`);
                    if (comTurno.length > 0) {
                        console.log('Exemplo turno:', comTurno[0].turno);
                    }
                }
                
                // Filtrar dados v√°lidos (excluindo registros com "VERIFICAR")
                const movimentacoesValidas = movimentacoesData.filter(mov => {
                    // Excluir registros que t√™m "VERIFICAR" na coluna de valida√ß√£o
                    const validacao = mov.validacao ? mov.validacao.toString().toUpperCase() : '';
                    const temVerificar = validacao.includes('VERIFICAR');
                    
                    // Incluir apenas registros v√°lidos com tempo > 0
                    return !temVerificar && mov.tempo > 0 && mov.tempo < 1000; // Filtro de tempo razo√°vel
                });
                
                console.log(`üìä Total movimenta√ß√µes: ${movimentacoesData.length}`);
                console.log(`‚úÖ Movimenta√ß√µes v√°lidas (sem VERIFICAR): ${movimentacoesValidas.length}`);
                
                // Log do filtro de operadores
                if (selectedOperators.length > 0) {
                    console.log(`üéØ Filtro de operadores ATIVO: ${selectedOperators.length} operador(es) selecionado(s)`);
                    console.log(`üìã Operadores inclu√≠dos: ${selectedOperators.join(', ')}`);
                } else {
                    console.log(`üìã Filtro de operadores DESATIVADO: Todos os operadores ser√£o inclu√≠dos`);
                }
                
                const tempoMedioMovT1Data = [];
                const tempoMedioMovT2Data = [];
                
                sortedMonths.forEach(mesKey => {
                    const [ano, mes] = mesKey.split('-').map(Number);
                    
                    // Filtrar movimenta√ß√µes do m√™s atual
                    const movimentacoesMes = movimentacoesValidas.filter(mov => {
                        if (!mov.data || !mov.turno) return false;
                        const mesMovimento = `${mov.data.getFullYear()}-${String(mov.data.getMonth() + 1).padStart(2, '0')}`;
                        return mesMovimento === mesKey;
                    })
                    // *** FILTRAR: Aplicar filtro de operadores salvos (igual ao hist√≥rico mensal) ***
                    .filter(mov => {
                        const operatorName = mov.responsavel || 'Desconhecido';
                        // Se nenhum operador selecionado, mostrar todos
                        if (selectedOperators.length === 0) return true;
                        // Mostrar apenas operadores selecionados
                        return selectedOperators.includes(operatorName);
                    });
                    
                    // Separar por turno
                    const movT1 = movimentacoesMes.filter(mov => mov.turno === '1¬∞ TURNO');
                    const movT2 = movimentacoesMes.filter(mov => mov.turno === '2¬∞ TURNO');
                    
                    // Calcular tempo m√©dio por turno
                    const tempoMedioT1 = movT1.length > 0 ? 
                        movT1.reduce((sum, mov) => sum + mov.tempo, 0) / movT1.length : 0;
                    
                    const tempoMedioT2 = movT2.length > 0 ? 
                        movT2.reduce((sum, mov) => sum + mov.tempo, 0) / movT2.length : 0;
                    
                    tempoMedioMovT1Data.push(parseFloat(tempoMedioT1.toFixed(2)));
                    tempoMedioMovT2Data.push(parseFloat(tempoMedioT2.toFixed(2)));
                    
                    console.log(`üìä ${mesKey}: 1¬∞T = ${tempoMedioT1.toFixed(2)}min (${movT1.length} movs), 2¬∞T = ${tempoMedioT2.toFixed(2)}min (${movT2.length} movs)`);
                });
                
                console.log('üìä Dados finais tempo m√©dio:');
                console.log('- 1¬∞ Turno:', tempoMedioMovT1Data);
                console.log('- 2¬∞ Turno:', tempoMedioMovT2Data);
                console.log('==========================================');
                
                // *** COMPLETAR VARI√ÅVEIS GLOBAIS PARA EXPEDI√á√ÉO ***
                window.horasNormaisExpedicaoData = horasNormaisExpedicaoData;
                
                console.log('=== DEBUG DADOS DO GR√ÅFICO DE HORAS ===');
                console.log('Meses ordenados:', sortedMonths);
                console.log('Horas PREVISTAS por m√™s:');
                console.log('- Picking:', horasPrevistasPickingData);
                console.log('- Expedi√ß√£o:', horasPrevistasExpedicaoData);
                console.log('- Op. Empilhadeira:', horasPrevistasOpEmpData);
                console.log('Horas NORMAIS (com desconto) por m√™s:');
                console.log('- Picking:', horasNormaisPickingData);
                console.log('- Expedi√ß√£o:', horasNormaisExpedicaoData);
                console.log('- Op. Empilhadeira:', horasNormaisOpEmpData);
                console.log('Horas ABSENTE√çSMO por m√™s:');
                console.log('- Picking:', horasAbsenteismoPickingData);
                console.log('- Expedi√ß√£o:', horasAbsenteismoExpedicaoData);
                console.log('- Op. Empilhadeira:', horasAbsenteismoOpEmpData);
                
                // *** DEBUG: Verificar estrutura monthlyAgg no momento do gr√°fico ***
                console.log('*** ESTRUTURA monthlyAgg NO MOMENTO DO GR√ÅFICO ***');
                sortedMonths.forEach(monthKey => {
                    if (monthlyAgg[monthKey]) {
                        const agg = monthlyAgg[monthKey];
                        console.log(`${monthKey}: Picking=${(agg.horasNormaisPickingMin/60).toFixed(2)}h, Expedi√ß√£o=${(agg.horasNormaisExpedicaoMin/60).toFixed(2)}h, OpEmp=${(agg.horasNormaisOpEmpMin/60).toFixed(2)}h`);
                    }
                });
                console.log('===========================================');
                
                // --- Preparar dados dos √öLTIMOS 30 DIAS para Movimenta√ß√µes ---
                // Encontrar a data mais recente nos dados de movimenta√ß√£o
                let dataMaxima = null;
                movimentacoesData.forEach(mov => {
                    if (mov.data && mov.data instanceof Date) {
                        if (!dataMaxima || mov.data > dataMaxima) {
                            dataMaxima = mov.data;
                        }
                    }
                });
                
                console.log('Total de registros de movimenta√ß√£o:', movimentacoesData.length);
                console.log('Data m√°xima nos dados:', dataMaxima);
                
                // Se n√£o houver dados, usar data atual
                const hoje = dataMaxima || new Date();
                const trintaDiasAtras = new Date(hoje);
                trintaDiasAtras.setDate(hoje.getDate() - 29); // -29 para incluir 30 dias no total (hoje + 29 dias anteriores)
                
                console.log('Filtrando de', trintaDiasAtras, 'at√©', hoje);
                
                // Agregar por dia
                const dailyMovAgg = {};
                let registrosFiltrados = 0;
                
                movimentacoesData.forEach(mov => {
                    if (!mov.data || !(mov.data instanceof Date)) {
                        return;
                    }
                    
                    if (mov.data < trintaDiasAtras || mov.data > hoje) {
                        return; // Fora do per√≠odo
                    }
                    
                    // Filtrar registros com valida√ß√£o "VERIFICAR"
                    if (mov.validacao === 'VERIFICAR') {
                        return;
                    }
                    
                    // Filtrar registros sem ID
                    if (!mov.id) {
                        return;
                    }
                    
                    registrosFiltrados++;
                    
                    // Log dos primeiros 5 registros para debug
                    if (registrosFiltrados <= 5) {
                        console.log(`Registro ${registrosFiltrados}:`, {
                            id: mov.id,
                            data: mov.data,
                            turno: mov.turno,
                            validacao: mov.validacao
                        });
                    }
                    
                    const dateKey = mov.data.toISOString().split('T')[0]; // YYYY-MM-DD
                    if (!dailyMovAgg[dateKey]) {
                        dailyMovAgg[dateKey] = { 
                            T1: new Set(), 
                            T2: new Set(), 
                            Todos: new Set() 
                        };
                    }
                    
                    const turno = mov.turno;
                    
                    // Adicionar ID ao Set (garante contagem √∫nica)
                    if (turno === '1¬∞ TURNO') {
                        dailyMovAgg[dateKey].T1.add(mov.id);
                    } else if (turno === '2¬∞ TURNO') {
                        dailyMovAgg[dateKey].T2.add(mov.id);
                    }
                    dailyMovAgg[dateKey].Todos.add(mov.id);
                });
                
                console.log('Registros dentro do per√≠odo de 30 dias:', registrosFiltrados);
                console.log('Dias agregados:', Object.keys(dailyMovAgg).length);
                
                const sortedDays = Object.keys(dailyMovAgg).sort();
                const labels30dias = sortedDays.map(dateKey => {
                    const [year, month, day] = dateKey.split('-');
                    return `${day}/${month}`;
                });
                
                // Converter Sets para contagens
                const movData30_T1 = sortedDays.map(k => dailyMovAgg[k].T1.size);
                const movData30_T2 = sortedDays.map(k => dailyMovAgg[k].T2.size);
                const movData30_Todos = sortedDays.map(k => dailyMovAgg[k].Todos.size);
                
                // Debug: verificar dados dos √∫ltimos 30 dias
                console.log('Dias com dados:', sortedDays.length);
                console.log('Primeiros 5 dias:', sortedDays.slice(0, 5));
                console.log('√öltimos 5 dias:', sortedDays.slice(-5));
                console.log('Labels 30 dias (primeiros 5):', labels30dias.slice(0, 5));
                console.log('Dados 1¬∞T (primeiros 5):', movData30_T1.slice(0, 5));
                console.log('Dados Total (primeiros 5):', movData30_Todos.slice(0, 5));

                // --- Render Charts ---

                // *** ATUALIZAR T√çTULOS DIN√ÇMICOS ***
                let movTitle = 'Movimenta√ß√µes Mensais';
                let movSubtitle = null; // Subt√≠tulo para mostrar a meta
                let mediaMovTitle = 'M√©dia Di√°ria Movimenta√ß√£o';
                let mediaMovSubtitle = null; // Subt√≠tulo para meta di√°ria
                let mediaExpSubtitle = null; // Subt√≠tulo para meta expedi√ß√£o
                // *** T√çTULO ATUALIZADO (Req 1) ***
                let horasTitle = 'Horas Previstas vs. Normais Trabalhadas (Total Horas/M√™s)'; 

                const corTurno1 = '#3B82F6'; // Blue
                const corTurno2 = '#F59E0B'; // Orange
                const corTodos = '#6366F1'; // Indigo

                let movDatasets = [];
                let mediaMovDatasets = [];

                // *** NOVO: Calcular Meta de Movimenta√ß√µes Mensais ***
                // Buscar a meta cadastrada para "Movimenta√ß√£o Empilhadeira"
                const metaMovEmpConfig = metasPorAtividade['Movimenta√ß√£o Empilhadeira'] || null;
                let metaMovimentacoesData = [];
                
                console.log('=== DEBUG META MOVIMENTA√á√ïES ===');
                console.log('metaMovEmpConfig:', metaMovEmpConfig);
                console.log('downtimePorMotivoMin:', downtimePorMotivoMin);
                
                if (metaMovEmpConfig && metaMovEmpConfig.meta > 0) {
                    // Meta √© quantidade por hora
                    const qtdPorHora = metaMovEmpConfig.meta;
                    
                    // Base de horas mensais (184:48 = 11088 minutos)
                    const baseHorasMensalMin = (184 * 60) + 48; // 11088 minutos
                    
                    // Total de downtime em minutos (soma de todos os motivos)
                    const totalDowntimeMin = Object.values(downtimePorMotivoMin).reduce((sum, min) => sum + min, 0);
                    
                    // Horas dispon√≠veis = Base mensal - Downtime
                    const horasDisponiveisMin = Math.max(0, baseHorasMensalMin - totalDowntimeMin);
                    const horasDisponiveisHoras = horasDisponiveisMin / 60;
                    
                    // Meta mensal = quantidade/hora √ó horas dispon√≠veis
                    const metaMensal = qtdPorHora * horasDisponiveisHoras;
                    
                    console.log('Quantidade por hora:', qtdPorHora);
                    console.log('Base mensal (min):', baseHorasMensalMin);
                    console.log('Total downtime (min):', totalDowntimeMin);
                    console.log('Horas dispon√≠veis:', horasDisponiveisHoras);
                    console.log('Meta mensal calculada:', metaMensal);
                    
                    // Criar array com a mesma meta para todos os meses
                    metaMovimentacoesData = sortedMonths.map(() => metaMensal);
                    
                    console.log('metaMovimentacoesData array:', metaMovimentacoesData);
                }
                console.log('================================');


                // Sempre adiciona o 1¬∞ Turno
                movDatasets.push({ label: '1¬∞ Turno', data: movData_T1, backgroundColor: corTurno1, borderColor: corTurno1, borderWidth: 1 });
                mediaMovDatasets.push({ label: '1¬∞ Turno', data: mediaMovDiaData_T1, borderColor: corTurno1, backgroundColor: 'transparent', fill: false, tension: 0.1, pointBackgroundColor: corTurno1, pointRadius: 3 });

                if (selectedTurno === '2¬∞ TURNO') {
                    movDatasets.push({ label: '2¬∞ Turno', data: movData_T2, backgroundColor: corTurno2, borderColor: corTurno2, borderWidth: 1 });
                    mediaMovDatasets.push({ label: '2¬∞ Turno', data: mediaMovDiaData_T2, borderColor: corTurno2, backgroundColor: 'transparent', fill: false, tension: 0.1, pointBackgroundColor: corTurno2, pointRadius: 3 });
                    movTitle += ' (1¬∞T vs 2¬∞T)';
                    mediaMovTitle += ' (1¬∞T vs 2¬∞T)';
                } else { // 'todos'
                    movDatasets.push({ label: 'Total (1¬∞+2¬∞T)', data: movData_Todos, backgroundColor: corTodos, borderColor: corTodos, borderWidth: 1 });
                    mediaMovDatasets.push({ label: 'Total (1¬∞+2¬∞T)', data: mediaMovDiaData_Todos, borderColor: corTodos, backgroundColor: 'transparent', fill: false, tension: 0.1, pointBackgroundColor: corTodos, pointRadius: 3 });
                    movTitle += ' (1¬∞T vs Total)';
                    mediaMovTitle += ' (1¬∞T vs Total)';
                }
                
                // *** CALCULAR META DI√ÅRIA ***
                const metaDiaria = metaMovEmpConfig && metaMovEmpConfig.meta > 0 
                    ? metaMovEmpConfig.meta * (7 + 43/60) 
                    : 0;
                
                // *** ADICIONAR LINHA DE META DI√ÅRIA NO GR√ÅFICO DE M√âDIA ***
                if (metaDiaria > 0) {
                    const valorMetaDiaria = Math.round(metaDiaria);
                    mediaMovSubtitle = `Meta Di√°ria: ${valorMetaDiaria.toLocaleString('pt-BR')} movimenta√ß√µes/dia`;
                    
                    const metaDiariaArray = sortedMonths.map(() => metaDiaria);
                    mediaMovDatasets.push({ 
                        label: 'Meta Di√°ria', 
                        data: metaDiariaArray,
                        borderColor: '#EF4444', // Vermelho
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        borderDash: [5, 5], // Linha tracejada
                        fill: false,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    });
                }
                
                // *** ADICIONAR LINHA DE META (se configurada) ***
                if (metaMovimentacoesData.length > 0) {
                    const valorMeta = Math.round(metaMovimentacoesData[0]); // Pega o valor da meta sem decimais
                    movSubtitle = `Meta: ${valorMeta.toLocaleString('pt-BR')} movimenta√ß√µes/m√™s`; // Define o subt√≠tulo
                    
                    movDatasets.push({ 
                        label: 'Meta', 
                        data: metaMovimentacoesData, 
                        type: 'line', // Tipo linha
                        borderColor: '#EF4444', // Vermelho
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        borderDash: [5, 5], // Linha tracejada
                        fill: false,
                        pointRadius: 0, // Sem pontos
                        pointHoverRadius: 0,
                        order: 0 // Renderizar por cima das barras
                    });
                }


                 // Renderizar gr√°ficos na sub-aba "Opera√ß√£o log√≠stica"
                 const logisticaContainer2 = document.getElementById('logistica-charts-container');
                 const logisticaPlaceholder2 = document.getElementById('logistica-placeholder');
                 
                 console.log('üéØ TENTANDO RENDERIZAR GR√ÅFICOS...');
                 console.log('logisticaContainer2:', logisticaContainer2 ? 'ENCONTRADO' : 'N√ÉO ENCONTRADO');
                 console.log('logisticaPlaceholder2:', logisticaPlaceholder2 ? 'ENCONTRADO' : 'N√ÉO ENCONTRADO');
                 
                 if (logisticaContainer2 && logisticaPlaceholder2) {
                     console.log('‚úÖ RENDERIZANDO GR√ÅFICOS DA LOG√çSTICA...');
                     
                     // *** PREPARAR SUBT√çTULO DO GR√ÅFICO DE TEMPO M√âDIO ANTES DO HTML ***
                     let tempoMedioSubtitle = 'Tempo m√©dio por movimenta√ß√£o, excluindo registros de verifica√ß√£o';
                     
                     // Buscar meta de tempo de movimenta√ß√£o para o subt√≠tulo
                     if (metasPorAtividade && metasPorAtividade['META TEMPO DE MOVIMENTA√á√ÉO']) {
                         const metaTempoConfig = metasPorAtividade['META TEMPO DE MOVIMENTA√á√ÉO'];
                         if (metaTempoConfig && metaTempoConfig.meta > 0) {
                             // Fun√ß√£o tempor√°ria para convers√£o (ser√° redefinida depois)
                             function tempDecimalToTimeFormat(decimal) {
                                 const totalSeconds = decimal * 60;
                                 const hours = Math.floor(totalSeconds / 3600);
                                 const minutes = Math.floor((totalSeconds % 3600) / 60);
                                 const seconds = Math.round(totalSeconds % 60);
                                 
                                 if (hours > 0) {
                                     return `${hours}h ${minutes}min ${seconds}s`;
                                 } else if (minutes > 0) {
                                     return `${minutes}min ${seconds}s`;
                                 } else {
                                     return `${seconds}s`;
                                 }
                             }
                             
                             const metaFormatada = tempDecimalToTimeFormat(metaTempoConfig.meta);
                             tempoMedioSubtitle = `Meta: ${metaFormatada} por movimenta√ß√£o | Excluindo registros de verifica√ß√£o`;
                         }
                     }
                     
                     // Ocultar placeholder e mostrar container de gr√°ficos da sub-aba
                     logisticaPlaceholder2.classList.add('hidden');
                     logisticaContainer2.classList.remove('hidden');
                     
                     // Explica√ß√µes dos gr√°ficos movidas para escopo global
                     
                     // Renderizar todos os gr√°ficos na sub-aba Opera√ß√£o log√≠stica
                     logisticaContainer2.innerHTML = `
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                            ${createChartContainer('expMensal', 'Expedi√ß√£o Mensal (Itens) e % Crescimento', null, false, chartExplanations.expMensal)}
                            ${createChartContainer('movMensais', movTitle, movSubtitle, true, chartExplanations.movMensais)} <!-- T√≠tulo Din√¢mico com Subt√≠tulo e Bot√£o -->
                        </div>
                         <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                            ${createChartContainer('mediaExpDia', 'M√©dia Di√°ria Expedi√ß√£o (Itens/Dia √ötil)', mediaExpSubtitle, false, chartExplanations.mediaExpDia)} <!-- Agora com subt√≠tulo de meta -->
                            ${createChartContainer('mediaMovDia', mediaMovTitle, mediaMovSubtitle, false, chartExplanations.mediaMovDia)} <!-- T√≠tulo Din√¢mico com Subt√≠tulo -->
                        </div>
                        <div class="grid grid-cols-1 gap-8 mb-8">
                            <div class="bg-gray-800 p-4 rounded-lg border border-gray-700 shadow-md relative">
                                <div class="chart-info-tooltip">
                                    !
                                    <div class="tooltip-card">
                                        ${chartExplanations.tempoMedioMovimentacao}
                                    </div>
                                </div>
                                <div class="flex items-center justify-between mb-1">
                                    <h3 class="text-lg font-semibold text-gray-200">Tempo M√©dio de Movimenta√ß√£o (1¬∞T vs 2¬∞T)</h3>
                                </div>
                                <p class="text-sm text-gray-400 mb-2">${tempoMedioSubtitle}</p>
                                <div class="chart-container" style="height: 450px;"><canvas id="tempoMedioMovimentacao"></canvas></div>
                            </div> <!-- GR√ÅFICO TEMPO M√âDIO SOZINHO NA LINHA -->
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                             ${createChartContainer('horasPrevistas', horasTitle, null, false, chartExplanations.horasPrevistas)} <!-- GR√ÅFICO HORAS PREVISTAS TAMANHO PADR√ÉO -->
                             ${createChartContainer('downtimePorMotivo', 'M√©dia Pausas Mensais por Motivo (%)', 'Base de c√°lculo m√©dio mensal de 184:48 horas por colaborador.', false, chartExplanations.downtimePorMotivo)} <!-- GR√ÅFICO PAUSAS JUNTO -->
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                             ${createChartContainer('horasAbsenteismo', 'Horas de Absente√≠smo por Setor (Total Horas/M√™s)', 'Total de absente√≠smo registrado por setor', false, chartExplanations.horasAbsenteismo)} <!-- NOVO GR√ÅFICO DE ABSENTE√çSMO -->
                        </div>
                    `;
                    console.log('‚úÖ CONTAINERS DE GR√ÅFICOS CRIADOS COM SUCESSO!');
                 } else {
                    console.log('‚ùå ERRO: N√£o foi poss√≠vel encontrar os containers da log√≠stica');
                 }

                 // *** RENDERIZAR GR√ÅFICOS NA SUB-ABA PICKING ***
                 const pickingContainer = document.getElementById('picking-charts-container');
                 const pickingPlaceholder = document.getElementById('picking-placeholder');
                 
                 // DEBUG: Verificar dados de expedi√ß√£o para picking
                 console.log('üîç DEBUG PICKING DETECTION: Total expedi√ß√£o data:', expedicaoData.length);
                 const locaisUnicosExpedicao = [...new Set(expedicaoData.map(item => item.locaisDeTrabalho).filter(Boolean))];
                 console.log('üîç DEBUG PICKING DETECTION: Locais √∫nicos na expedi√ß√£o:', locaisUnicosExpedicao);
                 
                 // Verificar se h√° dados de expedi√ß√£o para picking
                 const hasPickingDataExpedicao = expedicaoData.some(item => 
                     item.locaisDeTrabalho && 
                     item.locaisDeTrabalho.toLowerCase().includes('picking')
                 );
                 
                 // NOVA VERIFICA√á√ÉO: Usar dados do sistema de absente√≠smo que j√° calcula horas por setor
                 const hasPickingDataAbsenteismo = horasNormaisPickingData.some(valor => valor > 0);
                 
                 console.log('üîç DEBUG PICKING DETECTION: Tem dados picking (expedi√ß√£o)?', hasPickingDataExpedicao);
                 console.log('üîç DEBUG PICKING DETECTION: Tem dados picking (absente√≠smo)?', hasPickingDataAbsenteismo);
                 console.log('üîç DEBUG PICKING DETECTION: Horas normais picking:', horasNormaisPickingData);
                 
                 const hasPickingData = hasPickingDataExpedicao || hasPickingDataAbsenteismo;
                 
                 if (pickingContainer && pickingPlaceholder) {
                     if (hasPickingData) {
                         // Se h√° dados de picking, esconder placeholder e mostrar gr√°ficos
                         pickingPlaceholder.classList.add('hidden');
                         pickingContainer.classList.remove('hidden');
                         
                         // Renderizar gr√°fico Picking por hr pessoa e gr√°fico de pessoas
                         pickingContainer.innerHTML = `
                            <div class="grid grid-cols-1 gap-8">
                                ${createChartContainer('quantidadePessoasPicking', 'Quantidade de Pessoas no M√™s - Picking (Hist√≥rico)', 'Horas normais totais √∑ maior hora prevista individual por m√™s', false, chartExplanations.quantidadePessoasPicking)}
                                ${createChartContainer('pickingPorHrPessoa', 'Picking por Hr/Pessoa (Hist√≥rico Mensal)', 'Quantidade expedida √∑ horas normais do picking (com desconto downtime)', false, chartExplanations.pickingPorHrPessoa)}
                            </div>
                         `;
                         
                         console.log('‚úÖ PICKING: Container criado, canvas deveria estar dispon√≠vel');
                     } else {
                         // Se n√£o h√° dados de picking, mostrar placeholder
                         pickingContainer.classList.add('hidden');
                         pickingPlaceholder.classList.remove('hidden');
                         console.log('‚ùå PICKING: Nenhum dado encontrado, mostrando placeholder');
                     }
                 } else {
                     console.log('‚ùå PICKING: Containers n√£o encontrados:', {pickingContainer: !!pickingContainer, pickingPlaceholder: !!pickingPlaceholder});
                 }

                 // Manter container original vazio para compatibilidade
                 operacaoElements.chartsContainer.innerHTML = '';
                 operacaoElements.chartsContainer.classList.add('hidden');

                 // *** RENDERIZAR GR√ÅFICOS NA SUB-ABA EXPEDI√á√ÉO ***
                 const expedicaoContainer = document.getElementById('expedicao-charts-container');
                 const expedicaoPlaceholder = document.getElementById('expedicao-placeholder');
                 
                 // DEBUG: Verificar dados de expedi√ß√£o
                 console.log('üîç DEBUG EXPEDI√á√ÉO DETECTION: Total expedi√ß√£o data:', expedicaoData.length);
                 const locaisUnicosExpedicaoExp = [...new Set(expedicaoData.map(item => item.locaisDeTrabalho).filter(Boolean))];
                 console.log('üîç DEBUG EXPEDI√á√ÉO DETECTION: Locais √∫nicos na expedi√ß√£o:', locaisUnicosExpedicaoExp);
                 
                 // Verificar se h√° dados de expedi√ß√£o para expedi√ß√£o
                 const hasExpedicaoDataExpedicao = expedicaoData.some(item => 
                     item.locaisDeTrabalho && 
                     item.locaisDeTrabalho.toUpperCase().includes('EXPEDI√á√ÉO')
                 );
                 
                 // NOVA VERIFICA√á√ÉO: Usar dados do sistema de absente√≠smo que j√° calcula horas por setor
                 const hasExpedicaoDataAbsenteismo = horasNormaisExpedicaoData.some(valor => valor > 0);
                 
                 console.log('üîç DEBUG EXPEDI√á√ÉO DETECTION: Tem dados expedi√ß√£o (expedi√ß√£o)?', hasExpedicaoDataExpedicao);
                 console.log('üîç DEBUG EXPEDI√á√ÉO DETECTION: Tem dados expedi√ß√£o (absente√≠smo)?', hasExpedicaoDataAbsenteismo);
                 console.log('üîç DEBUG EXPEDI√á√ÉO DETECTION: Horas normais expedi√ß√£o:', horasNormaisExpedicaoData);
                 
                 const hasExpedicaoData = hasExpedicaoDataExpedicao || hasExpedicaoDataAbsenteismo;
                 
                 if (expedicaoContainer && expedicaoPlaceholder) {
                     if (hasExpedicaoData) {
                         // Se h√° dados de expedi√ß√£o, esconder placeholder e mostrar gr√°ficos
                         expedicaoPlaceholder.classList.add('hidden');
                         expedicaoContainer.classList.remove('hidden');
                         
                         // Renderizar gr√°fico Expedi√ß√£o por hr pessoa e gr√°fico de pessoas
                         expedicaoContainer.innerHTML = `
                            <div class="grid grid-cols-1 gap-8">
                                ${createChartContainer('quantidadePessoasExpedicao', 'Quantidade de Pessoas no M√™s - Expedi√ß√£o (Hist√≥rico)', 'Horas normais totais √∑ maior hora prevista individual por m√™s', false, chartExplanations.quantidadePessoasExpedicao)}
                                ${createChartContainer('expedicaoPorHrPessoa', 'Expedi√ß√£o por Hr/Pessoa (Hist√≥rico Mensal)', 'Quantidade expedida √∑ horas normais da expedi√ß√£o (com desconto downtime)', false, chartExplanations.expedicaoPorHrPessoa)}
                            </div>
                         `;
                         
                         console.log('‚úÖ EXPEDI√á√ÉO: Container criado, canvas deveria estar dispon√≠vel');
                         
                         // Aguardar um pouco para garantir que o DOM foi atualizado
                         setTimeout(() => {
                             const expedicaoCanvas = document.getElementById('expedicaoPorHrPessoa');
                             if (expedicaoCanvas) {
                                 console.log('‚úÖ EXPEDI√á√ÉO: Canvas encontrado, calculando dados...');
                                 
                                 // *** C√ÅLCULO DOS DADOS DE EXPEDI√á√ÉO POR HR/PESSOA (MESMO PADR√ÉO DO PICKING) ***
                                 const expedicaoPorHrPessoaData = [];
                                 const expedicaoLabels = [];
                                 const percentuaisExpedicao = []; // NOVO: Array para armazenar percentuais
                                 
                                 // Buscar meta de expedi√ß√£o se configurada
                                 const metasExpedicao = metasPorAtividade['EXPEDI√á√ÉO'] || metasPorAtividade['expedi√ß√£o'] || metasPorAtividade['Expedi√ß√£o'];
                                 let metaExpedicao = null;
                                 if (metasExpedicao && metasExpedicao.meta > 0) {
                                     metaExpedicao = metasExpedicao.meta;
                                     console.log('üéØ Meta de expedi√ß√£o encontrada para percentual:', metaExpedicao);
                                 } else {
                                     console.log('‚ö†Ô∏è Meta de expedi√ß√£o n√£o encontrada - percentuais n√£o ser√£o calculados');
                                 }
                                 
                                 // Processar cada m√™s (usando mesma l√≥gica do picking)
                                 monthsLabels.forEach((mesLabel, index) => {
                                     console.log(`üßÆ EXPEDI√á√ÉO - Processando ${mesLabel}`);
                                     
                                     const horasNormaisMesHoras = horasNormaisExpedicaoData[index] || 0;
                                     const quantidadeExpedida = expData[index] || 0;
                                     
                                     console.log(`üßÆ EXPEDI√á√ÉO ${mesLabel}: Horas normais:`, horasNormaisMesHoras.toFixed(2), 'horas');
                                     console.log(`üßÆ EXPEDI√á√ÉO ${mesLabel}: Quantidade expedida:`, quantidadeExpedida);
                                     
                                     if (horasNormaisMesHoras > 0 && quantidadeExpedida > 0) {
                                         const expedicaoPorHrPessoa = quantidadeExpedida / horasNormaisMesHoras;
                                         expedicaoPorHrPessoaData.push(expedicaoPorHrPessoa);
                                         expedicaoLabels.push(mesLabel);
                                         
                                         // Calcular percentual de atingimento da meta
                                         let percentualAtingimento = null;
                                         if (metaExpedicao && metaExpedicao > 0) {
                                             percentualAtingimento = (expedicaoPorHrPessoa / metaExpedicao) * 100;
                                         }
                                         percentuaisExpedicao.push(percentualAtingimento);
                                         
                                         console.log(`‚úÖ EXPEDI√á√ÉO ${mesLabel}: ${expedicaoPorHrPessoa.toFixed(2)} itens/hora | Percentual: ${percentualAtingimento ? percentualAtingimento.toFixed(1) + '%' : 'N/A'}`);
                                     } else {
                                         console.log(`‚ùå EXPEDI√á√ÉO ${mesLabel}: Dados insuficientes (horas: ${horasNormaisMesHoras}, itens: ${quantidadeExpedida})`);
                                     }
                                 });
                                 
                                 // Preparar datasets para o gr√°fico (EXATAMENTE IGUAL AO PICKING)
                                 const datasets = [{
                                     label: 'Expedi√ß√£o por Hr/Pessoa',
                                     data: expedicaoPorHrPessoaData,
                                     borderColor: '#06B6D4', // Azul ciano (igual ao picking)
                                     backgroundColor: 'rgba(6, 182, 212, 0.1)', // Azul ciano (igual ao picking)
                                     borderWidth: 3,
                                     fill: true,
                                     tension: 0.4,
                                     datalabels: {
                                         display: function(context) {
                                             // S√≥ mostrar labels se h√° meta configurada (igual ao picking)
                                             return metaExpedicao && metaExpedicao > 0;
                                         },
                                         color: 'white',
                                         backgroundColor: 'rgba(239, 68, 68, 0.8)', // Vermelho fixo (igual ao picking)
                                         borderRadius: 4,
                                         padding: 4,
                                         font: {
                                             size: 12,
                                             weight: 'bold'
                                         },
                                         formatter: function(value, context) {
                                             if (!value || !metaExpedicao || metaExpedicao <= 0) {
                                                 return '';
                                             }
                                             const percentual = (value / metaExpedicao) * 100;
                                             return percentual.toFixed(1) + '%';
                                         }
                                     }
                                 }];
                                 
                                 // *** ADICIONAR LINHA DE META TRACEJADA (se configurada) - IGUAL AO PICKING ***
                                 if (metaExpedicao && metaExpedicao > 0) {
                                     const metaArray = expedicaoLabels.map(() => metaExpedicao);
                                     
                                     // *** CALCULAR PERCENTUAL ATINGIDO ***
                                     const mediaRealizada = expedicaoPorHrPessoaData.reduce((sum, val) => sum + val, 0) / expedicaoPorHrPessoaData.filter(val => val > 0).length;
                                     let percentualAtingido = metaExpedicao > 0 ? (mediaRealizada / metaExpedicao * 100) : 0;
                                     
                                     datasets.push({
                                         label: 'Meta Expedi√ß√£o',
                                         data: metaArray,
                                         type: 'line',
                                         borderColor: '#EF4444', // Vermelho (igual picking)
                                         backgroundColor: 'transparent',
                                         borderWidth: 2,
                                         borderDash: [5, 5], // Linha tracejada
                                         fill: false,
                                         pointRadius: 0,
                                         pointHoverRadius: 0,
                                         order: 0, // Renderizar por cima
                                         datalabels: {
                                             display: false // N√£o mostrar labels na linha de meta
                                         }
                                     });
                                     
                                     // Atualizar subt√≠tulo para incluir meta e percentual (IGUAL AO PICKING)
                                     const percentualTexto = percentualAtingido ? ` | Atingimento: ${percentualAtingido.toFixed(1)}%` : '';
                                     let expedicaoSubtitle = `Meta: ${metaExpedicao.toLocaleString('pt-BR')} itens/hora${percentualTexto} | Quantidade expedida √∑ horas normais da expedi√ß√£o (com desconto downtime)`;
                                     console.log(`üéØ META EXPEDI√á√ÉO: ${metaExpedicao} itens/hora | Atingimento: ${percentualAtingido?.toFixed(1)}%`);
                                     
                                     // Atualizar subt√≠tulo do gr√°fico
                                     const subtitleElement = expedicaoCanvas.closest('.bg-gray-800').querySelector('p.text-sm');
                                     if (subtitleElement) {
                                         subtitleElement.textContent = expedicaoSubtitle;
                                     }
                                 }
                                 
                                 console.log('üìä DADOS FINAIS EXPEDI√á√ÉO:');
                                 console.log('- Labels:', expedicaoLabels);
                                 console.log('- Dados:', expedicaoPorHrPessoaData);
                                 console.log('- Datasets:', datasets.length);
                                 
                                 // *** CONFIGURA√á√ÉO ESPEC√çFICA PARA EXPEDI√á√ÉO COM DATALABELS ***
                                 const expedicaoChartOptions = {
                                     scales: {
                                         y: {
                                             beginAtZero: true,
                                             title: {
                                                 display: true,
                                                 text: 'Itens por Hora'
                                             },
                                             grid: {
                                                 color: 'rgba(107, 114, 128, 0.3)'
                                             },
                                             ticks: {
                                                 color: '#D1D5DB'
                                             }
                                         },
                                         x: {
                                             grid: {
                                                 display: false
                                             },
                                             ticks: {
                                                 color: '#D1D5DB'
                                             }
                                         }
                                     },
                                     plugins: {
                                         tooltip: {
                                             backgroundColor: 'rgba(0,0,0,0.7)',
                                             titleColor: '#FFFFFF',
                                             bodyColor: '#D1D5DB',
                                             borderColor: 'rgba(255,255,255,0.1)',
                                             borderWidth: 1,
                                             callbacks: {
                                                 label: function(context) {
                                                     const value = context.parsed.y;
                                                     const datasetLabel = context.dataset.label;
                                                     
                                                     // Calcular percentual para este ponto espec√≠fico (IGUAL AO PICKING)
                                                     let percentualPonto = '';
                                                     if (metaExpedicao && metaExpedicao > 0 && value > 0) {
                                                         const percentual = (value / metaExpedicao) * 100;
                                                         const status = percentual >= 100 ? '‚úÖ' : percentual >= 80 ? '‚ö†Ô∏è' : '‚ùå';
                                                         percentualPonto = ` (${percentual.toFixed(1)}% ${status})`;
                                                     }
                                                     return `${datasetLabel}: ${value.toFixed(2)} itens/hora${percentualPonto}`;
                                                 }
                                             }
                                         },
                                         legend: {
                                             labels: {
                                                 color: '#D1D5DB'
                                             }
                                         },
                                     }
                                 };
                                 
                                 // Renderizar o gr√°fico apenas se h√° dados v√°lidos
                                 if (expedicaoLabels.length > 0 && expedicaoPorHrPessoaData.some(valor => valor > 0)) {
                                     renderChart('expedicaoPorHrPessoa', 'line', expedicaoLabels, datasets, expedicaoChartOptions);
                                     
                                     console.log('‚úÖ EXPEDI√á√ÉO: Gr√°fico renderizado com sucesso');
                                 } else {
                                     console.log('‚ùå EXPEDI√á√ÉO: N√£o h√° dados v√°lidos para renderizar');
                                 }
                                 
                                 // Calcular e exibir quantidade de pessoas no m√™s em gr√°fico (EXATAMENTE IGUAL AO PICKING)
                                 function calcularQuantidadePessoasExpedicao() {
                                     try {
                                         console.log('üßÆ Iniciando c√°lculo hist√≥rico de quantidade de pessoas na expedi√ß√£o...');
                                         
                                         const mesesDisponiveis = Object.keys(monthlyAgg).sort();
                                         if (mesesDisponiveis.length === 0) {
                                             console.log('‚ùå Nenhum m√™s dispon√≠vel para c√°lculo');
                                             return;
                                         }
                                         
                                         const dadosHistoricos = [];
                                         const labelsHistorico = [];
                                         const percentuaisAtingimento = [];
                                         
                                         // *** USAR OS MESMOS ARRAYS QUE O GR√ÅFICO EXPEDI√á√ÉO POR HR/PESSOA USA ***
                                         console.log('üìä Usando arrays j√° calculados para expedi√ß√£o:');
                                         console.log('- monthsLabels:', monthsLabels);
                                         console.log('- expData:', expData);
                                         console.log('- horasNormaisExpedicaoData:', horasNormaisExpedicaoData);
                                         
                                         // Calcular para cada m√™s usando os mesmos dados do gr√°fico Expedi√ß√£o por Hr/Pessoa
                                         monthsLabels.forEach((mesLabel, index) => {
                                             const mesAtual = mesesDisponiveis[index];
                                             console.log(`üßÆ EXPEDI√á√ÉO - Processando ${mesLabel} (${mesAtual})`);
                                             
                                             // Usar dados j√° calculados (mesmos do gr√°fico Expedi√ß√£o por Hr/Pessoa)
                                             const horasNormaisMesHoras = horasNormaisExpedicaoData[index] || 0;
                                             const quantidadeExpedida = expData[index] || 0;
                                             
                                             console.log(`üßÆ EXPEDI√á√ÉO ${mesLabel}: Horas normais:`, horasNormaisMesHoras.toFixed(2), 'horas');
                                             console.log(`üßÆ EXPEDI√á√ÉO ${mesLabel}: Quantidade expedida:`, quantidadeExpedida);
                                             
                                             // Encontrar a maior hora prevista individual de uma pessoa da expedi√ß√£o neste m√™s
                                             let maiorHoraPrevistaPessoa = 0;
                                             
                                             // Filtrar dados de absente√≠smo para expedi√ß√£o no m√™s atual
                                             const dadosExpedicaoMes = allAbsenteismoAtual.filter(item => {
                                                 if (!item.data || !item.locaisDeTrabalho) return false;
                                                 const [year, month] = item.data.split('-');
                                                 const monthKey = `${year}-${month}`;
                                                 return monthKey === mesAtual && 
                                                        item.locaisDeTrabalho.toUpperCase().includes('EXPEDI√á√ÉO');
                                             });
                                             
                                             console.log(`üßÆ EXPEDI√á√ÉO ${mesLabel}: Funcion√°rios expedi√ß√£o encontrados:`, dadosExpedicaoMes.length);
                                             
                                             // Encontrar a maior hora prevista entre todos os funcion√°rios da expedi√ß√£o (mesmo m√©todo do picking)
                                             dadosExpedicaoMes.forEach(item => {
                                                 const horasPrevistas = timeStringToMinutes(item.horasPrevistas || '0:00') / 60; // Converter para horas
                                                 if (horasPrevistas > maiorHoraPrevistaPessoa) {
                                                     maiorHoraPrevistaPessoa = horasPrevistas;
                                                     console.log(`üßÆ EXPEDI√á√ÉO ${mesLabel}: Nova maior hora prevista:`, horasPrevistas.toFixed(2), 'horas para', item.colaborador);
                                                 }
                                             });
                                             
                                             console.log(`üßÆ EXPEDI√á√ÉO ${mesLabel}: Maior hora prevista individual:`, maiorHoraPrevistaPessoa.toFixed(2), 'horas');
                                             
                                             // Calcular quantidade de pessoas
                                             let quantidadePessoas = 0;
                                             if (maiorHoraPrevistaPessoa > 0 && horasNormaisMesHoras > 0) {
                                                 quantidadePessoas = horasNormaisMesHoras / maiorHoraPrevistaPessoa;
                                             }
                                             
                                             // *** CALCULAR PERCENTUAL EXATAMENTE COMO NO GR√ÅFICO EXPEDI√á√ÉO POR HR/PESSOA ***
                                             let percentualAtingimento = 0;
                                             let expedicaoPorHora = 0;
                                             
                                             if (horasNormaisMesHoras > 0) {
                                                 // Usar a mesma f√≥rmula: Quantidade Expedida √∑ Horas Normais Expedi√ß√£o
                                                 expedicaoPorHora = quantidadeExpedida / horasNormaisMesHoras;
                                                 
                                                 // Meta removida conforme solicita√ß√£o
                                             }
                                             
                                             console.log(`üßÆ EXPEDI√á√ÉO ${mesLabel}: Expedi√ß√£o por hora:`, expedicaoPorHora.toFixed(2), 'itens/hora');
                                             console.log(`üßÆ EXPEDI√á√ÉO ${mesLabel}: Quantidade de pessoas calculada:`, quantidadePessoas.toFixed(1));
                                             
                                             // Adicionar aos dados hist√≥ricos
                                             dadosHistoricos.push(parseFloat(quantidadePessoas.toFixed(1)));
                                             percentuaisAtingimento.push(percentualAtingimento);
                                             labelsHistorico.push(mesLabel); // Usar o mesmo label formatado
                                         });
                                         
                                         console.log('üßÆ EXPEDI√á√ÉO - Dados hist√≥ricos calculados:', dadosHistoricos);
                                         console.log('üßÆ EXPEDI√á√ÉO - Percentuais de atingimento da meta:', percentuaisAtingimento);
                                         console.log('üßÆ EXPEDI√á√ÉO - Labels:', labelsHistorico);
                                         
                                         // Renderizar gr√°fico (EXATAMENTE IGUAL AO PICKING)
                                         if (dadosHistoricos.length > 0 && dadosHistoricos.some(valor => valor > 0)) {
                                             const datasets = [{
                                                 label: 'Quantidade de Pessoas',
                                                 data: dadosHistoricos,
                                                 borderColor: '#3B82F6',
                                                 backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                                 borderWidth: 3,
                                                 fill: true,
                                                 tension: 0.4,
                                                 pointBackgroundColor: '#3B82F6',
                                                 pointBorderColor: '#FFFFFF',
                                                 pointBorderWidth: 2,
                                                 pointRadius: 6,
                                                 pointHoverRadius: 8
                                             }];
                                             
                                             // Calcular m√©dia para linha de refer√™ncia
                                             const media = dadosHistoricos.reduce((sum, val) => sum + val, 0) / dadosHistoricos.filter(val => val > 0).length;
                                             
                                             if (!isNaN(media) && media > 0) {
                                                 datasets.push({
                                                     label: `M√©dia: ${media.toFixed(1)} pessoas`,
                                                     data: Array(dadosHistoricos.length).fill(media),
                                                     borderColor: '#10B981',
                                                     backgroundColor: 'transparent',
                                                     borderWidth: 2,
                                                     borderDash: [5, 5],
                                                     fill: false,
                                                     pointRadius: 0,
                                                     pointHoverRadius: 0
                                                 });
                                             }
                                             
                                             const chartOptions = {
                                                 responsive: true,
                                                 maintainAspectRatio: false,
                                                 scales: {
                                                     y: {
                                                         beginAtZero: true,
                                                         grid: { color: 'rgba(107, 114, 128, 0.3)' },
                                                         ticks: { 
                                                             color: '#D1D5DB',
                                                             callback: function(value) {
                                                                 return value.toFixed(1) + ' pessoas';
                                                             }
                                                         },
                                                         title: {
                                                             display: true,
                                                             text: 'Quantidade de Pessoas',
                                                             color: '#D1D5DB'
                                                         }
                                                     },
                                                     x: {
                                                         grid: { color: 'rgba(107, 114, 128, 0.3)' },
                                                         ticks: { color: '#D1D5DB' }
                                                     }
                                                 },
                                                 plugins: {
                                                     tooltip: {
                                                         callbacks: {
                                                             label: function(context) {
                                                                 const value = context.parsed.y;
                                                                 const datasetLabel = context.dataset.label;
                                                                 const index = context.dataIndex;
                                                                 
                                                                 if (datasetLabel.includes('M√©dia')) {
                                                                     return `${datasetLabel}`;
                                                                 } else {
                                                                     // Pegar percentual de atingimento da meta correspondente
                                                                     const percentual = percentuaisAtingimento[index] || 0;
                                                                     
                                                                     // Determinar status baseado no percentual de atingimento da meta
                                                                     let status = '';
                                                                     if (percentual <= 79) {
                                                                         status = '‚úÖ Opera√ß√£o Confort√°vel';
                                                                     } else if (percentual <= 89) {
                                                                         status = '‚ö†Ô∏è Aten√ß√£o Necess√°ria';
                                                                     } else {
                                                                         status = 'üö® Necess√°ria Contrata√ß√£o';
                                                                     }
                                                                     
                                                                     return [
                                                                         `${datasetLabel}: ${value.toFixed(1)} pessoas`,
                                                                         `Carga da Opera√ß√£o: ${percentual.toFixed(1)}%`,
                                                                         `Status: ${status}`
                                                                     ];
                                                                 }
                                                             }
                                                         }
                                                     },
                                                     legend: {
                                                         labels: { color: '#D1D5DB' }
                                                     }
                                                 }
                                             };
                                             
                                             // Renderizar gr√°fico
                                             renderChart('quantidadePessoasExpedicao', 'line', labelsHistorico, datasets, chartOptions);
                                             console.log('‚úÖ Gr√°fico de quantidade de pessoas da expedi√ß√£o renderizado com sucesso');
                                             
                                         } else {
                                             console.log('‚ùå N√£o h√° dados v√°lidos para renderizar gr√°fico de pessoas da expedi√ß√£o');
                                         }
                                         
                                     } catch (error) {
                                         console.error('‚ùå Erro ao calcular quantidade de pessoas da expedi√ß√£o:', error);
                                     }
                                 }
                                 
                                 calcularQuantidadePessoasExpedicao();
                                 
                             } else {
                                 console.log('‚ùå EXPEDI√á√ÉO: Canvas n√£o encontrado');
                             }
                         }, 200);
                         
                     } else {
                         // Se n√£o h√° dados de expedi√ß√£o, mostrar placeholder
                         expedicaoContainer.classList.add('hidden');
                         expedicaoPlaceholder.classList.remove('hidden');
                         console.log('‚ùå EXPEDI√á√ÉO: Nenhum dado encontrado, mostrando placeholder');
                     }
                 } else {
                     console.log('‚ùå EXPEDI√á√ÉO: Containers n√£o encontrados:', {expedicaoContainer: !!expedicaoContainer, expedicaoPlaceholder: !!expedicaoPlaceholder});
                 }


                // *** OP√á√ïES DE LABELS PARA O GR√ÅFICO DE EXPEDI√á√ÉO ***
                const datalabelsExpMensal = {
                    plugins: {
                        datalabels: {
                            display: true, // Habilita os labels para este gr√°fico
                            anchor: (context) => context.dataset.data[context.dataIndex] >= 0 ? 'end' : 'start', // Posi√ß√£o na barra (fim p/ +, in√≠cio p/ -)
                            align: (context) => context.dataset.data[context.dataIndex] >= 0 ? 'top' : 'bottom', // Posi√ß√£o relativa (acima p/ +, abaixo p/ -)
                            color: (context) => { // Cor din√¢mica
                                const index = context.dataIndex;
                                if (index === 0) return '#D1D5DB'; // Cor neutra (cinza claro) para o primeiro
                                const crescimentoValor = crescimentoExpData[index];
                                return crescimentoValor >= 0 ? corPositiva : corNegativa; // Verde ou Vermelho
                            },
                            font: {
                                weight: 'bold',
                                size: 12 // Aumentado de 10 para 12
                            },
                            formatter: (value, context) => {
                                const index = context.dataIndex;
                                const crescimentoValor = crescimentoExpData[index];
                                if (index === 0) {
                                    return ''; // N√£o mostra % no primeiro m√™s
                                }
                                if (crescimentoValor === 0) return '0%'; // Mostra 0%
                                // Evita exibir "Infinity%" se o m√™s anterior foi 0
                                if (!isFinite(crescimentoValor)) return 'N/A'; 
                                return (crescimentoValor > 0 ? '+' : '') + crescimentoValor.toFixed(1) + '%'; // Mostra +20.5% ou -10.0%
                            },
                            offset: 8, // Aumentado de -5 para 8 (dist√¢ncia da barra)
                            padding: 0
                        }
                    }
                };

                // *** OP√á√ïES CUSTOMIZADAS PARA O GR√ÅFICO DE MOVIMENTA√á√ïES ***
                const optionsMovMensais = {
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    const value = context.parsed.y;
                                    // Se for a linha de meta, mostrar sem decimais
                                    if (context.dataset.label === 'Meta') {
                                        label += Math.round(value).toLocaleString('pt-BR');
                                    } else {
                                        // Para os turnos, mostrar o valor normal
                                        label += value.toLocaleString('pt-BR');
                                    }
                                    return label;
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                // Mostrar apenas nas barras (n√£o na linha de meta)
                                const shouldDisplay = context.dataset.type !== 'line';
                                console.log('Datalabels display check:', {
                                    datasetLabel: context.dataset.label,
                                    datasetType: context.dataset.type,
                                    shouldDisplay: shouldDisplay,
                                    dataIndex: context.dataIndex,
                                    value: context.dataset.data[context.dataIndex]
                                });
                                return shouldDisplay;
                            },
                            anchor: 'end',
                            align: 'top',
                            color: '#FFFFFF',
                            font: {
                                weight: 'bold',
                                size: 10
                            },
                            formatter: function(value, context) {
                                // Se n√£o houver meta configurada, n√£o mostra percentual
                                if (metaMovimentacoesData.length === 0) {
                                    console.log('Sem meta configurada, n√£o exibindo percentual');
                                    return '';
                                }
                                
                                const metaValor = metaMovimentacoesData[0];
                                if (!metaValor || metaValor === 0) {
                                    console.log('Meta √© zero, n√£o exibindo percentual');
                                    return '';
                                }
                                
                                const percentual = (value / metaValor) * 100;
                                const resultado = percentual.toFixed(0) + '%';
                                
                                console.log('Datalabels formatter:', {
                                    value: value,
                                    metaValor: metaValor,
                                    percentual: percentual,
                                    resultado: resultado
                                });
                                
                                return resultado; // Ex: "85%"
                            },
                            offset: 4
                        }
                    },
                    scales: {
                        x: {
                            stacked: false,
                            barPercentage: 0.7, // Reduz a largura das barras para criar mais espa√ßo entre grupos
                            categoryPercentage: 0.8 // Reduz o espa√ßo ocupado por cada categoria
                        }
                    }
                };


                // *** FUN√á√ÉO PARA RENDERIZAR GR√ÅFICO DE MOVIMENTA√á√ïES ***
                const renderMovimentacoesChart = (modo) => {
                    let labelsToUse, datasetsToUse, optionsToUse;
                    
                    if (modo === 'ultimos30dias') {
                        labelsToUse = labels30dias;
                        datasetsToUse = [];
                        
                        console.log('Renderizando √∫ltimos 30 dias...');
                        console.log('Labels dispon√≠veis:', labelsToUse);
                        console.log('Dados T1:', movData30_T1);
                        console.log('Dados Todos:', movData30_Todos);
                        
                        // Montar datasets para √∫ltimos 30 dias
                        datasetsToUse.push({ label: '1¬∞ Turno', data: movData30_T1, backgroundColor: corTurno1, borderColor: corTurno1, borderWidth: 1 });
                        
                        if (selectedTurno === '2¬∞ TURNO') {
                            datasetsToUse.push({ label: '2¬∞ Turno', data: movData30_T2, backgroundColor: corTurno2, borderColor: corTurno2, borderWidth: 1 });
                        } else {
                            datasetsToUse.push({ label: 'Total (1¬∞+2¬∞T)', data: movData30_Todos, backgroundColor: corTodos, borderColor: corTodos, borderWidth: 1 });
                        }
                        
                        // Meta di√°ria = (quantidade/hora da meta) √ó 7:43h (7h + 43min = 7.7167 horas)
                        const metaDiaria = metaMovEmpConfig && metaMovEmpConfig.meta > 0 
                            ? metaMovEmpConfig.meta * (7 + 43/60) 
                            : 0;
                        
                        console.log('Meta Config:', metaMovEmpConfig);
                        console.log('Meta di√°ria calculada:', metaDiaria);
                        
                        // Atualizar subt√≠tulo para meta di√°ria
                        const subtitleElement = document.querySelector('#movMensais').closest('.bg-gray-800').querySelector('p.text-sm');
                        if (subtitleElement && metaDiaria > 0) {
                            subtitleElement.textContent = `Meta Di√°ria: ${Math.round(metaDiaria).toLocaleString('pt-BR')} movimenta√ß√µes/dia`;
                        }
                        
                        if (metaDiaria > 0) {
                            const metaDiariaArray = labelsToUse.map(() => metaDiaria);
                            datasetsToUse.push({ 
                                label: 'Meta Di√°ria', 
                                data: metaDiariaArray, 
                                type: 'line',
                                borderColor: '#EF4444',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                pointHoverRadius: 0,
                                order: 0
                            });
                        }
                        
                        // Op√ß√µes espec√≠ficas para √∫ltimos 30 dias
                        optionsToUse = {
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            let label = context.dataset.label || '';
                                            if (label) {
                                                label += ': ';
                                            }
                                            const value = context.parsed.y;
                                            if (context.dataset.label === 'Meta Di√°ria') {
                                                label += Math.round(value).toLocaleString('pt-BR');
                                            } else {
                                                label += value.toLocaleString('pt-BR');
                                            }
                                            return label;
                                        }
                                    }
                                },
                                datalabels: {
                                    display: function(context) {
                                        return context.dataset.type !== 'line';
                                    },
                                    anchor: 'end',
                                    align: 'top',
                                    color: '#FFFFFF',
                                    font: {
                                        weight: 'bold',
                                        size: 10
                                    },
                                    formatter: function(value, context) {
                                        if (metaDiaria === 0) return '';
                                        const percentual = (value / metaDiaria) * 100;
                                        return percentual.toFixed(0) + '%';
                                    },
                                    offset: 4
                                }
                            },
                            scales: {
                                x: {
                                    stacked: false,
                                    barPercentage: 0.7,
                                    categoryPercentage: 0.8
                                }
                            }
                        };
                    } else {
                        // Modo mensal
                        labelsToUse = monthsLabels;
                        datasetsToUse = movDatasets;
                        optionsToUse = optionsMovMensais;
                        
                        // Restaurar subt√≠tulo para meta mensal
                        const subtitleElement = document.querySelector('#movMensais').closest('.bg-gray-800').querySelector('p.text-sm');
                        if (subtitleElement && metaMovimentacoesData.length > 0) {
                            const valorMeta = Math.round(metaMovimentacoesData[0]);
                            subtitleElement.textContent = `Meta: ${valorMeta.toLocaleString('pt-BR')} movimenta√ß√µes/m√™s`;
                        }
                    }
                    
                    renderChart('movMensais', 'bar', labelsToUse, datasetsToUse, optionsToUse);
                };

                // *** OP√á√ïES PARA GR√ÅFICO DE M√âDIA DI√ÅRIA MOVIMENTA√á√ÉO ***
                const optionsMediaMovDia = {
                    plugins: {
                        datalabels: {
                            display: function(context) {
                                // N√£o mostrar na linha de meta
                                return context.dataset.label !== 'Meta Di√°ria';
                            },
                            anchor: 'end',
                            align: function(context) {
                                // 1¬∞ Turno: acima (top)
                                // 2¬∞ Turno ou Total: abaixo (bottom)
                                const label = context.dataset.label;
                                if (label === '1¬∞ Turno') {
                                    return 'top';
                                } else {
                                    return 'bottom'; // 2¬∞ Turno ou Total (1¬∞+2¬∞T)
                                }
                            },
                            color: '#FFFFFF',
                            font: {
                                weight: 'bold',
                                size: 10
                            },
                            formatter: function(value, context) {
                                // Se n√£o houver meta di√°ria configurada, n√£o mostra percentual
                                if (metaDiaria === 0) {
                                    console.log('Sem meta di√°ria configurada, n√£o exibindo percentual');
                                    return '';
                                }
                                
                                const percentual = (value / metaDiaria) * 100;
                                const resultado = percentual.toFixed(0) + '%';
                                
                                console.log('Datalabels m√©dia di√°ria:', {
                                    label: context.dataset.label,
                                    value: value,
                                    metaDiaria: metaDiaria,
                                    percentual: percentual,
                                    resultado: resultado
                                });
                                
                                return resultado; // Ex: "85%"
                            },
                            offset: 4
                        }
                    }
                };

                // *** BUSCAR META PARA EXPEDI√á√ÉO DI√ÅRIA ***
                const metaExpedicaoConfig = metasPorAtividade['Expedi√ß√£o'] || null;
                let mediaExpDatasets = [];
                
                // Dataset principal de expedi√ß√£o
                mediaExpDatasets.push({ 
                    label: 'Expedi√ß√£o (Itens/Dia)', 
                    data: mediaExpDiaData, 
                    borderColor: '#10B981', 
                    backgroundColor: 'transparent', 
                    fill: false, 
                    tension: 0.1, 
                    pointBackgroundColor: '#10B981', 
                    pointRadius: 3 
                });
                
                // Meta de expedi√ß√£o removida conforme solicita√ß√£o

                // Render the charts in the new order with ORIGINAL colors
                renderChart('expMensal', 'bar', monthsLabels, [{ label: 'Itens Expedidos', data: expData, backgroundColor: '#10B981', borderColor: '#059669', borderWidth: 1 }], datalabelsExpMensal); // Green + LABELS
                renderMovimentacoesChart(movViewMode); // Renderiza com o modo atual
                renderChart('mediaExpDia', 'line', monthsLabels, mediaExpDatasets); // Agora com meta inclu√≠da
                renderChart('mediaMovDia', 'line', monthsLabels, mediaMovDatasets, optionsMediaMovDia); // Passa os datasets din√¢micos COM op√ß√µes de datalabels
                
                // *** NOVO GR√ÅFICO: TEMPO M√âDIO DE MOVIMENTA√á√ÉO (1¬∞T vs 2¬∞T) ***
                // Buscar meta de tempo de movimenta√ß√£o PRIMEIRO
                let metaTempoConfig = null;
                if (metasPorAtividade && metasPorAtividade['META TEMPO DE MOVIMENTA√á√ÉO']) {
                    metaTempoConfig = metasPorAtividade['META TEMPO DE MOVIMENTA√á√ÉO'];
                    console.log('üéØ Meta Tempo de Movimenta√ß√£o encontrada:', metaTempoConfig);
                }
                
                const tempoMedioDatasets = [];
                
                // Dataset para 1¬∞ Turno - MESMA COR DO PADR√ÉO
                if (tempoMedioMovT1Data.length > 0) {
                    tempoMedioDatasets.push({
                        label: '1¬∞ Turno',
                        data: tempoMedioMovT1Data,
                        borderColor: '#3B82F6', // Blue (padr√£o 1¬∞ turno)
                        backgroundColor: 'transparent',
                        fill: false,
                        tension: 0.1,
                        pointBackgroundColor: '#3B82F6',
                        pointRadius: 4,
                        pointHoverRadius: 6
                    });
                }
                
                // Dataset para 2¬∞ Turno - MESMA COR DO PADR√ÉO
                if (tempoMedioMovT2Data.length > 0) {
                    tempoMedioDatasets.push({
                        label: '2¬∞ Turno',
                        data: tempoMedioMovT2Data,
                        borderColor: '#F59E0B', // Orange (padr√£o 2¬∞ turno)
                        backgroundColor: 'transparent',
                        fill: false,
                        tension: 0.1,
                        pointBackgroundColor: '#F59E0B',
                        pointRadius: 4,
                        pointHoverRadius: 6
                    });
                }
                
                // Adicionar linha de meta se configurada
                if (metaTempoConfig && metaTempoConfig.meta > 0) {
                    const metaTempoMovimentacao = metaTempoConfig.meta; // J√° est√° em formato decimal (minutos)
                    const metaTempoArray = monthsLabels.map(() => metaTempoMovimentacao);
                    
                    tempoMedioDatasets.push({
                        label: `Meta Tempo (${decimalToTimeFormat(metaTempoMovimentacao)})`,
                        data: metaTempoArray,
                        borderColor: '#EF4444', // Vermelho (padr√£o metas)
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        borderDash: [8, 4], // Linha tracejada
                        fill: false,
                        tension: 0,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        datalabels: {
                            display: false // N√£o mostrar labels na linha de meta
                        }
                    });
                    
                    console.log(`üéØ META TEMPO DE MOVIMENTA√á√ÉO: ${decimalToTimeFormat(metaTempoMovimentacao)} adicionada ao gr√°fico`);
                }
                
                // Fun√ß√£o para converter tempo decimal para HH:MM:SS
                function decimalToTimeFormat(decimal) {
                    const totalSeconds = decimal * 60; // Decimal est√° em minutos
                    const hours = Math.floor(totalSeconds / 3600);
                    const minutes = Math.floor((totalSeconds % 3600) / 60);
                    const seconds = Math.round(totalSeconds % 60);
                    
                    if (hours > 0) {
                        return `${hours}h ${minutes}min ${seconds}s`;
                    } else if (minutes > 0) {
                        return `${minutes}min ${seconds}s`;
                    } else {
                        return `${seconds}s`;
                    }
                }
                
                // Op√ß√µes espec√≠ficas para tempo m√©dio (formato com segundos)
                const optionsTempoMedio = {
                    responsive: true,
                    maintainAspectRatio: false, // Permite controlar altura
                    layout: {
                        padding: {
                            top: 50, // Espa√ßo extra no topo para datalabels
                            bottom: 30,
                            left: 50, // Aumentado para evitar corte lateral esquerdo
                            right: 50 // Aumentado para evitar corte lateral direito
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const minutos = context.parsed.y;
                                    return `${context.dataset.label}: ${decimalToTimeFormat(minutos)}`;
                                }
                            }
                        },
                        datalabels: {
                            display: true,
                            anchor: 'center', // Centraliza o label no ponto
                            align: function(context) {
                                // Posicionamento baseado no dataset (turno)
                                const datasetLabel = context.dataset.label || '';
                                
                                if (datasetLabel.includes('1¬∞ Turno')) {
                                    return 'top'; // 1¬∞ Turno sempre acima da linha
                                } else if (datasetLabel.includes('2¬∞ Turno')) {
                                    return 'bottom'; // 2¬∞ Turno sempre abaixo da linha
                                } else {
                                    return 'center'; // Meta ou outros datasets no centro
                                }
                            },
                            offset: function(context) {
                                // Dist√¢ncia baseada no posicionamento
                                const datasetLabel = context.dataset.label || '';
                                
                                if (datasetLabel.includes('1¬∞ Turno')) {
                                    return 15; // Mais distante para cima (1¬∞ turno)
                                } else if (datasetLabel.includes('2¬∞ Turno')) {
                                    return 15; // Mais distante para baixo (2¬∞ turno)
                                } else {
                                    return 8; // Dist√¢ncia padr√£o para meta
                                }
                            },
                            color: function(context) {
                                return context.dataset.borderColor;
                            },
                            font: {
                                size: 12,
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                if (value === null || value === undefined) return '';
                                
                                // N√£o mostrar labels na linha de meta
                                const datasetLabel = context.dataset.label || '';
                                if (datasetLabel.includes('Meta')) {
                                    return ''; // Ocultar labels da meta
                                }
                                
                                return decimalToTimeFormat(value);
                            },
                            clip: false // Permite que labels sejam exibidos fora da √°rea do gr√°fico
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: true,
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            suggestedMax: function(context) {
                                // Calcula o valor m√°ximo dos dados e adiciona margem de 20%
                                const maxValue = Math.max(...context.chart.data.datasets.flatMap(d => d.data.filter(v => v !== null)));
                                return maxValue * 1.3; // Margem de 30% para evitar corte dos labels
                            },
                            title: {
                                display: true,
                                text: 'Tempo M√©dio'
                            },
                            ticks: {
                                callback: function(value) {
                                    return decimalToTimeFormat(value);
                                },
                                font: {
                                    size: 12
                                }
                            },
                            grid: {
                                display: true,
                                color: 'rgba(255, 255, 255, 0.1)'
                            }
                        }
                    }
                };
                
                // Renderizar o gr√°fico de tempo m√©dio
                if (tempoMedioDatasets.length > 0) {
                    renderChart('tempoMedioMovimentacao', 'line', monthsLabels, tempoMedioDatasets, optionsTempoMedio);
                    console.log('üìä Gr√°fico Tempo M√©dio de Movimenta√ß√£o (1¬∞T vs 2¬∞T) renderizado com sucesso');
                } else {
                    console.log('‚ö†Ô∏è Nenhum dado dispon√≠vel para renderizar gr√°fico de tempo m√©dio');
                    
                    // Mostrar mensagem de "sem dados" no container do gr√°fico
                    const tempoMedioCanvas = document.getElementById('tempoMedioMovimentacao');
                    if (tempoMedioCanvas && tempoMedioCanvas.parentElement) {
                        tempoMedioCanvas.parentElement.innerHTML = `
                            <div class="flex items-center justify-center h-64 text-gray-400">
                                <div class="text-center">
                                    <div class="text-4xl mb-2">üìä</div>
                                    <div class="text-lg">Dados de movimenta√ß√£o necess√°rios</div>
                                    <div class="text-sm mt-2">Carregue os dados de movimenta√ß√µes para visualizar este gr√°fico</div>
                                    <button onclick="window.testarComDadosExemplo()" class="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors">
                                        Testar com dados de exemplo
                                    </button>
                                </div>
                            </div>
                        `;
                    }
                }
                
                // *** CONFIGURAR BOT√ÉO DE TOGGLE ***
                const toggleBtn = document.getElementById('movMensais-toggle-btn');
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', () => {
                        if (movViewMode === 'mensal') {
                            movViewMode = 'ultimos30dias';
                            toggleBtn.textContent = 'Visualiza√ß√£o Mensal';
                        } else {
                            movViewMode = 'mensal';
                            toggleBtn.textContent = '√öltimos 30 dias';
                        }
                        renderMovimentacoesChart(movViewMode);
                    });
                }
                
                // *** GR√ÅFICO REMOVIDO ***
                // renderChart('crescimentoExp', 'bar', labels, [{...}]);
                
                // GR√ÅFICO REMOVIDO: renderChart('mediaAbs', ...)
                 
                 // *** GR√ÅFICO ATUALIZADO (Req 1) ***
                 
                // Cores com opacidade
                const corPrevPicking = '#14B8A680'; // Teal 50%
                const corPrevExpedicao = '#F9731680'; // Orange 50%
                const corPrevOpEmp = '#E11D4880'; // Rose 50%
                // Cores S√≥lidas
                const corNormPicking = '#14B8A6'; // Teal
                const corNormExpedicao = '#F97316'; // Orange
                const corNormOpEmp = '#E11D48'; // Rose
                
                // Op√ß√µes de sobreposi√ß√£o (Req 1)
                const optionsHoras = {
                    responsive: true,
                    interaction: {
                        mode: 'nearest',
                        intersect: true,
                    },
                    scales: {
                        x: {
                            stacked: true, // Ativa stack para sobreposi√ß√£o
                        },
                        y: {
                            beginAtZero: true,
                            stacked: false, // Y n√£o empilhado para permitir sobreposi√ß√£o
                            title: {
                                display: true,
                                text: 'Horas'
                            },
                            ticks: {
                                callback: function(value) {
                                    // Converte decimal para HH:MM
                                    const horas = Math.floor(value);
                                    const minutos = Math.round((value - horas) * 60);
                                    return `${horas}:${minutos.toString().padStart(2, '0')}`;
                                }
                            }
                        }
                    },
                    plugins: {
                        // Configura√ß√£o personalizada da legenda
                        legend: {
                            position: 'bottom',
                            labels: {
                                // Fun√ß√£o personalizada para ordenar e agrupar os labels
                                generateLabels: function(chart) {
                                    const originalLabels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                    
                                    // Cria grupos por local de trabalho
                                    const grupos = {
                                        'Picking': [],
                                        'Expedi√ß√£o': [],
                                        'Op. Empilhadeira': []
                                    };
                                    
                                    // Agrupa os labels por local
                                    originalLabels.forEach(label => {
                                        if (label.text.includes('Picking')) {
                                            grupos['Picking'].push(label);
                                        } else if (label.text.includes('Expedi√ß√£o')) {
                                            grupos['Expedi√ß√£o'].push(label);
                                        } else if (label.text.includes('Empilhadeira')) {
                                            grupos['Op. Empilhadeira'].push(label);
                                        }
                                    });
                                    
                                    // Reorganiza: Normais primeiro, depois Previstas para cada grupo
                                    const legendaOrganizada = [];
                                    
                                    Object.keys(grupos).forEach(grupo => {
                                        const items = grupos[grupo];
                                        
                                        // Primeiro adiciona "Normais"
                                        const normais = items.find(item => item.text.includes('Normais'));
                                        if (normais) {
                                            normais.text = normais.text.replace('Normais - ', ''); // Remove prefixo
                                            legendaOrganizada.push(normais);
                                        }
                                        
                                        // Depois adiciona "Previstas"
                                        const previstas = items.find(item => item.text.includes('Previstas'));
                                        if (previstas) {
                                            previstas.text = previstas.text.replace('Previstas - ', '') + ' (Meta)'; // Remove prefixo e adiciona indica√ß√£o
                                            legendaOrganizada.push(previstas);
                                        }
                                    });
                                    
                                    return legendaOrganizada;
                                },
                                boxWidth: 12,
                                padding: 8,
                                color: '#D1D5DB'
                            }
                        },
                        
                        tooltip: {
                            mode: 'nearest',
                            intersect: true,
                            
                            callbacks: {
                                title: function(tooltipItems) {
                                    const item = tooltipItems[0];
                                    const stack = item?.dataset?.stack;
                                    let localName = '';
                                    
                                    if (stack === 'picking') localName = 'Picking';
                                    else if (stack === 'expedicao') localName = 'Expedi√ß√£o';
                                    else if (stack === 'empilhadeira') localName = 'Op. Empilhadeira';
                                    
                                    return `${item.label} - ${localName}`;
                                },
                                
                                beforeBody: function(tooltipItems) {
                                    const item = tooltipItems[0];
                                    const currentStack = item?.dataset?.stack;
                                    const dataIndex = item?.dataIndex;
                                    const chart = item?.chart;
                                    
                                    if (!currentStack || !chart) return [];
                                    
                                    // Busca os datasets do mesmo stack
                                    let previstaValue = 0;
                                    let normalValue = 0;
                                    
                                    chart.data.datasets.forEach(dataset => {
                                        if (dataset.stack === currentStack) {
                                            if (dataset.label.includes('Previstas')) {
                                                previstaValue = dataset.data[dataIndex];
                                            } else if (dataset.label.includes('Normais')) {
                                                normalValue = dataset.data[dataIndex];
                                            }
                                        }
                                    });
                                    
                                    // Calcula o percentual
                                    const percentual = previstaValue > 0 ? ((normalValue / previstaValue) * 100) : 0;
                                    
                                    // Fun√ß√£o para converter decimal para HH:MM
                                    function horasParaHHMM(horasDecimal) {
                                        const horas = Math.floor(horasDecimal);
                                        const minutos = Math.round((horasDecimal - horas) * 60);
                                        return `${horas}:${minutos.toString().padStart(2, '0')}`;
                                    }
                                    
                                    return [
                                        `Previstas: ${horasParaHHMM(previstaValue)} horas`,
                                        `Normais: ${horasParaHHMM(normalValue)} horas - ${percentual.toFixed(0)}%`
                                    ];
                                },
                                
                                label: function() {
                                    return ''; // Remove labels padr√£o
                                }
                            }
                        }
                    }
                };

                 
                 // *** DEBUG: Log final dos dados que v√£o para o gr√°fico ***
                 console.log('üéØ DADOS FINAIS SENDO ENVIADOS PARA O GR√ÅFICO:');
                 console.log('üìä horasNormaisPickingData (FINAL):', horasNormaisPickingData);
                 console.log('üìä horasNormaisExpedicaoData (FINAL):', horasNormaisExpedicaoData);
                 console.log('üìä horasNormaisOpEmpData (FINAL):', horasNormaisOpEmpData);
                 
                 renderChart('horasPrevistas', 'bar', monthsLabels, [
                    // PICKING - Previstas como base (fundo transparente)
                    { 
                        label: 'Previstas - Picking', 
                        data: horasPrevistasPickingData, 
                        backgroundColor: corPrevPicking + '40', // Muito transparente
                        borderColor: corPrevPicking,
                        borderWidth: 2,
                        stack: 'picking', // Stack pr√≥prio
                        order: 2
                    },
                    // PICKING - Normais sobrep√µe as previstas (frente s√≥lida)
                    { 
                        label: 'Normais - Picking', 
                        data: horasNormaisPickingData, 
                        backgroundColor: corNormPicking, // S√≥lido
                        borderColor: corNormPicking,
                        borderWidth: 1,
                        stack: 'picking', // MESMO stack = sobrep√µe
                        order: 1
                    },
                    
                    // EXPEDI√á√ÉO - Previstas como base (fundo transparente)
                    { 
                        label: 'Previstas - Expedi√ß√£o', 
                        data: horasPrevistasExpedicaoData, 
                        backgroundColor: corPrevExpedicao + '40', // Muito transparente
                        borderColor: corPrevExpedicao,
                        borderWidth: 2,
                        stack: 'expedicao', // Stack pr√≥prio
                        order: 2
                    },
                    // EXPEDI√á√ÉO - Normais sobrep√µe as previstas (frente s√≥lida)
                    { 
                        label: 'Normais - Expedi√ß√£o', 
                        data: horasNormaisExpedicaoData, 
                        backgroundColor: corNormExpedicao, // S√≥lido
                        borderColor: corNormExpedicao,
                        borderWidth: 1,
                        stack: 'expedicao', // MESMO stack = sobrep√µe
                        order: 1
                    },
                    
                    // OP. EMPILHADEIRA - Previstas como base (fundo transparente)
                    { 
                        label: 'Previstas - Op. Empilhadeira 1¬∞T', 
                        data: horasPrevistasOpEmpData, 
                        backgroundColor: corPrevOpEmp + '40', // Muito transparente
                        borderColor: corPrevOpEmp,
                        borderWidth: 2,
                        stack: 'empilhadeira', // Stack pr√≥prio
                        order: 2
                    },
                    // OP. EMPILHADEIRA - Normais sobrep√µe as previstas (frente s√≥lida)
                    { 
                        label: 'Normais - Op. Empilhadeira 1¬∞T', 
                        data: horasNormaisOpEmpData, 
                        backgroundColor: corNormOpEmp, // S√≥lido
                        borderColor: corNormOpEmp,
                        borderWidth: 1,
                        stack: 'empilhadeira', // MESMO stack = sobrep√µe
                        order: 1
                    }
                ], optionsHoras);


                // --- NOVO GR√ÅFICO: Downtime por Motivo (Req 2) ---
                
                // 1. Preparar dados e ordenar por percentual (maior para menor)
                const totalHorasFixoMin = (184 * 60) + 48; // 11088 minutos (184:48 horas)
                
                // Criar array com motivos e valores, depois ordenar por percentual
                const downtimeArray = Object.entries(downtimePorMotivoMin)
                    .map(([motivo, minutos]) => ({
                        motivo: motivo,
                        minutos: minutos,
                        horas: minutos / 60,
                        percentual: (minutos / totalHorasFixoMin) * 100
                    }))
                    .sort((a, b) => b.percentual - a.percentual); // Ordenar por percentual (maior para menor)
                
                const downtimeLabels = downtimeArray.map(item => item.motivo);
                const downtimeDataHoras = downtimeArray.map(item => item.horas);
                
                // Fun√ß√£o para converter horas decimais para formato HH:MM
                const formatarHoras = (horasDecimais) => {
                    const horas = Math.floor(horasDecimais);
                    const minutos = Math.round((horasDecimais - horas) * 60);
                    return `${horas.toString().padStart(2, '0')}:${minutos.toString().padStart(2, '0')}`;
                };
                
                // 2. Op√ß√µes do Gr√°fico (com datalabels)
                const optionsDowntime = {
                    plugins: {
                        datalabels: {
                            display: true,
                            anchor: 'end',
                            align: 'top',
                            color: '#FFFFFF', // Cor do label (branco)
                            font: {
                                weight: 'bold',
                                size: 10
                            },
                            formatter: (value, context) => {
                                // Value √© o total de horas (ex: 10.5)
                                // Calcular percentual
                                const percentual = (value * 60 / totalHorasFixoMin) * 100;
                                const horasFormatadas = formatarHoras(value);
                                return `${horasFormatadas}\n(${percentual.toFixed(1)}%)`; // Ex: "10:30 (5.2%)"
                            },
                            offset: 4,
                            textAlign: 'center'
                        },
                        tooltip: {
                             callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    const value = context.parsed.y;
                                    const percentual = (value * 60 / totalHorasFixoMin) * 100;
                                    const horasFormatadas = formatarHoras(value);
                                    label += `${horasFormatadas} (${percentual.toFixed(1)}%)`;
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Horas Totais'
                            }
                        }
                    }
                };

                // 3. Renderizar Gr√°fico
                renderChart('downtimePorMotivo', 'bar', downtimeLabels, [
                    { 
                        label: 'Horas de Downtime', 
                        data: downtimeDataHoras, 
                        backgroundColor: '#6366F1', // Indigo
                        borderColor: '#4338CA', 
                        borderWidth: 1 
                    }
                ], optionsDowntime);
                
                
                // --- NOVO GR√ÅFICO: Horas de Absente√≠smo por Setor ---
                
                // Cores para o gr√°fico de absente√≠smo (ALINHADAS COM GR√ÅFICO DE HORAS PREVISTAS)
                const corAbsPicking = '#14B8A6'; // Teal (mesma do Picking no gr√°fico horas)
                const corAbsExpedicao = '#F97316'; // Orange (mesma da Expedi√ß√£o no gr√°fico horas)
                const corAbsOpEmp = '#E11D48'; // Rose (mesma da Op. Empilhadeira no gr√°fico horas)
                
                // Op√ß√µes do gr√°fico de absente√≠smo
                const optionsAbsenteismo = {
                    responsive: true,
                    interaction: {
                        mode: 'nearest',
                        intersect: true,
                    },
                    scales: {
                        x: {
                            stacked: false,
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Horas de Absente√≠smo'
                            },
                            ticks: {
                                callback: function(value) {
                                    // Converte decimal para HH:MM
                                    const horas = Math.floor(value);
                                    const minutos = Math.round((value - horas) * 60);
                                    return `${horas}:${minutos.toString().padStart(2, '0')}`;
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                boxWidth: 12,
                                padding: 8,
                                color: '#D1D5DB'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    const value = context.parsed.y;
                                    const horas = Math.floor(value);
                                    const minutos = Math.round((value - horas) * 60);
                                    label += `${horas}:${minutos.toString().padStart(2, '0')}`;
                                    return label;
                                }
                            }
                        }
                    }
                };
                
                // Renderizar gr√°fico de absente√≠smo
                renderChart('horasAbsenteismo', 'bar', monthsLabels, [
                    { 
                        label: 'Picking', 
                        data: horasAbsenteismoPickingData, 
                        backgroundColor: corAbsPicking,
                        borderColor: corAbsPicking,
                        borderWidth: 1 
                    },
                    { 
                        label: 'Expedi√ß√£o', 
                        data: horasAbsenteismoExpedicaoData, 
                        backgroundColor: corAbsExpedicao,
                        borderColor: corAbsExpedicao,
                        borderWidth: 1 
                    },
                    { 
                        label: 'Op. Empilhadeira 1¬∞T', 
                        data: horasAbsenteismoOpEmpData, 
                        backgroundColor: corAbsOpEmp,
                        borderColor: corAbsOpEmp,
                        borderWidth: 1 
                    }
                ], optionsAbsenteismo);

                // *** AGUARDAR DOM ATUALIZAR E CRIAR GR√ÅFICO DO PICKING ***
                setTimeout(() => {
                    // Gr√°fico da sub-aba Picking
                    const pickingCanvas = document.getElementById('pickingPorHrPessoa');
                    console.log('üéØ DEBUG PICKING RENDER: Canvas encontrado?', !!pickingCanvas);
                    console.log('üéØ DEBUG PICKING RENDER: Total de dados de expedi√ß√£o:', expedicaoData.length);
                    
                    if (pickingCanvas) {
                        // *** BUSCAR META CONFIGURADA PARA PICKING ***
                        const metaPickingConfig = metasPorAtividade['Picking'] || null;
                        console.log('üéØ META PICKING CONFIG:', metaPickingConfig);
                        
                        // *** USAR DADOS CALCULADOS DO SISTEMA DE ABSENTE√çSMO ***
                        console.log('üìä DADOS DISPON√çVEIS PARA PICKING:');
                        console.log('- Meses:', monthsLabels);
                        console.log('- Horas normais picking:', horasNormaisPickingData);
                        console.log('- Dados de expedi√ß√£o total:', expData);
                        
                        // Calcular dados de picking por hr/pessoa usando dados j√° calculados
                        const pickingPorHrPessoaData = [];
                        const pickingLabels = [];
                        const datasets = [];
                        
                        // Verificar se temos dados de picking nas horas normais
                        const temDadosPicking = horasNormaisPickingData.some(valor => valor > 0);
                        console.log('üîç Tem dados de picking?', temDadosPicking);
                        
                        if (temDadosPicking) {
                            // Usar os meses e dados j√° calculados
                            monthsLabels.forEach((mes, index) => {
                                const horasNormaisPicking = horasNormaisPickingData[index] || 0;
                                const quantidadeExpedida = expData[index] || 0;
                                
                                if (horasNormaisPicking > 0) {
                                    // Calcular m√©dia de separa√ß√£o por pessoa
                                    // Assumindo que expedi√ß√£o total representa trabalho de picking tamb√©m
                                    // F√≥rmula: Quantidade Expedida √∑ Horas Normais Picking
                                    const pickingPorHora = quantidadeExpedida / horasNormaisPicking;
                                    
                                    pickingLabels.push(mes);
                                    pickingPorHrPessoaData.push(parseFloat(pickingPorHora.toFixed(2)));
                                    
                                    console.log(`üìä ${mes}: ${quantidadeExpedida} itens √∑ ${horasNormaisPicking}h = ${pickingPorHora.toFixed(2)} itens/hora`);
                                } else {
                                    pickingLabels.push(mes);
                                    pickingPorHrPessoaData.push(0);
                                }
                            });
                            
                            // Dataset principal com dados de picking
                            datasets.push({
                                label: 'Itens por Hora (Picking)', 
                                data: pickingPorHrPessoaData, 
                                borderColor: '#06B6D4', 
                                backgroundColor: 'rgba(6, 182, 212, 0.1)',
                                tension: 0.4,
                                fill: true,
                                datalabels: {
                                    display: true,
                                    color: 'white',
                                    backgroundColor: 'rgba(239, 68, 68, 0.8)', // Vermelho fixo (vers√£o est√°vel)
                                    borderRadius: 4,
                                    padding: 4,
                                    font: {
                                        size: 12,
                                        weight: 'bold'
                                    },
                                    formatter: function(value) {
                                        if (!value || !metaPickingConfig || !metaPickingConfig.meta) {
                                            return '';
                                        }
                                        const percentual = (value / metaPickingConfig.meta) * 100;
                                        return percentual.toFixed(1) + '%';
                                    }
                                }
                            });
                            
                            // *** ADICIONAR LINHA DE META (se configurada) ***
                            let pickingSubtitle = 'Quantidade expedida √∑ horas normais do picking (com desconto downtime)';
                            let percentualAtingido = null;
                            
                            if (metaPickingConfig && metaPickingConfig.meta > 0) {
                                const metaPicking = metaPickingConfig.meta;
                                const metaArray = pickingLabels.map(() => metaPicking);
                                
                                // *** CALCULAR PERCENTUAL ATINGIDO ***
                                const mediaRealizada = pickingPorHrPessoaData.reduce((sum, val) => sum + val, 0) / pickingPorHrPessoaData.filter(val => val > 0).length;
                                percentualAtingido = metaPicking > 0 ? (mediaRealizada / metaPicking * 100) : 0;
                                
                                datasets.push({
                                    label: 'Meta Picking',
                                    data: metaArray,
                                    type: 'line',
                                    borderColor: '#EF4444', // Vermelho
                                    backgroundColor: 'transparent',
                                    borderWidth: 2,
                                    borderDash: [5, 5], // Linha tracejada
                                    fill: false,
                                    pointRadius: 0,
                                    pointHoverRadius: 0,
                                    order: 0, // Renderizar por cima
                                    datalabels: {
                                        display: false // N√£o mostrar labels na linha de meta
                                    }
                                });
                                
                                // Atualizar subt√≠tulo para incluir meta e percentual
                                const percentualTexto = percentualAtingido ? ` | Atingimento: ${percentualAtingido.toFixed(1)}%` : '';
                                pickingSubtitle = `Meta: ${metaPicking.toLocaleString('pt-BR')} itens/hora${percentualTexto} | ${pickingSubtitle}`;
                                console.log(`üéØ META PICKING: ${metaPicking} itens/hora | Atingimento: ${percentualAtingido?.toFixed(1)}%`);
                            }
                            
                            // Atualizar subt√≠tulo do gr√°fico
                            const subtitleElement = pickingCanvas.closest('.bg-gray-800').querySelector('p.text-sm');
                            if (subtitleElement) {
                                subtitleElement.textContent = pickingSubtitle;
                            }
                            
                            console.log('üìä DADOS FINAIS PICKING:');
                            console.log('- Labels:', pickingLabels);
                            console.log('- Dados:', pickingPorHrPessoaData);
                            console.log('- Datasets:', datasets.length);
                            
                            // *** CONFIGURA√á√ÉO ESPEC√çFICA PARA PICKING COM DATALABELS ***
                            const pickingChartOptions = {
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        title: {
                                            display: true,
                                            text: 'Itens por Hora'
                                        },
                                        grid: {
                                            color: 'rgba(107, 114, 128, 0.3)'
                                        },
                                        ticks: {
                                            color: '#D1D5DB'
                                        }
                                    },
                                    x: {
                                        grid: {
                                            display: false
                                        },
                                        ticks: {
                                            color: '#D1D5DB'
                                        }
                                    }
                                },
                                plugins: {
                                    tooltip: {
                                        backgroundColor: 'rgba(0,0,0,0.7)',
                                        titleColor: '#FFFFFF',
                                        bodyColor: '#D1D5DB',
                                        borderColor: 'rgba(255,255,255,0.1)',
                                        borderWidth: 1,
                                        callbacks: {
                                            label: function(context) {
                                                const value = context.parsed.y;
                                                const datasetLabel = context.dataset.label;
                                                
                                                if (datasetLabel === 'Meta Picking') {
                                                    return `${datasetLabel}: ${value.toFixed(0)} itens/hora`;
                                                } else {
                                                    // Calcular percentual para este ponto espec√≠fico
                                                    let percentualPonto = '';
                                                    if (metaPickingConfig && metaPickingConfig.meta > 0 && value > 0) {
                                                        const percentual = (value / metaPickingConfig.meta) * 100;
                                                        const status = percentual >= 100 ? '‚úÖ' : percentual >= 80 ? '‚ö†Ô∏è' : '‚ùå';
                                                        percentualPonto = ` (${percentual.toFixed(1)}% ${status})`;
                                                    }
                                                    return `${datasetLabel}: ${value.toFixed(2)} itens/hora${percentualPonto}`;
                                                }
                                            }
                                        }
                                    },
                                    legend: {
                                        labels: {
                                            color: '#D1D5DB'
                                        }
                                    },
                                }
                            };
                            
                            // Renderizar o gr√°fico apenas se h√° dados v√°lidos
                            if (pickingLabels.length > 0 && pickingPorHrPessoaData.some(valor => valor > 0)) {
                                renderChart('pickingPorHrPessoa', 'line', pickingLabels, datasets, pickingChartOptions);
                                
                                console.log('‚úÖ PICKING: Gr√°fico renderizado com sucesso');
                            } else {
                                console.log('‚ùå PICKING: N√£o h√° dados v√°lidos para renderizar');
                            }
                            
                            // Calcular e exibir quantidade de pessoas no m√™s em gr√°fico
                            // Fun√ß√£o interna para ter acesso √†s vari√°veis monthlyAgg e allAbsenteismoAtual
                            function calcularQuantidadePessoasPicking() {
                                try {
                                    console.log('üßÆ Iniciando c√°lculo hist√≥rico de quantidade de pessoas...');
                                    
                                    const mesesDisponiveis = Object.keys(monthlyAgg).sort();
                                    if (mesesDisponiveis.length === 0) {
                                        console.log('‚ùå Nenhum m√™s dispon√≠vel para c√°lculo');
                                        return;
                                    }
                                    
                                    const dadosHistoricos = [];
                                    const labelsHistorico = [];
                                    const percentuaisAtingimento = [];
                                    
                                    // *** USAR OS MESMOS ARRAYS QUE O GR√ÅFICO PICKING POR HR/PESSOA USA ***
                                    console.log('üìä Usando arrays j√° calculados:');
                                    console.log('- monthsLabels:', monthsLabels);
                                    console.log('- expData:', expData);
                                    console.log('- horasNormaisPickingData:', horasNormaisPickingData);
                                    
                                    // Calcular para cada m√™s usando os mesmos dados do gr√°fico Picking por Hr/Pessoa
                                    monthsLabels.forEach((mesLabel, index) => {
                                        const mesAtual = mesesDisponiveis[index];
                                        console.log(`üßÆ Processando ${mesLabel} (${mesAtual})`);
                                        
                                        // Usar dados j√° calculados (mesmos do gr√°fico Picking por Hr/Pessoa)
                                        const horasNormaisMesHoras = horasNormaisPickingData[index] || 0;
                                        const quantidadeExpedida = expData[index] || 0;
                                        
                                        console.log(`üßÆ ${mesLabel}: Horas normais:`, horasNormaisMesHoras.toFixed(2), 'horas');
                                        console.log(`üßÆ ${mesLabel}: Quantidade expedida:`, quantidadeExpedida);
                                        
                                        // Encontrar a maior hora prevista individual de uma pessoa do picking neste m√™s
                                        let maiorHoraPrevistaPessoa = 0;
                                        
                                        // Filtrar dados de absente√≠smo para picking no m√™s atual
                                        const dadosPickingMes = allAbsenteismoAtual.filter(item => {
                                            if (!item.data || !item.locaisDeTrabalho) return false;
                                            const [year, month] = item.data.split('-');
                                            const monthKey = `${year}-${month}`;
                                            return monthKey === mesAtual && 
                                                   item.locaisDeTrabalho.toUpperCase().includes('PICKING');
                                        });
                                        
                                        console.log(`üßÆ ${mesLabel}: Funcion√°rios picking encontrados:`, dadosPickingMes.length);
                                        
                                        // Encontrar a maior hora prevista entre todos os funcion√°rios do picking
                                        dadosPickingMes.forEach(item => {
                                            const horasPrevistas = timeStringToMinutes(item.horasPrevistas || '0:00') / 60; // Converter para horas
                                            if (horasPrevistas > maiorHoraPrevistaPessoa) {
                                                maiorHoraPrevistaPessoa = horasPrevistas;
                                                console.log(`üßÆ ${mesLabel}: Nova maior hora prevista:`, horasPrevistas.toFixed(2), 'horas para', item.colaborador);
                                            }
                                        });
                                        
                                        console.log(`üßÆ ${mesLabel}: Maior hora prevista individual:`, maiorHoraPrevistaPessoa.toFixed(2), 'horas');
                                        
                                        // Calcular quantidade de pessoas
                                        let quantidadePessoas = 0;
                                        if (maiorHoraPrevistaPessoa > 0 && horasNormaisMesHoras > 0) {
                                            quantidadePessoas = horasNormaisMesHoras / maiorHoraPrevistaPessoa;
                                        }
                                        
                                        // *** CALCULAR PERCENTUAL EXATAMENTE COMO NO GR√ÅFICO PICKING POR HR/PESSOA ***
                                        let percentualAtingimento = 0;
                                        let pickingPorHora = 0;
                                        
                                        if (horasNormaisMesHoras > 0) {
                                            // Usar a mesma f√≥rmula: Quantidade Expedida √∑ Horas Normais Picking
                                            pickingPorHora = quantidadeExpedida / horasNormaisMesHoras;
                                            
                                            // Calcular percentual baseado na meta (exatamente como no outro gr√°fico)
                                            if (metaPickingConfig && metaPickingConfig.meta > 0) {
                                                percentualAtingimento = (pickingPorHora / metaPickingConfig.meta) * 100;
                                            }
                                        }
                                        
                                        console.log(`üßÆ ${mesLabel}: Picking por hora:`, pickingPorHora.toFixed(2), 'itens/hora');
                                        console.log(`üßÆ ${mesLabel}: Meta picking:`, metaPickingConfig?.meta || 'N√£o configurada');
                                        console.log(`üßÆ ${mesLabel}: Percentual de atingimento:`, percentualAtingimento.toFixed(1), '%');
                                        console.log(`üßÆ ${mesLabel}: Quantidade de pessoas calculada:`, quantidadePessoas.toFixed(1));
                                        
                                        // Adicionar aos dados hist√≥ricos
                                        dadosHistoricos.push(parseFloat(quantidadePessoas.toFixed(1)));
                                        percentuaisAtingimento.push(percentualAtingimento);
                                        labelsHistorico.push(mesLabel); // Usar o mesmo label formatado
                                    });
                                    
                                    console.log('üßÆ Dados hist√≥ricos calculados:', dadosHistoricos);
                                    console.log('üßÆ Percentuais de atingimento da meta:', percentuaisAtingimento);
                                    console.log('üßÆ Labels:', labelsHistorico);
                                    
                                    // Renderizar gr√°fico
                                    if (dadosHistoricos.length > 0 && dadosHistoricos.some(valor => valor > 0)) {
                                        const datasets = [{
                                            label: 'Quantidade de Pessoas',
                                            data: dadosHistoricos,
                                            borderColor: '#3B82F6',
                                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                            borderWidth: 3,
                                            fill: true,
                                            tension: 0.4,
                                            pointBackgroundColor: '#3B82F6',
                                            pointBorderColor: '#FFFFFF',
                                            pointBorderWidth: 2,
                                            pointRadius: 6,
                                            pointHoverRadius: 8
                                        }];
                                        
                                        // Calcular m√©dia para linha de refer√™ncia
                                        const media = dadosHistoricos.reduce((sum, val) => sum + val, 0) / dadosHistoricos.filter(val => val > 0).length;
                                        
                                        if (!isNaN(media) && media > 0) {
                                            datasets.push({
                                                label: `M√©dia: ${media.toFixed(1)} pessoas`,
                                                data: Array(dadosHistoricos.length).fill(media),
                                                borderColor: '#10B981',
                                                backgroundColor: 'transparent',
                                                borderWidth: 2,
                                                borderDash: [5, 5],
                                                fill: false,
                                                pointRadius: 0,
                                                pointHoverRadius: 0
                                            });
                                        }
                                        
                                        const chartOptions = {
                                            responsive: true,
                                            maintainAspectRatio: false,
                                            scales: {
                                                y: {
                                                    beginAtZero: true,
                                                    grid: { color: 'rgba(107, 114, 128, 0.3)' },
                                                    ticks: { 
                                                        color: '#D1D5DB',
                                                        callback: function(value) {
                                                            return value.toFixed(1) + ' pessoas';
                                                        }
                                                    },
                                                    title: {
                                                        display: true,
                                                        text: 'Quantidade de Pessoas',
                                                        color: '#D1D5DB'
                                                    }
                                                },
                                                x: {
                                                    grid: { color: 'rgba(107, 114, 128, 0.3)' },
                                                    ticks: { color: '#D1D5DB' }
                                                }
                                            },
                                            plugins: {
                                                tooltip: {
                                                    callbacks: {
                                                        label: function(context) {
                                                            const value = context.parsed.y;
                                                            const datasetLabel = context.dataset.label;
                                                            const index = context.dataIndex;
                                                            
                                                            if (datasetLabel.includes('M√©dia')) {
                                                                return `${datasetLabel}`;
                                                            } else {
                                                                // Pegar percentual de atingimento da meta correspondente
                                                                const percentual = percentuaisAtingimento[index] || 0;
                                                                
                                                                // Determinar status baseado no percentual de atingimento da meta
                                                                let status = '';
                                                                if (percentual <= 79) {
                                                                    status = '‚úÖ Opera√ß√£o Confort√°vel';
                                                                } else if (percentual <= 89) {
                                                                    status = '‚ö†Ô∏è Aten√ß√£o Necess√°ria';
                                                                } else {
                                                                    status = 'üö® Necess√°ria Contrata√ß√£o';
                                                                }
                                                                
                                                                return [
                                                                    `${datasetLabel}: ${value.toFixed(1)} pessoas`,
                                                                    `Carga da Opera√ß√£o: ${percentual.toFixed(1)}%`,
                                                                    `Status: ${status}`
                                                                ];
                                                            }
                                                        }
                                                    }
                                                },
                                                legend: {
                                                    labels: { color: '#D1D5DB' }
                                                }
                                            }
                                        };
                                        
                                        // Renderizar gr√°fico
                                        renderChart('quantidadePessoasPicking', 'line', labelsHistorico, datasets, chartOptions);
                                        console.log('‚úÖ Gr√°fico de quantidade de pessoas renderizado com sucesso');
                                        
                                    } else {
                                        console.log('‚ùå N√£o h√° dados v√°lidos para renderizar gr√°fico de pessoas');
                                    }
                                    
                                } catch (error) {
                                    console.error('‚ùå Erro ao calcular quantidade de pessoas:', error);
                                }
                            }
                            
                            calcularQuantidadePessoasPicking();
                            
                        } else {
                            console.log('‚ùå PICKING: Nenhuma hora normal de picking encontrada');
                        }
                    } else {
                        console.log('‚ùå PICKING: Canvas n√£o encontrado');
                    }
                }, 200);

            }

            function createChartContainer(id, title, subtitle = null, showToggleButton = false, infoTooltip = null) {
                const toggleButtonHtml = showToggleButton ? 
                    `<button id="${id}-toggle-btn" class="btn-primary py-1 px-3 rounded text-sm ml-2">√öltimos 30 dias</button>` : '';
                
                const infoTooltipHtml = infoTooltip ? `
                    <div class="chart-info-tooltip">
                        !
                        <div class="tooltip-card">
                            ${infoTooltip}
                        </div>
                    </div>
                ` : '';
                
                return `
                    <div class="bg-gray-800 p-4 rounded-lg border border-gray-700 shadow-md relative"> <!-- Adicionado relative para posicionamento -->
                        ${infoTooltipHtml}
                        <div class="flex items-center justify-between mb-1">
                            <h3 class="text-lg font-semibold text-gray-200">${title}</h3>
                            ${toggleButtonHtml}
                        </div>
                        ${subtitle ? `<p class="text-sm text-gray-400 mb-2">${subtitle}</p>` : '<div class="mb-2"></div>'}
                        <div class="chart-container"><canvas id="${id}"></canvas></div>
                    </div>
                `;
            }

            function renderChart(canvasId, type, labels, datasets, customOptions = {}) {
                // Verificar se Chart.js est√° dispon√≠vel
                if (typeof Chart === 'undefined') {
                    console.error(`‚ùå Chart.js n√£o dispon√≠vel para renderizar gr√°fico ${canvasId}`);
                    return;
                }
                
                // Destruir gr√°fico anterior se existir
                if (charts[canvasId]) {
                    charts[canvasId].destroy();
                }
                
                // Obter contexto do canvas
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) {
                    console.error(`‚ùå Canvas element with id "${canvasId}" not found.`);
                    return;
                }
                
                // Verificar se h√° dados v√°lidos
                const hasValidData = datasets && datasets.length > 0 && 
                                   datasets.some(dataset => dataset.data && dataset.data.length > 0 && 
                                                dataset.data.some(value => value != null && value !== 0));
                
                if (!hasValidData) {
                    console.warn(`‚ö†Ô∏è Gr√°fico ${canvasId}: sem dados v√°lidos para renderizar`);
                    console.log(`Datasets recebidos:`, datasets);
                    
                    // Mostrar mensagem de "sem dados" no canvas
                    const container = ctx.canvas.parentElement;
                    if (container) {
                        container.innerHTML = `
                            <div class="flex items-center justify-center h-64 text-gray-400">
                                <div class="text-center">
                                    <div class="text-4xl mb-2">üìä</div>
                                    <div class="text-lg">Sem dados para exibir</div>
                                </div>
                            </div>
                        `;
                    }
                    return;
                }
                
                // As cores padr√£o (Chart.defaults.color e .borderColor) j√° foram definidas no topo do script.

                // Objeto de op√ß√µes base com cores de texto corrigidas
                const options = {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(107, 114, 128, 0.3)' // Cor da grade Y (var(--chart-grid-color))
                            },
                            ticks: {
                                 color: '#D1D5DB' // Cor do texto/label Y (var(--chart-label-color))
                            }
                        },
                        x: {
                            grid: {
                                display: false // Hide X-axis grid lines
                            },
                            ticks: {
                                color: '#D1D5DB' // Cor do texto/label X (var(--chart-label-color))
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#D1D5DB' // Cor da legenda (var(--text-color))
                            }
                        },
                        tooltip: { // Estilo original do tooltip
                            backgroundColor: 'rgba(0,0,0,0.7)',
                            titleColor: '#FFFFFF',
                            bodyColor: '#D1D5DB',
                            borderColor: 'rgba(255,255,255,0.1)',
                            borderWidth: 1
                        },
                        datalabels: {
                            display: false // Por padr√£o, n√£o mostrar (deixar para configura√ß√£o individual do dataset)
                        }
                    }
                };

                // Mescla escalas customizadas (se houver)
                if (customOptions.scales) {
                    // Simples merge, pode ser melhorado se precisarmos de deep merge
                    if(options.scales.y && customOptions.scales.y) options.scales.y = { ...options.scales.y, ...customOptions.scales.y };
                    if(options.scales.x && customOptions.scales.x) options.scales.x = { ...options.scales.x, ...customOptions.scales.x };
                }
                 // Mescla op√ß√µes de plugins customizados (tooltip, datalabels, etc)
                if (customOptions.plugins) {
                     // Deep merge de cada plugin customizado
                    Object.keys(customOptions.plugins).forEach(pluginKey => {
                        options.plugins[pluginKey] = { ...options.plugins[pluginKey], ...customOptions.plugins[pluginKey] };
                    });
                }
                
                try {
                    // Determinar plugins dispon√≠veis
                    const availablePlugins = [];
                    if (window.ChartDataLabels) {
                        availablePlugins.push(ChartDataLabels);
                    }

                    // Criar o gr√°fico
                    charts[canvasId] = new Chart(ctx, {
                        type: type,
                        data: { labels, datasets },
                        options: options,
                        plugins: availablePlugins
                    });
                    
                    console.log(`‚úÖ Gr√°fico ${canvasId} criado com sucesso`);
                    
                } catch (chartError) {
                    console.error(`‚ùå Erro ao criar gr√°fico ${canvasId}:`, chartError);
                    
                    // Tentar criar gr√°fico b√°sico sem plugins como fallback
                    try {
                        charts[canvasId] = new Chart(ctx, {
                            type: type,
                            data: { labels, datasets },
                            options: options
                        });
                        console.log(`‚ö†Ô∏è Gr√°fico ${canvasId} criado sem plugins (fallback)`);
                    } catch (fallbackError) {
                        console.error(`‚ùå Falha total ao criar gr√°fico ${canvasId}:`, fallbackError);
                        
                        // Mostrar mensagem de erro no canvas
                        const container = ctx.canvas.parentElement;
                        if (container) {
                            container.innerHTML = `
                                <div class="flex items-center justify-center h-64 text-red-400">
                                    <div class="text-center">
                                        <div class="text-4xl mb-2">‚ö†Ô∏è</div>
                                        <div class="text-lg">Erro ao renderizar gr√°fico</div>
                                        <div class="text-sm mt-2">${fallbackError.message}</div>
                                    </div>
                                </div>
                            `;
                        }
                    }
                }
            }


            async function getFirestoreCollection(collectionPath) {
                 if (!isFirebaseInitialized || !collectionPath) {
                     console.warn("Firebase not ready or collection path invalid for getFirestoreCollection");
                    return [];
                }
                try {
                    const q = query(collection(db, collectionPath));
                    const querySnapshot = await getDocs(q);
                    const data = [];
                    querySnapshot.forEach(doc => data.push({id: doc.id, ...doc.data()}));
                    // console.log(`Fetched ${data.length} documents from ${collectionPath}`); // Optional: Log success
                    return data;
                } catch (error) {
                    console.error(`Error fetching collection ${collectionPath}:`, error);
                    showFeedback(`Erro ao buscar dados: ${collectionPath.split('/').pop()}. Verifique as regras de seguran√ßa.`, "error", 5000);
                    return []; // Return empty array on error
                }
            }

            async function getRecentAbsenteismoData(collectionPath) {
                if (!isFirebaseInitialized || !collectionPath) {
                    console.warn("Firebase not ready or collection path invalid for getRecentAbsenteismoData");
                    return [];
                }
                try {
                    // Calcular data limite (12 meses atr√°s)
                    const dataLimite = new Date();
                    dataLimite.setMonth(dataLimite.getMonth() - 12);
                    const dataLimiteStr = dataLimite.toISOString().split('T')[0]; // YYYY-MM-DD
                    
                    console.log(`üîç Buscando dados de absente√≠smo ap√≥s: ${dataLimiteStr}`);
                    
                    const q = query(collection(db, collectionPath));
                    const querySnapshot = await getDocs(q);
                    const data = [];
                    
                    querySnapshot.forEach(doc => {
                        const docData = doc.data();
                        // Filtrar apenas dados recentes (√∫ltimos 12 meses)
                        if (docData.data && docData.data >= dataLimiteStr) {
                            data.push({id: doc.id, ...docData});
                        }
                    });
                    
                    console.log(`‚úÖ Dados de absente√≠smo filtrados: ${data.length} registros (ap√≥s ${dataLimiteStr})`);
                    return data;
                } catch (error) {
                    console.error(`Error fetching recent absenteismo data:`, error);
                    showFeedback(`Erro ao buscar dados de absente√≠smo recentes.`, "error", 5000);
                    return [];
                }
            }


            // --- Expedi√ß√£o Functions ---
            async function handleExpedicaoFile(file) {
                if (!file) return;
                showFileInfo(expedicaoElements, file);
                expedicaoElements.loader.classList.remove('hidden');

                try {
                    const data = await parseExcelOrCsv(file);
                    expedicaoData = processExpedicaoData(data); // Store processed data locally
                    console.log("‚úÖ Expedi√ß√£o processada:", expedicaoData.length, "registros");
                    
                    // *** MODIFICADO: Salvar apenas info resumida no localStorage ***
                    try {
                        const dataInfo = {
                            count: expedicaoData.length,
                            lastUpdate: new Date().toISOString(),
                            hasData: expedicaoData.length > 0
                        };
                        localStorage.setItem('expedicaoDataInfo', JSON.stringify(dataInfo));
                        console.log(`üíæ Info de expedi√ß√£o salva no localStorage: ${expedicaoData.length} registros`);
                    } catch (storageError) {
                        console.warn('‚ö†Ô∏è N√£o foi poss√≠vel salvar no localStorage:', storageError.message);
                    }
                    
                    expedicaoElements.loader.classList.add('hidden');
                    showFeedback(`Arquivo de expedi√ß√£o carregado com ${expedicaoData.length} registros v√°lidos.`, "success");
                    if (movimentacoesData.length > 0) {
                        console.log("üîÑ Recalculando indicadores (expedi√ß√£o + movimenta√ß√£o)...");
                        calcularIndicadoresOperacao(); // Recalculate if both datasets are present
                    }
                } catch (error) {
                    console.error("Erro ao processar arquivo de expedi√ß√£o:", error);
                     showFeedback("Houve um erro ao ler o arquivo de expedi√ß√£o. Verifique o formato.", "error");
                    expedicaoElements.loader.classList.add('hidden');
                     // Clear data if processing failed
                     expedicaoData = [];
                     if (operacaoElements && operacaoElements.chartsContainer && operacaoElements.placeholder) {
                        operacaoElements.chartsContainer.classList.add('hidden');
                        operacaoElements.placeholder.classList.remove('hidden');
                    }
                }
            }

            function processExpedicaoData(data) {
                 // ATUALIZADO: Usar Coluna M (M√™s) e N (Ano) ao inv√©s da Data Envio para agrega√ß√£o
                 console.log("üîç DEBUG COLUNA M: Primeiros 5 registros da expedi√ß√£o:");
                 data.slice(0, 5).forEach((row, i) => {
                     console.log(`Registro ${i + 1}:`, {
                         'M√™s (M)': row['M√™s'] || row['Mes'],
                         'Ano (N)': row['Ano'] || row['ano'],
                         'Quantidade (Q)': row['Quantidade'],
                         'Data Envio (K)': row['Data Envio'] || row['Data envio']
                     });
                 });
                
                return data.map(row => {
                    const dataEnvio = excelDateToJSDate(row['Data Envio'] || row['Data envio']); // Coluna K (mantida para refer√™ncia)
                    const quantidade = parseFloat(row['Quantidade']); // Coluna Q
                    const mesColuna = row['M√™s'] || row['Mes']; // Coluna M (M√™s)
                    const anoColuna = row['Ano'] || row['ano']; // Coluna N (Ano), se dispon√≠vel

                    return {
                        ...row, // Manter dados originais
                        dataEnvio: dataEnvio, // Objeto Date ou null (mantido para compatibilidade)
                        quantidade: !isNaN(quantidade) ? quantidade : 0, // N√∫mero
                        mesRef: mesColuna, // NOVO: M√™s da Coluna M
                        anoRef: anoColuna || 2025, // NOVO: Ano da Coluna N ou padr√£o 2025
                    };
                })
                // Filtro ATUALIZADO: Requer M√™s (Coluna M) e Quantidade (Q) v√°lidos
                .filter(row => row.mesRef && !isNaN(row.quantidade));
            }


            // --- Absente√≠smo Functions ---
            async function handleAbsenteismoFile(file) {
                if (!file) return;
                showFileInfo(absenteismoElements, file);
                absenteismoElements.loader.classList.remove('hidden');
                absenteismoElements.feedback.innerHTML = ''; // Clear previous specific feedback

                try {
                    const { jsonData, reportDate } = await processAbsenteismoFile(file);

                    if(!reportDate) {
                        throw new Error("N√£o foi poss√≠vel encontrar a data do relat√≥rio no arquivo. Verifique se a data est√° na 4¬™ linha (c√©lula C4 ou A4).");
                    }

                    if (!jsonData || jsonData.length === 0) {
                        throw new Error("Nenhum dado de colaborador v√°lido foi encontrado no arquivo. Verifique o formato do arquivo.");
                    }

                    absenteismoData = jsonData; // Store parsed data temporarily
                    absenteismoFileDate = reportDate; // Store parsed date (should be UTC)

                     // Display date in pt-BR format for the user
                    absenteismoElements.datePreview.textContent = reportDate.toLocaleDateString('pt-BR', { timeZone: 'UTC' });
                    absenteismoElements.previewContainer.classList.remove('hidden');
                     absenteismoElements.saveBtn.disabled = false; // Enable save button


                } catch (error) {
                    console.error("Erro ao processar arquivo de absente√≠smo:", error);
                    absenteismoElements.feedback.innerHTML = `<p class="text-red-400 text-sm">${error.message}</p>`; // Show specific error
                    absenteismoElements.previewContainer.classList.add('hidden'); // Hide save button on error
                    absenteismoData = []; // Clear data on error
                    absenteismoFileDate = null;
                } finally {
                    absenteismoElements.loader.classList.add('hidden');
                }
            }

            function processAbsenteismoFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const worksheet = workbook.Sheets[workbook.SheetNames[0]];

                            let reportDate = null;
                             // Try C4 first, then A4 for the date string
                            const cellC4 = worksheet['C4'];
                            const cellA4 = worksheet['A4'];

                            let dateLine = '';
                            if (cellC4 && (cellC4.w || cellC4.v)) {
                                dateLine = cellC4.w || String(cellC4.v); // Ensure string conversion
                            } else if (cellA4 && (cellA4.w || cellA4.v)) { // Corrigido: cella4 -> cellA4
                                dateLine = cellA4.w || String(cellA4.v); // Ensure string conversion
                            }

                            if (dateLine) {
                                // Extract the *first* date found in the format dd/mm/yyyy
                                const dateMatch = dateLine.match(/(\d{2}\/\d{2}\/\d{4})/);
                                if (dateMatch && dateMatch[1]) {
                                    const [day, month, year] = dateMatch[1].split('/');
                                    // Create date in UTC to avoid timezone shifts
                                    reportDate = new Date(Date.UTC(year, month - 1, day));
                                    // Validate the created date
                                    if (isNaN(reportDate.getTime())) {
                                        reportDate = null; // Invalidate if date is wrong
                                        console.warn("Invalid date parsed from file:", dateMatch[1]);
                                    }
                                }
                            }

                             // Start reading data from row 5 (index 4)
                            const jsonDataRaw = XLSX.utils.sheet_to_json(worksheet, { range: 4 });

                            const jsonData = jsonDataRaw.filter(row => row && row['Colaborador'] && String(row['Colaborador']).trim()) // Ensure 'Colaborador' exists and is not empty
                                .map(row => {
                                    const colaborador = String(row['Colaborador']).trim();
                                    const horasNormaisRaw = row['Horas Normais Trabalhadas'];
                                    
                                    // Fun√ß√£o para processar valores de tempo do Excel
                                    const processTimeValue = (value) => {
                                        if (value === null || value === undefined || value === '') return '00:00';
                                        
                                        // Se √© n√∫mero (fra√ß√£o do Excel), converte para HH:MM
                                        if (typeof value === 'number') {
                                            const totalMinutes = Math.round(value * 1440); // 1440 min = 1 dia
                                            const hours = Math.floor(totalMinutes / 60);
                                            const minutes = totalMinutes % 60;
                                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                                        }
                                        
                                        // Se j√° √© string, retorna como est√°
                                        return String(value).trim();
                                    };
                                    
                                    const horasNormais = processTimeValue(horasNormaisRaw);
                                    
                                    return {
                                        colaborador: colaborador,
                                        // Use empty string as default for potentially missing fields
                                        cargo: String(row['Cargo'] || '').trim(),
                                        locaisDeTrabalho: String(row['Locais de Trabalho'] || '').trim(),
                                        horasPrevistas: processTimeValue(row['Horas Previstas']),
                                        horasNormaisTrabalhadas: horasNormais,
                                        horasExtras: processTimeValue(row['Horas Extras']),
                                        horasTotaisTrabalhadas: processTimeValue(row['Horas Totais Trabalhadas'])
                                        // Add other relevant fields if needed
                                    };
                                });

                            resolve({ jsonData, reportDate });

                        } catch (err) {
                            console.error("Error parsing absenteismo file:", err);
                            reject(new Error("N√£o foi poss√≠vel ler o arquivo Excel. Verifique se n√£o est√° corrompido ou protegido."));
                        }
                    };
                    reader.onerror = (err) => {
                         console.error("FileReader error:", err);
                         reject(new Error("Erro ao ler o arquivo selecionado."));
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            async function saveAbsenteismoToFirestore() {
                console.log(`üíæ Iniciando salvamento no Firestore...`);
                console.log(`üìä Dados processados:`, processedAbsenteismoData);
                console.log(`üî• Firebase inicializado:`, isFirebaseInitialized);
                
                // Aguardar inicializa√ß√£o do Firebase se necess√°rio
                if (!isFirebaseInitialized) {
                    console.log("‚è≥ Aguardando inicializa√ß√£o do Firebase...");
                    showFeedback("Aguardando inicializa√ß√£o do Firebase...", "info", 2000);
                    
                    const firebaseReady = await waitForFirebaseInit();
                    if (!firebaseReady) {
                        console.error('‚ùå Erro: Firebase n√£o inicializou a tempo');
                        showFeedback("Erro: Firebase n√£o inicializou. Tente novamente em alguns segundos.", "error");
                        return;
                    }
                    console.log("‚úÖ Firebase inicializado, prosseguindo com salvamento...");
                }
                
                 // Use data stored in processedAbsenteismoData (from multiple files)
                if (!processedAbsenteismoData || processedAbsenteismoData.length === 0) {
                     console.error('‚ùå Erro: dados inv√°lidos');
                     showFeedback("N√£o h√° dados de absente√≠smo v√°lidos para salvar.", "warning");
                    return;
                }

                // Verificar se deve manter dados antigos
                const keepOldData = document.getElementById('keep-old-data-checkbox')?.checked ?? true;
                console.log(`üîÑ Op√ß√£o manter dados antigos: ${keepOldData}`);

                const collectionPath = getFirestorePath('absenteismo');
                if (!collectionPath) {
                    showFeedback("Erro: N√£o foi poss√≠vel obter o caminho do banco de dados para absente√≠smo.", "error");
                    return;
                }

                absenteismoElements.loader.classList.remove('hidden');
                absenteismoElements.saveBtn.disabled = true;
                absenteismoElements.feedback.innerHTML = ''; // Clear specific feedback

                try {
                    // Se n√£o deve manter dados antigos, fazer limpeza completa antes de importar
                    if (!keepOldData) {
                        console.log(`üßπ Fazendo limpeza completa antes de importar novos dados...`);
                        
                        // Buscar todos os documentos existentes
                        const q = query(collection(db, collectionPath));
                        const querySnapshot = await getDocs(q);
                        
                        if (querySnapshot.size > 0) {
                            console.log(`üóëÔ∏è Encontrados ${querySnapshot.size} registros antigos. Limpando...`);
                            
                            // Deletar em lotes
                            const batchSize = 50;
                            const docs = querySnapshot.docs;
                            let deletedCount = 0;
                            
                            for (let i = 0; i < docs.length; i += batchSize) {
                                const deleteBatch = writeBatch(db);
                                const currentBatch = docs.slice(i, i + batchSize);
                                
                                currentBatch.forEach(doc => {
                                    deleteBatch.delete(doc.ref);
                                    deletedCount++;
                                });
                                
                                await deleteBatch.commit();
                                console.log(`‚úÖ Lote ${Math.floor(i/batchSize) + 1}: ${currentBatch.length} registros deletados`);
                            }
                            
                            console.log(`‚úÖ Limpeza completa finalizada: ${deletedCount} registros deletados`);
                            
                            // Aguardar um pouco para garantir que a limpeza foi conclu√≠da
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        } else {
                            console.log(`üìù Nenhum registro antigo encontrado`);
                        }
                    } else {
                        // Se deve manter dados antigos, limpar apenas per√≠odos que ser√£o atualizados
                        const periodosNovos = [...new Set(processedAbsenteismoData.map(item => item.mesAno))];
                        console.log(`üóëÔ∏è Limpando dados antigos dos per√≠odos: ${periodosNovos.join(', ')}`);
                        
                        for (const periodo of periodosNovos) {
                            await deleteAbsenteismoByPeriod(collectionPath, periodo);
                        }
                    }

                    const batch = writeBatch(db);
                    
                    // Group data by date to check for existing records
                    const dataByDate = {};
                    processedAbsenteismoData.forEach(record => {
                        const dateString = record.data; // Already in YYYY-MM-DD format
                        console.log(`üìã Agrupando registro para data ${dateString}:`, record);
                        if (!dataByDate[dateString]) {
                            dataByDate[dateString] = [];
                        }
                        dataByDate[dateString].push(record);
                    });

                    const dates = Object.keys(dataByDate);
                    console.log(`üìÖ Datas encontradas nos dados:`, dates);
                    console.log(`üìä Registros por data:`, Object.keys(dataByDate).map(date => ({
                        data: date,
                        quantidade: dataByDate[date].length
                    })));
                    
                    let overwriteRequired = false;
                    let existingDates = [];

                    // Check for existing records for each date
                    for (const dateString of dates) {
                        console.log(`üîç Verificando se existe data ${dateString} no Firestore...`);
                        const q = query(collection(db, collectionPath), where("data", "==", dateString));
                        const querySnapshot = await getDocs(q);
                        console.log(`üìä Documentos existentes para ${dateString}: ${querySnapshot.size}`);
                        if (!querySnapshot.empty) {
                            overwriteRequired = true;
                            existingDates.push(dateString);
                        }
                    }

                    // Handle overwrite confirmation
                    if (overwriteRequired) {
                        // Check if this is the second click (confirmation)
                        if (absenteismoElements.saveBtn.dataset.confirming === 'true') {
                            // Delete existing documents before adding new ones
                            for (const dateString of existingDates) {
                                const q = query(collection(db, collectionPath), where("data", "==", dateString));
                                const querySnapshot = await getDocs(q);
                                querySnapshot.forEach(doc => batch.delete(doc.ref));
                                console.log(`Overwriting existing records for ${dateString}`);
                            }
                            // Reset the button state
                            delete absenteismoElements.saveBtn.dataset.confirming;
                            absenteismoElements.saveBtn.textContent = 'Salvar no Hist√≥rico';
                        } else {
                            // First click: Show warning and change button state
                            const datesText = existingDates.map(d => new Date(d + 'T00:00:00Z').toLocaleDateString('pt-BR')).join(', ');
                            showFeedback(`J√° existem dados para as datas: ${datesText}. Clique em 'Confirmar Sobrescrita' para substitu√≠-los.`, "warning", 7000);
                            absenteismoElements.saveBtn.textContent = 'Confirmar Sobrescrita';
                            absenteismoElements.saveBtn.dataset.confirming = 'true'; // Mark as confirming
                            absenteismoElements.loader.classList.add('hidden');
                            absenteismoElements.saveBtn.disabled = false;
                            return; // Stop execution, wait for confirmation click
                        }
                    }

                    // Proceed to save all records
                    processedAbsenteismoData.forEach((record, index) => {
                        // Generate a unique ID based on date and collaborator name (sanitized)
                        const recordId = `${record.data}_${record.colaborador.replace(/[^a-zA-Z0-9\-_]/g, '-')}_${index}`;
                        const docRef = doc(db, collectionPath, recordId);
                        batch.set(docRef, record);
                    });

                    await batch.commit();

                    const totalDates = dates.length;
                    const totalRecords = processedAbsenteismoData.length;
                    showFeedback(`Hist√≥rico de absente√≠smo salvo com sucesso! ${totalRecords} registros em ${totalDates} data(s).`, "success");
                    
                    // Clear processed data and reset UI
                    processedAbsenteismoData = [];
                    absenteismoElements.previewContainer.classList.add('hidden');
                    absenteismoElements.filesList.classList.add('hidden');
                    absenteismoElements.fileInput.value = '';
                    
                    loadAbsenteismoHistory(); // Refresh the table to show the newly saved data
                    loadAbsenteismoDataList(); // Atualizar lista de gerenciamento
                    
                    // Recalcular indicadores se os dados de absente√≠smo (necess√°rios para downtime) mudarem
                    if (expedicaoData.length > 0 && movimentacoesData.length > 0) {
                        calcularIndicadoresOperacao();
                    }

                    // Reset button state if it was confirming
                    if (absenteismoElements.saveBtn.dataset.confirming) {
                         delete absenteismoElements.saveBtn.dataset.confirming;
                         absenteismoElements.saveBtn.textContent = 'Salvar no Hist√≥rico';
                    }

                } catch (error) {
                    console.error("Firestore save error: ", error);
                     if (error.code === 'failed-precondition' || (error.message && error.message.includes('offline'))) {
                         showFeedback("Sem conex√£o. Seus dados ser√£o salvos quando a conex√£o for restaurada.", "warning");
                     } else {
                         showFeedback("Erro ao salvar o hist√≥rico no Firestore.", "error");
                     }
                      // Reset button state on error
                    if (absenteismoElements.saveBtn.dataset.confirming) {
                        delete absenteismoElements.saveBtn.dataset.confirming;
                        absenteismoElements.saveBtn.textContent = 'Salvar no Hist√≥rico';
                    }
                } finally {
                    absenteismoElements.loader.classList.add('hidden');
                    absenteismoElements.saveBtn.disabled = false;
                }
            }


            async function loadAbsenteismoHistory(filterDate = null) {
                console.log(`üîç Carregando hist√≥rico de absente√≠smo...`);
                 if (!isFirebaseInitialized) {
                     console.warn("Firebase not ready for loadAbsenteismoHistory");
                    return;
                }
                 const collectionPath = getFirestorePath('absenteismo');
                 if (!collectionPath) {
                    // Feedback already shown by getFirestorePath
                    return;
                }

                const selectedDate = filterDate || absenteismoElements.dateFilter.value;
                console.log(`üìÖ Data selecionada: ${selectedDate}`);

                if (!selectedDate) {
                     absenteismoElements.tableContainer.innerHTML = '';
                     absenteismoElements.placeholder.classList.remove('hidden');
                     absenteismoElements.placeholder.querySelector('p').textContent = 'Selecione uma data para visualizar o hist√≥rico.';
                    return;
                }

                absenteismoElements.placeholder.classList.add('hidden');
                absenteismoElements.tableContainer.innerHTML = '<p class="text-center text-gray-400">Carregando hist√≥rico...</p>';

                try {
                    // Query Firestore for records matching the selected date
                    console.log(`üî• Consultando Firestore para data: ${selectedDate}`);
                    const q = query(collection(db, collectionPath), where("data", "==", selectedDate));
                    const querySnapshot = await getDocs(q);
                    console.log(`üìä Documentos encontrados: ${querySnapshot.size}`);

                    if (querySnapshot.empty) {
                         // Display date in pt-BR format, ensuring UTC interpretation
                        const displayDate = new Date(selectedDate + 'T00:00:00Z').toLocaleDateString('pt-BR', { timeZone: 'UTC' });
                        console.log(`‚ùå Nenhum registro encontrado para ${selectedDate}`);
                         absenteismoElements.tableContainer.innerHTML = `<p class="text-center text-gray-400 mt-4">Nenhum registro para ${displayDate}.</p>`;
                        return;
                    }

                    let historyData = [];
                    querySnapshot.forEach((doc) => {
                        console.log(`üìÑ Documento:`, doc.id, doc.data());
                        historyData.push({ id: doc.id, ...doc.data() });
                    }); // Include ID if needed
                    
                    console.log(`‚úÖ Total de registros carregados: ${historyData.length}`);
                    renderAbsenteismoTable(historyData); // Render the fetched data

                } catch (error) {
                    console.error("Error loading history: ", error);
                     showFeedback("Erro ao carregar o hist√≥rico de absente√≠smo.", "error");
                    absenteismoElements.tableContainer.innerHTML = `<p class="text-center text-red-400 mt-4">Erro ao carregar o hist√≥rico.</p>`;
                }
            }

            function renderAbsenteismoTable(data) {
                // Sort data alphabetically by collaborator name
                 data.sort((a, b) => (a.colaborador || '').localeCompare(b.colaborador || ''));

                const tableHTML = `
                    <div class="overflow-x-auto relative shadow-md sm:rounded-lg">
                        <table class="w-full text-sm text-left text-gray-400">
                            <thead class="text-xs text-gray-300 uppercase bg-gray-700">
                                <tr>
                                    <th scope="col" class="px-6 py-3">Colaborador</th>
                                    <th scope="col" class="px-6 py-3">Cargo</th>
                                    <th scope="col" class="px-6 py-3">Locais de Trabalho</th>
                                    <th scope="col" class="px-6 py-3">Horas Previstas</th>
                                    <th scope="col" class="px-6 py-3">Horas Normais Trabalhadas</th>
                                    <th scope="col" class="px-6 py-3">Horas Extras</th>
                                    <th scope="col" class="px-6 py-3">Horas Totais Trabalhadas</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${data.map(row => `
                                    <tr class="bg-gray-800 border-b border-gray-700 hover:bg-gray-600">
                                        <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">${row.colaborador}</th>
                                        <td class="px-6 py-4">${row.cargo || ''}</td>
                                        <td class="px-6 py-4">${row.locaisDeTrabalho || ''}</td>
                                        <td class="px-6 py-4">${row.horasPrevistas || '00:00'}</td>
                                        <td class="px-6 py-4">${row.horasNormaisTrabalhadas || '00:00'}</td>
                                        <td class="px-6 py-4">${row.horasExtras || '00:00'}</td>
                                        <td class="px-6 py-4 font-bold">${row.horasTotaisTrabalhadas || '00:00'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                absenteismoElements.tableContainer.innerHTML = tableHTML;
            }

            // --- Movimenta√ß√µes Empilhadeira Functions ---
            async function handleMovimentacoesFile(file) {
                 if (!file) return;
                showFileInfo(movimentacoesElements, file);
                movimentacoesElements.loader.classList.remove('hidden');

                try {
                    const data = await parseExcelOrCsv(file);
                    movimentacoesData = processMovimentacoesData(data); // Store processed data (already UTC dates)
                    console.log("‚úÖ Movimenta√ß√µes processadas:", movimentacoesData.length, "registros");
                    
                    // *** MODIFICADO: Salvar apenas info resumida no localStorage ***
                    try {
                        const dataInfo = {
                            count: movimentacoesData.length,
                            lastUpdate: new Date().toISOString(),
                            hasData: movimentacoesData.length > 0
                        };
                        localStorage.setItem('movimentacoesDataInfo', JSON.stringify(dataInfo));
                        console.log(`üíæ Info de movimenta√ß√µes salva no localStorage: ${movimentacoesData.length} registros`);
                    } catch (storageError) {
                        console.warn('‚ö†Ô∏è N√£o foi poss√≠vel salvar no localStorage:', storageError.message);
                    }
                    console.log("üíæ Dados de movimenta√ß√µes salvos no localStorage");
                    
                    // *** POPULATE OPERATOR FILTERS ***
                    populateOperatorCheckboxes();
                    populateQuickFilter();
                    
                    renderMovimentacoesDashboard(); // Render the monthly tables
                    movimentacoesElements.placeholder.classList.add('hidden');
                     showFeedback(`Arquivo de movimenta√ß√µes carregado. ${movimentacoesData.length} linhas processadas inicialmente.`, "success"); // Adjusted message

                     // Recalculate indicators if expedition data is also present
                     if (expedicaoData.length > 0) {
                        console.log("üîÑ Recalculando indicadores (movimenta√ß√£o + expedi√ß√£o)...");
                        calcularIndicadoresOperacao();
                    }
                     // Dashboard foi removido - c√≥digo limpo
                } catch (error) {
                    console.error("Erro ao processar arquivo de movimenta√ß√µes:", error);
                     showFeedback("Houve um erro ao ler o arquivo de movimenta√ß√µes.", "error");
                     // Clear data on error
                     movimentacoesData = [];
                     if (movimentacoesElements && movimentacoesElements.dashboardContent && movimentacoesElements.placeholder) {
                        movimentacoesElements.dashboardContent.innerHTML = '';
                        movimentacoesElements.placeholder.classList.remove('hidden');
                    }
                     if (operacaoElements && operacaoElements.chartsContainer && operacaoElements.placeholder) {
                        operacaoElements.chartsContainer.classList.add('hidden');
                        operacaoElements.placeholder.classList.remove('hidden');
                    }
                    // Dashboard foi removido - c√≥digo limpo
                } finally {
                    movimentacoesElements.loader.classList.add('hidden');
                }
            }

             function processMovimentacoesData(data) {
                 // Process each row but DO NOT filter here
                 return data.map(row => {
                    const jsDate = excelDateToJSDate(row['Data']); // Get UTC Date object (might be null)

                    // *** CORRE√á√ÉO: Usar diretamente a coluna Q (M√™s) ***
                    let mesNum = row['M√™s'] !== undefined && row['M√™s'] !== null && String(row['M√™s']).trim() !== '' ? parseInt(String(row['M√™s']).trim(), 10) : undefined;
                    if (isNaN(mesNum) || mesNum < 1 || mesNum > 12) {
                        mesNum = undefined; // Invalidate if not 1-12
                    }

                    // Try to get year from 'Data' column, even if date is invalid
                    let yearNum = jsDate?.getUTCFullYear();
                    if (yearNum === undefined) { // If date failed, try other methods
                         if (typeof row['Data'] === 'number' && row['Data'] > 30000) { // Check Excel serial
                             const tempDate = excelDateToJSDate(row['Data']);
                             yearNum = tempDate?.getUTCFullYear();
                         } else if (typeof row['Data'] === 'string') { // Check string for YYYY
                             const match = String(row['Data']).match(/\b(\d{4})\b/);
                             if (match && match[1]) {
                                 const potentialYear = parseInt(match[1], 10);
                                 if (potentialYear > 1900 && potentialYear < 2100) { // Broader sanity check
                                    yearNum = potentialYear;
                                 }
                             }
                         }
                    }

                    // Parse tempo, default to NaN if invalid
                    const tempoParsed = parseFloat(row['Tempo entre movimentos (min)']);
                    
                    // *** CORRE√á√ÉO: Capturar campo Valida√ß√£o ***
                    const validacao = String(row['Valida√ß√£o'] || '').trim().toUpperCase();
                    
                    // *** ADICIONAR: Capturar ID (coluna A) ***
                    const id = row['ID'] !== undefined && row['ID'] !== null ? String(row['ID']).trim() : null;

                    return {
                        id: id, // ID da movimenta√ß√£o (coluna A)
                        ano: yearNum, // May be undefined
                        mes: mesNum, // Usando coluna Q (M√™s) diretamente
                        data: jsDate, // Keep original Date object or null
                        responsavel: String(row['Responsavel'] || '').trim(), // Coluna E (Respons√°vel)
                        tempo: !isNaN(tempoParsed) ? tempoParsed : NaN, // Ensure tempo is number or NaN
                        tipoMovimentacao: String(row['Tipo movimenta√ß√£o'] || '').trim().toUpperCase(),
                        turno: String(row['Turno'] || '').trim().toUpperCase(),
                        validacao: validacao // Novo campo para filtrar VERIFICAR
                        // Keep other original fields if needed by spreading row: ...row
                    };
                });
                // REMOVED THE .filter() CALL HERE
            }


            function renderMovimentacoesDashboard() {
                 // Ensure elements exist
                if (!movimentacoesElements || !movimentacoesElements.dashboardContent) {
                    console.error("Movimentacoes dashboard elements not ready.");
                    return;
                }
                const container = movimentacoesElements.dashboardContent;

                if (movimentacoesData.length === 0) {
                     container.innerHTML = ''; // Clear previous content
                     if (movimentacoesElements.placeholder) {
                        movimentacoesElements.placeholder.classList.remove('hidden');
                     }
                    return;
                }
                 // Hide placeholder if we have data
                 if (movimentacoesElements.placeholder) {
                    movimentacoesElements.placeholder.classList.add('hidden');
                 }


                // Group data by month-year (using coluna Q - M√™s)
                const byMonth = movimentacoesData.reduce((acc, curr) => {
                     // *** CORRE√á√ÉO: Usar 'mes' da coluna Q (M√™s) e 'ano' ***
                     const year = curr.ano;
                     const month = curr.mes; // Diretamente da coluna Q
                     
                     // Only group if year and month are valid numbers
                     if (typeof year === 'number' && typeof month === 'number' && !isNaN(year) && !isNaN(month)) {
                        const monthYear = `${year}-${String(month).padStart(2, '0')}`;
                        if (!acc[monthYear]) acc[monthYear] = [];
                        acc[monthYear].push(curr);
                    } else {
                         // Optional: Track rows skipped due to invalid year/month
                         console.warn("Skipping row in byMonth grouping - invalid year/month:", { responsavel: curr.responsavel, year, month, validacao: curr.validacao });
                    }
                    return acc;
                }, {});

                const sortedMonths = Object.keys(byMonth).sort().reverse(); // Show most recent first

                let html = '<div class="space-y-8">';
                sortedMonths.forEach(monthKey => {
                    const monthData = byMonth[monthKey];
                    const [year, month] = monthKey.split('-');
                    const monthName = new Date(Date.UTC(year, month - 1)).toLocaleString('pt-BR', { month: 'long', year: 'numeric', timeZone: 'UTC' });

                    const baixarData = monthData.filter(d => d.tipoMovimentacao === 'BAIXAR');
                    const levantarData = monthData.filter(d => d.tipoMovimentacao === 'LEVANTAR');

                    const geralAgg = aggregateByOperator(monthData);
                    const baixarAgg = aggregateByOperator(baixarData);
                    const levantarAgg = aggregateByOperator(levantarData);

                    html += `
                        <div class="bg-gray-800 p-4 rounded-lg border border-gray-700">
                            <h3 class="text-xl font-semibold capitalize text-gray-200 mb-4">${monthName}</h3>

                            <div class="border-b border-gray-600 mb-4">
                                <nav class="-mb-px flex space-x-4 overflow-x-auto pb-px" aria-label="Sub-tabs">
                                    <button data-month="${monthKey}" data-target="geral" class="mov-sub-tab mov-sub-tab-${monthKey} active whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">Geral</button>
                                    <button data-month="${monthKey}" data-target="baixar" class="mov-sub-tab mov-sub-tab-${monthKey} whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300">Baixar</button>
                                    <button data-month="${monthKey}" data-target="levantar" class="mov-sub-tab mov-sub-tab-${monthKey} whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300">Levantar</button>
                                </nav>
                            </div>

                            <div>
                                <div id="mov-content-${monthKey}-geral" class="mov-sub-content mov-sub-content-${monthKey}">
                                    ${generateOperatorTableHTML(geralAgg, 'META TEMPO DE MOVIMENTA√á√ÉO')}
                                </div>
                                <div id="mov-content-${monthKey}-baixar" class="mov-sub-content mov-sub-content-${monthKey} hidden">
                                    ${generateOperatorTableHTML(baixarAgg, 'Meta baixar')}
                                </div>
                                <div id="mov-content-${monthKey}-levantar" class="mov-sub-content mov-sub-content-${monthKey} hidden">
                                    ${generateOperatorTableHTML(levantarAgg, 'Meta levantar')}
                                </div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                container.innerHTML = html;
            }

            function aggregateByOperator(data) {
                return data
                    // *** CORRE√á√ÉO: Filtrar linhas com VERIFICAR ***
                    .filter(curr => curr.validacao !== 'VERIFICAR')
                    // *** FILTRAR: Aplicar filtro de operadores salvos ***
                    .filter(curr => {
                        const operatorName = curr.responsavel || 'Desconhecido';
                        // Se nenhum operador selecionado, mostrar todos
                        if (selectedOperators.length === 0) return true;
                        // Mostrar apenas operadores selecionados
                        return selectedOperators.includes(operatorName);
                    })
                    // *** N√ÉO FILTRAR aqui pelo hiddenOperators - s√≥ ocultar nome ***
                    .reduce((acc, curr) => {
                        const key = curr.responsavel || 'Desconhecido'; // Handle potential missing names
                        if (!acc[key]) {
                            acc[key] = { count: 0, totalTime: 0 };
                        }
                        acc[key].count++;
                         if (!isNaN(curr.tempo)) { // Only add if tempo is a valid number
                            acc[key].totalTime += curr.tempo;
                         }
                        return acc;
                    }, {});
            }

            function generateOperatorTableHTML(operatorData, metaKey) {
                const metaConfig = metasPorAtividade[metaKey] || { meta: 0, unidade: '/ Min' };
                const metaTempo = metaConfig.meta; // Target time in minutes
                
                // Debug: Log das metas para verificar se est√£o sendo aplicadas
                console.log(`üéØ DEBUG META ${metaKey}:`, {
                    metaKey: metaKey,
                    metaConfig: metaConfig,
                    metaTempo: metaTempo,
                    metasPorAtividadeKeys: Object.keys(metasPorAtividade)
                });

                if (Object.keys(operatorData).length === 0) {
                    return '<p class="text-center text-gray-400 p-4">Nenhum dado para este filtro.</p>';
                }

                const operatorEntries = Object.entries(operatorData);
                 // Sort by average time (ascending), handle count = 0
                operatorEntries.sort((a, b) => {
                    const avgA = a[1].count > 0 ? a[1].totalTime / a[1].count : Infinity;
                    const avgB = b[1].count > 0 ? b[1].totalTime / b[1].count : Infinity;
                    return avgA - avgB;
                });

                return `
                    <div class="overflow-x-auto relative shadow-md sm:rounded-lg">
                        <table class="w-full text-sm text-left text-gray-400">
                            <thead class="text-xs text-gray-300 uppercase bg-gray-700">
                                <tr>
                                    <th scope="col" class="px-6 py-3">Operador</th>
                                    <th scope="col" class="px-6 py-3">Qtd. Movimentada</th>
                                    <th scope="col" class="px-6 py-3">Tempo M√©dio (min)</th>
                                    <th scope="col" class="px-6 py-3">Meta de Tempo (min)</th>
                                    <th scope="col" class="px-6 py-3">% Atingido</th>
                                </tr>
                            </thead>
                            <tbody>
                            ${operatorEntries.map(([operador, data]) => {
                                 // Handle division by zero if count is 0
                                const tempoMedio = data.count > 0 ? data.totalTime / data.count : 0;
                                // Calculate percentage: (Meta Time / Average Time) * 100
                                const percentual = metaTempo > 0 && tempoMedio > 0 ? (metaTempo / tempoMedio) * 100 : 0;
                                 let corPercentual = 'text-red-400';
                                if (percentual >= 100) { // Met or exceeded time goal (faster or equal)
                                    corPercentual = 'text-green-400';
                                } else if (percentual >= 90) { // Close to goal
                                    corPercentual = 'text-yellow-400';
                                }
                                
                                // *** OCULTAR APENAS O NOME se estiver em hiddenOperators ***
                                const isHidden = hiddenOperators.has(operador);
                                const displayName = isHidden ? '***********' : operador;
                                
                                return `
                                <tr class="bg-gray-800 border-b border-gray-700 hover:bg-gray-600">
                                    <th scope="row" class="px-6 py-4 font-medium ${isHidden ? 'text-gray-500' : 'text-white'} whitespace-nowrap">${displayName}</th>
                                    <td class="px-6 py-4">${data.count}</td>
                                    <td class="px-6 py-4">${tempoMedio > 0 ? tempoMedio.toFixed(2) : '--'}</td>
                                    <td class="px-6 py-4">${metaTempo > 0 ? metaTempo.toFixed(2) : '--'}</td>
                                    <td class="px-6 py-4 font-bold ${corPercentual}">${metaTempo > 0 && tempoMedio > 0 ? percentual.toFixed(2) + '%' : '--'}</td>
                                </tr>
                                `
                            }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }

            // --- Operator Filter Functions ---
            
            // Extract unique operator names from movimentacoesData
            function getUniqueOperators() {
                const operators = new Set();
                movimentacoesData.forEach(item => {
                    const name = item.responsavel || 'Desconhecido';
                    operators.add(name);
                });
                return Array.from(operators).sort();
            }

            // Populate operator checkboxes in Regras tab
            function populateOperatorCheckboxes() {
                if (!regrasElements || !regrasElements.operatorCheckboxes) return;
                
                const operators = getUniqueOperators();
                if (operators.length === 0) {
                    regrasElements.operatorCheckboxes.innerHTML = '<p class="text-sm text-gray-400">Carregue dados de movimenta√ß√£o para ver os operadores dispon√≠veis.</p>';
                    return;
                }

                let html = '';
                operators.forEach(operator => {
                    const isChecked = selectedOperators.length === 0 || selectedOperators.includes(operator);
                    html += `
                        <div class="flex items-center mb-2">
                            <input type="checkbox" id="op-${operator.replace(/\s+/g, '-')}" 
                                   class="operator-checkbox mr-2 h-4 w-4 rounded border-gray-600 bg-gray-700 text-blue-600 focus:ring-blue-500" 
                                   value="${operator}" ${isChecked ? 'checked' : ''}>
                            <label for="op-${operator.replace(/\s+/g, '-')}" class="text-sm text-gray-300">${operator}</label>
                        </div>
                    `;
                });
                regrasElements.operatorCheckboxes.innerHTML = html;
            }

            // Populate quick filter buttons in movimentacoes tab
            function populateQuickFilter() {
                if (!movimentacoesElements || !movimentacoesElements.quickFilter) return;
                
                const operators = getUniqueOperators();
                if (operators.length === 0) {
                    movimentacoesElements.quickFilter.innerHTML = '<p class="text-sm text-gray-400">Carregue dados de movimenta√ß√£o para ver filtros dispon√≠veis.</p>';
                    return;
                }

                // Filter to show only selected operators from saved config
                const visibleOperators = selectedOperators.length > 0 
                    ? operators.filter(op => selectedOperators.includes(op))
                    : operators;

                let html = '<p class="text-xs text-gray-400 w-full mb-2">Clique para ocultar/mostrar operadores:</p>';
                visibleOperators.forEach(operator => {
                    const isHidden = hiddenOperators.has(operator);
                    html += `
                        <button class="operator-filter-btn px-3 py-1 rounded-lg text-sm ${isHidden ? 'bg-gray-600 text-gray-400' : 'bg-blue-600 text-white'}" 
                                data-operator="${operator}">
                            ${operator} ${isHidden ? '(oculto)' : ''}
                        </button>
                    `;
                });
                movimentacoesElements.quickFilter.innerHTML = html;

                // Attach event listeners to quick filter buttons
                document.querySelectorAll('.operator-filter-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const operator = e.target.dataset.operator;
                        if (hiddenOperators.has(operator)) {
                            hiddenOperators.delete(operator);
                        } else {
                            hiddenOperators.add(operator);
                        }
                        renderMovimentacoesDashboard(); // Re-render with new filter
                        populateQuickFilter(); // Update button states
                    });
                });
            }

            // Save operator filter to Firebase
            async function saveOperatorFilter(e) {
                if (e) e.preventDefault();
                if (!isFirebaseInitialized) {
                    showFeedback("Firebase n√£o inicializado. N√£o √© poss√≠vel salvar.", "error");
                    return;
                }

                const collectionPath = getFirestorePath('operator_filter');
                if (!collectionPath) return;

                // Collect selected operators from checkboxes
                const checkboxes = document.querySelectorAll('.operator-checkbox:checked');
                const selected = Array.from(checkboxes).map(cb => cb.value);

                try {
                    // Save as single document with array of operator names
                    await setDoc(doc(db, collectionPath, 'selected_operators'), {
                        operators: selected,
                        updatedAt: new Date()
                    });
                    
                    selectedOperators = selected;
                    hiddenOperators.clear(); // Reset quick filter
                    
                    if (regrasElements.operatorFilterFeedback) {
                        regrasElements.operatorFilterFeedback.innerHTML = `<p class="text-green-400 text-sm">‚úÖ Filtro salvo! ${selected.length} operador(es) selecionado(s).</p>`;
                    }
                    
                    // Update quick filter and re-render dashboard
                    populateQuickFilter();
                    renderMovimentacoesDashboard();
                    
                    setTimeout(() => {
                        if (regrasElements.operatorFilterFeedback) {
                            regrasElements.operatorFilterFeedback.innerHTML = '';
                        }
                    }, 3000);
                    
                } catch (error) {
                    console.error("Error saving operator filter:", error);
                    if (regrasElements.operatorFilterFeedback) {
                        regrasElements.operatorFilterFeedback.innerHTML = `<p class="text-red-400 text-sm">‚ùå Erro ao salvar filtro.</p>`;
                    }
                }
            }

            // Load operator filter from Firebase
            async function loadOperatorFilter() {
                if (!isFirebaseInitialized) return;

                const collectionPath = getFirestorePath('operator_filter');
                if (!collectionPath) return;

                try {
                    const docRef = doc(db, collectionPath, 'selected_operators');
                    const docSnap = await getDocs(query(collection(db, collectionPath)));
                    
                    if (!docSnap.empty) {
                        const data = docSnap.docs[0].data();
                        selectedOperators = data.operators || [];
                        console.log(`‚úÖ Filtro de operadores carregado: ${selectedOperators.length} selecionados`);
                    } else {
                        selectedOperators = []; // Empty means show all
                        console.log('‚ÑπÔ∏è Nenhum filtro de operadores salvo. Mostrando todos.');
                    }
                } catch (error) {
                    console.error("Error loading operator filter:", error);
                    selectedOperators = [];
                }
            }


            // --- Regras Functions ---
            async function saveRegraDowntime(e) {
                e.preventDefault();
                 if (!isFirebaseInitialized) {
                    showFeedback("Firebase n√£o inicializado. N√£o √© poss√≠vel salvar.", "error");
                    return;
                }
                 const collectionPath = getFirestorePath('regras_downtime');
                 if (!collectionPath) {
                    // Feedback already shown by getFirestorePath
                    return;
                }

                const motivo = regrasElements.motivoInput.value.trim();
                const tempo = regrasElements.tempoInput.value; // Should be in HH:MM format

                // Valida√ß√£o melhorada para aceitar valores acima de 24 horas
                if (!motivo || !tempo || !/^\d+:[0-5]\d$/.test(tempo)) { // Permite qualquer quantidade de horas
                    regrasElements.downtimeFeedback.innerHTML = `<p class="text-orange-400 text-sm">Preencha o motivo e o tempo no formato HH:MM (ex: 30:15 para 30h e 15min).</p>`;
                    return;
                }

                try {
                    await addDoc(collection(db, collectionPath), { motivo, tempo });
                    regrasElements.downtimeFeedback.innerHTML = `<p class="text-green-400 text-sm">Regra salva com sucesso!</p>`;
                    regrasElements.downtimeForm.reset();
                } catch (error) {
                    console.error("Error saving downtime rule:", error);
                    regrasElements.downtimeFeedback.innerHTML = `<p class="text-red-400 text-sm">Erro ao salvar a regra.</p>`;
                }
                setTimeout(() => {
                     if (regrasElements.downtimeFeedback) regrasElements.downtimeFeedback.innerHTML = '';
                 }, 3000);
            }

            function listenForDowntimeUpdates() {
                 if (!isFirebaseInitialized) return;
                 const collectionPath = getFirestorePath('regras_downtime');
                 if (!collectionPath) return;

                if (unsubDowntime) unsubDowntime(); // Unsubscribe from previous listener

                const q = query(collection(db, collectionPath));
                unsubDowntime = onSnapshot(q, (querySnapshot) => {
                    downtimeRules = [];
                    querySnapshot.forEach((doc) => downtimeRules.push({ id: doc.id, ...doc.data() }));
                     downtimeRules.sort((a,b) => (a.motivo || '').localeCompare(b.motivo || '')); // Sort alphabetically
                    renderDowntimeTable(downtimeRules);
                     
                     // *** ADICIONADO: Recalcular indicadores se as regras mudarem ***
                     if (expedicaoData.length > 0 && movimentacoesData.length > 0) {
                        calcularIndicadoresOperacao();
                    }
                     
                     // Dashboard removido - c√≥digo limpo
                }, (error) => {
                     console.error("Error listening for downtime rule updates:", error);
                     showFeedback("Erro ao carregar regras de downtime.", "error");
                });
            }

            function renderDowntimeTable(regras) {
                 if (!regrasElements || !regrasElements.downtimeListContainer) return;
                const container = regrasElements.downtimeListContainer;
                if (regras.length === 0) {
                    container.innerHTML = `<p class="text-center text-gray-400">Nenhuma regra de downtime cadastrada.</p>`;
                    return;
                }

                container.innerHTML = `
                     <div class="overflow-x-auto relative shadow-md sm:rounded-lg">
                         <table class="w-full text-sm text-left text-gray-400">
                             <thead class="text-xs text-gray-300 uppercase bg-gray-700">
                                <tr>
                                    <th scope="col" class="px-6 py-3">Motivo</th>
                                    <th scope="col" class="px-6 py-3">Tempo Mensal (HH:MM)</th>
                                    <th scope="col" class="px-6 py-3">A√ß√£o</th>
                                </tr>
                             </thead>
                             <tbody>
                                ${regras.map(regra => `
                                    <tr class="bg-gray-800 border-b border-gray-700">
                                        <td class="px-6 py-4">${regra.motivo || 'N/A'}</td>
                                        <td class="px-6 py-4">${regra.tempo || '--:--'}</td>
                                        <td class="px-6 py-4">
                                            <button data-id="${regra.id}" class="delete-downtime-rule-btn text-red-500 hover:text-red-700 text-xs">Remover</button>
                                        </td>
                                    </tr>
                                `).join('')}
                             </tbody>
                         </table>
                     </div>
                `;
            }

            async function deleteRule(e) {
                 if (!isFirebaseInitialized) {
                    showFeedback("Firebase n√£o inicializado.", "error");
                    return;
                 }
                let docId = null;
                let collectionName = null;
                 let actionType = null; // To differentiate between rule deletion and launched downtime deletion

                 // Check if deleting a downtime RULE
                 if (e.target.classList.contains('delete-downtime-rule-btn')) {
                    docId = e.target.dataset.id;
                    collectionName = 'regras_downtime';
                    actionType = 'rule';
                }
                // Check if deleting a meta RULE
                else if (e.target.classList.contains('delete-meta-btn')) {
                    docId = e.target.dataset.id;
                     collectionName = 'regras_meta';
                     actionType = 'rule';
                }
                // Check if removing a LAUNCHED downtime instance
                else if (e.target.classList.contains('remove-downtime-item')) {
                     docId = e.target.dataset.downtimeId; // Use the specific ID for the launched instance
                     collectionName = 'downtimes_lancados';
                     actionType = 'launched';
                     const operatorId = e.target.dataset.operator; // Needed to update local state

                      if (!docId || !operatorId) {
                         console.error("Missing ID or operator for launched downtime deletion");
                         showFeedback("Erro ao tentar remover downtime lan√ßado.", "error");
                        return;
                     }

                     const collectionPath = getFirestorePath(collectionName);
                     if (!collectionPath) return;

                      try {
                        await deleteDoc(doc(db, collectionPath, docId));
                        showFeedback("Downtime lan√ßado removido.", "success");

                         // Dashboard removido - l√≥gica de update local removida

                     } catch (error) {
                        console.error(`Error deleting launched downtime (${docId}):`, error);
                        showFeedback("Erro ao remover o downtime lan√ßado.", "error");
                     }
                    return; // Stop further processing for this specific case
                }


                 // Process deletion for RULES (downtime or meta)
                 if (actionType === 'rule' && docId && collectionName) {
                     const collectionPath = getFirestorePath(collectionName);
                     if (!collectionPath) {
                        showFeedback("Erro: Caminho do banco de dados inv√°lido para regras.", "error");
                        return;
                    }
                    try {
                        await deleteDoc(doc(db, collectionPath, docId));
                         showFeedback("Regra removida com sucesso.", "success");
                         // Firestore listener will automatically update the table for rules
                    } catch (error) {
                        console.error(`Error deleting ${collectionName} rule (${docId}):`, error);
                         showFeedback("Erro ao remover a regra.", "error");
                    }
                }
            }


            async function saveMeta(e) {
                e.preventDefault();
                if (!isFirebaseInitialized) {
                    showFeedback("Firebase n√£o inicializado. N√£o √© poss√≠vel salvar.", "error");
                    return;
                }
                 const collectionPath = getFirestorePath('regras_meta');
                 if (!collectionPath) {
                    // Feedback already shown by getFirestorePath
                    return;
                }

                const atividade = regrasElements.metaAtividadeInput.value.trim();
                const metaValue = regrasElements.metaValorInput.value; // Get value as string first
                const unidade = regrasElements.metaUnidadeInput.value;

                // Validate input
                if (!atividade) {
                    regrasElements.metaFeedback.innerHTML = `<p class="text-orange-400 text-sm">Por favor, insira o nome da atividade.</p>`;
                    return;
                }
                const meta = Number(metaValue); // Convert to number
                if (metaValue === '' || isNaN(meta) || meta < 0) {
                     regrasElements.metaFeedback.innerHTML = `<p class="text-orange-400 text-sm">Por favor, insira um valor num√©rico n√£o negativo para a meta.</p>`;
                    return;
                }


                try {
                     // Check if a meta with this activity name already exists (case-sensitive check)
                    const q = query(collection(db, collectionPath), where("atividade", "==", atividade));
                    const querySnapshot = await getDocs(q);

                     if (!querySnapshot.empty) {
                        // Meta already exists. Provide feedback.
                        regrasElements.metaFeedback.innerHTML = `<p class="text-orange-400 text-sm">J√° existe uma meta para "${atividade}". Remova a antiga primeiro se quiser criar uma nova ou editar.</p>`;
                        // Optional: Implement update logic here if desired
                        // const existingDoc = querySnapshot.docs[0];
                        // await setDoc(doc(db, collectionPath, existingDoc.id), { atividade, meta, unidade }); // Example update
                    } else {
                         // Add new meta
                        await addDoc(collection(db, collectionPath), { atividade, meta, unidade });
                        regrasElements.metaFeedback.innerHTML = `<p class="text-green-400 text-sm">Meta salva com sucesso!</p>`;
                        regrasElements.metaForm.reset();
                     }
                } catch (error) {
                    console.error("Error saving meta:", error);
                    regrasElements.metaFeedback.innerHTML = `<p class="text-red-400 text-sm">Erro ao salvar a meta.</p>`;
                }
                 // Clear feedback message after a delay
                setTimeout(() => {
                    if (regrasElements.metaFeedback) regrasElements.metaFeedback.innerHTML = '';
                 }, 3000);
            }

            function listenForMetasUpdates() {
                 if (!isFirebaseInitialized) return;
                 const collectionPath = getFirestorePath('regras_meta');
                 if (!collectionPath) return;

                if (unsubMetas) unsubMetas(); // Unsubscribe from previous listener

                const q = query(collection(db, collectionPath));
                unsubMetas = onSnapshot(q, (querySnapshot) => {
                    const metas = [];
                    metasPorAtividade = {}; // Reset and repopulate the map
                    querySnapshot.forEach((doc) => {
                        const data = doc.data();
                        // Basic validation on fetched data
                        if (data.atividade && typeof data.meta === 'number' && data.unidade) {
                            metas.push({ id: doc.id, ...data });
                            metasPorAtividade[data.atividade] = { meta: data.meta, unidade: data.unidade };
                        } else {
                            console.warn("Invalid meta data fetched from Firestore:", doc.id, data);
                        }
                    });
                     metas.sort((a,b) => (a.atividade || '').localeCompare(b.atividade || '')); // Sort alphabetically
                    renderMetasTable(metas);
                    // Refresh related views that depend on metas
                    if (movimentacoesData.length > 0) {
                        renderMovimentacoesDashboard();
                    }
                     // Dashboard removido - c√≥digo limpo
                }, (error) => {
                    console.error("Error listening for meta rule updates:", error);
                     showFeedback("Erro ao carregar metas.", "error");
                });
            }

            function renderMetasTable(metas) {
                 if (!regrasElements || !regrasElements.metaListContainer) return;
                const container = regrasElements.metaListContainer;
                if (metas.length === 0) {
                    container.innerHTML = `<p class="text-center text-gray-400">Nenhuma meta cadastrada.</p>`;
                    return;
                }

                container.innerHTML = `
                     <div class="overflow-x-auto relative shadow-md sm:rounded-lg">
                         <table class="w-full text-sm text-left text-gray-400">
                             <thead class="text-xs text-gray-300 uppercase bg-gray-700">
                                <tr>
                                    <th scope="col" class="px-6 py-3">Atividade</th>
                                    <th scope="col" class="px-6 py-3">Meta</th>
                                    <th scope="col" class="px-6 py-3">Unidade</th>
                                    <th scope="col" class="px-6 py-3">A√ß√£o</th>
                                </tr>
                             </thead>
                             <tbody>
                                ${metas.map(meta => `
                                    <tr class="bg-gray-800 border-b border-gray-700">
                                        <td class="px-6 py-4">${meta.atividade || 'N/A'}</td>
                                        <td class="px-6 py-4">${meta.meta}</td>
                                        <td class="px-6 py-4">${meta.unidade || 'N/A'}</td>
                                        <td class="px-6 py-4">
                                            <button data-id="${meta.id}" class="delete-meta-btn text-red-500 hover:text-red-700 text-xs">Remover</button>
                                        </td>
                                    </tr>
                                `).join('')}
                             </tbody>
                         </table>
                     </div>
                `;
            }


            // --- Generic Functions ---
            function parseExcelOrCsv(file) {
                 // Uses SheetJS (xlsx library) loaded globally
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = new Uint8Array(e.target.result);
                             // Attempt to parse dates, but handle potential errors or inconsistencies
                            const workbook = XLSX.read(data, { type: 'array', cellDates: true, dateNF:'dd/mm/yyyy' });
                            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                            // header: 1 ensures the first row is treated as headers
                            const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                            if (json.length < 2) { // Need at least header + 1 data row
                                resolve([]); // Return empty if no data
                                return;
                            }

                             // Assume first row is headers
                            const headers = json[0].map(h => String(h || '').trim());
                            const dataRows = json.slice(1);

                            const formattedJson = dataRows.map(rowArray => {
                                let rowObject = {};
                                headers.forEach((header, index) => {
                                     // Ensure index is within bounds of the current rowArray
                                    if(index < rowArray.length){
                                        rowObject[header] = rowArray[index];
                                    } else {
                                        rowObject[header] = undefined; // Or null, or '', depending on desired handling
                                    }
                                });
                                return rowObject;
                            });

                            resolve(formattedJson);
                        } catch (err) {
                            console.error("Error parsing file with SheetJS:", err);
                            reject(new Error("Falha ao processar o arquivo. Verifique o formato."));
                        }
                    };
                    reader.onerror = (err) => {
                         console.error("FileReader error:", err);
                         reject(new Error("Erro ao ler o arquivo selecionado."));
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            function excelDateToJSDate(serialOrDate) {
                 if (serialOrDate === null || serialOrDate === undefined || serialOrDate === '') return null;

                // 1. Check if it's already a valid JS Date object
                if (serialOrDate instanceof Date && !isNaN(serialOrDate)) {
                    // Create a new Date object representing the same date in UTC
                    return new Date(Date.UTC(serialOrDate.getFullYear(), serialOrDate.getMonth(), serialOrDate.getDate()));
                }

                // 2. Check if it's an Excel serial number (number type)
                if (typeof serialOrDate === 'number' && isFinite(serialOrDate)) {
                     // Check if it's potentially a valid Excel date range (avoids very small/large numbers)
                     if (serialOrDate > 0 && serialOrDate < 2958466) { // Approx year 1900 to 9999
                        const utc_days = Math.floor(serialOrDate - 25569);
                        const utc_value = utc_days * 86400; // Seconds in a day
                        const date_info = new Date(utc_value * 1000); // Milliseconds from epoch

                         // Validate the resulting date parts
                         const year = date_info.getUTCFullYear();
                         const month = date_info.getUTCMonth();
                         const day = date_info.getUTCDate();

                         // Basic sanity check for the parsed date
                         if (year > 1899 && year < 3000) {
                              // Create date in UTC
                            return new Date(Date.UTC(year, month, day));
                         } else {
                              console.warn("Parsed Excel date resulted in an unlikely year:", year, "from serial:", serialOrDate);
                              return null; // Return null if the year seems wrong
                         }
                    } else {
                        // console.warn("Number is outside the expected Excel date serial range:", serialOrDate);
                         return null; // Number likely isn't an Excel date
                     }
                }

                // 3. Check if it's a string and try parsing common formats
                if (typeof serialOrDate === 'string') {
                    const trimmedDate = serialOrDate.trim();
                    let dateObj = null;

                    // Try ISO format (YYYY-MM-DD) or (YYYY/MM/DD) potentially with time
                    if (/^\d{4}[-\/]\d{1,2}[-\/]\d{1,2}/.test(trimmedDate)) {
                         // Attempt to create a date object. If time is present, it might affect the UTC date.
                         // It's safer to reconstruct just the date part in UTC.
                         try {
                             const parts = trimmedDate.split(/[-\/ T]/); // Split by '-', '/', ' ', or 'T'
                             if (parts.length >= 3) {
                                 const year = parseInt(parts[0], 10);
                                 const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed
                                 const day = parseInt(parts[2], 10);
                                 if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
                                     dateObj = new Date(Date.UTC(year, month, day));
                                 }
                             }
                         } catch (e) { /* ignore parse error */ }
                    }
                    // Try DD/MM/YYYY or DD-MM-YYYY potentially with time
                    else if (/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})/.test(trimmedDate)) {
                        const parts = trimmedDate.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})/);
                        if (parts) {
                            // parts[1] = day, parts[2] = month, parts[3] = year
                            const year = parseInt(parts[3], 10);
                            const month = parseInt(parts[2], 10) - 1; // Month is 0-indexed
                            const day = parseInt(parts[1], 10);
                            if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
                                 dateObj = new Date(Date.UTC(year, month, day));
                            }
                        }
                    }
                    // Add more formats here if needed

                    // Validate the parsed date from string
                    if (dateObj instanceof Date && !isNaN(dateObj)) {
                        return dateObj; // Return the UTC date object
                    }
                }

                // If none of the above worked, log a warning and return null
                 // console.warn("Could not parse date:", serialOrDate, typeof serialOrDate);
                return null;
            }

            // === FUN√á√ÉO PARA LIMPAR DADOS ANTERIORES (SOBRESCREVER) ===
            function limparDadosAbsenteismoMensal(anoMes, monthlyAgg) {
                console.log(`üóëÔ∏è Limpando dados anteriores do m√™s ${anoMes} para sobrescrever...`);
                
                if (monthlyAgg[anoMes]) {
                    // Limpa TODOS os dados relacionados ao absente√≠smo/horas para permitir nova importa√ß√£o
                    monthlyAgg[anoMes].horasAbsenteismoPickingMin = 0;
                    monthlyAgg[anoMes].horasAbsenteismoExpedicaoMin = 0;
                    monthlyAgg[anoMes].horasAbsenteismoOpEmpMin = 0;
                    
                    // *** CORRIGIR: LIMPAR TAMB√âM HORAS PREVISTAS E NORMAIS ***
                    monthlyAgg[anoMes].horasPrevistasPickingMin = 0;
                    monthlyAgg[anoMes].horasPrevistasExpedicaoMin = 0;
                    monthlyAgg[anoMes].horasPrevistasOpEmpMin = 0;
                    monthlyAgg[anoMes].horasNormaisPickingMin = 0;
                    monthlyAgg[anoMes].horasNormaisExpedicaoMin = 0;
                    monthlyAgg[anoMes].horasNormaisOpEmpMin = 0;
                    
                    // Limpar conjuntos de dias
                    monthlyAgg[anoMes].diasUteisPicking = new Set();
                    monthlyAgg[anoMes].diasUteisExpedicao = new Set();
                    monthlyAgg[anoMes].diasUteisOpEmp = new Set();
                    
                    monthlyAgg[anoMes].dadosProcessados = new Set();
                    console.log(`‚úÖ Todos os dados de horas/absente√≠smo limpos para ${anoMes}`);
                }
            }

            // === FUN√á√ÉO PARA CALCULAR DIAS √öTEIS ===
            function calcularDiasUteis(ano, mes, diaFinal = null) {
                const hoje = new Date();
                const dataFinal = diaFinal ? new Date(ano, mes - 1, diaFinal) : hoje;
                const dataInicio = new Date(ano, mes - 1, 1);
                
                // Se o m√™s/ano √© futuro, retorna 0
                if (dataInicio > hoje) {
                    return 0;
                }
                
                // Ajusta data final para n√£o passar de hoje
                if (dataFinal > hoje) {
                    dataFinal.setTime(hoje.getTime());
                }
                
                // Lista de feriados brasileiros (pode ser expandida)
                const feriados = [
                    `${ano}-01-01`, // Ano Novo
                    `${ano}-04-21`, // Tiradentes
                    `${ano}-09-07`, // Independ√™ncia
                    `${ano}-10-12`, // Nossa Senhora Aparecida
                    `${ano}-11-02`, // Finados
                    `${ano}-11-15`, // Proclama√ß√£o da Rep√∫blica
                    `${ano}-12-25`, // Natal
                    // Adicione outros feriados conforme necess√°rio
                ];
                
                let diasUteis = 0;
                const dataAtual = new Date(dataInicio);
                
                while (dataAtual <= dataFinal) {
                    const diaSemana = dataAtual.getDay(); // 0 = domingo, 6 = s√°bado
                    const dataStr = dataAtual.toISOString().split('T')[0];
                    
                    // Conta apenas se n√£o for fim de semana e n√£o for feriado
                    if (diaSemana !== 0 && diaSemana !== 6 && !feriados.includes(dataStr)) {
                        diasUteis++;
                    }
                    
                    dataAtual.setDate(dataAtual.getDate() + 1);
                }
                
                console.log(`üìÖ Dias √∫teis calculados para ${mes}/${ano}: ${diasUteis} dias (at√© ${dataFinal.toLocaleDateString()})`);
                return diasUteis;
            }

            // === FUN√á√ÉO PARA CALCULAR DIAS √öTEIS ENTRE DUAS DATAS ESPEC√çFICAS ===
            function calcularDiasUteisEntreDatas(dataInicial, dataFinal) {
                if (!dataInicial || !dataFinal) return 0;
                
                const ano = dataInicial.getFullYear();
                
                // Lista de feriados brasileiros (pode ser expandida)
                const feriados = [
                    `${ano}-01-01`, // Ano Novo
                    `${ano}-04-21`, // Tiradentes
                    `${ano}-09-07`, // Independ√™ncia
                    `${ano}-10-12`, // Nossa Senhora Aparecida
                    `${ano}-11-02`, // Finados
                    `${ano}-11-15`, // Proclama√ß√£o da Rep√∫blica
                    `${ano}-12-25`, // Natal
                    // Adicione outros feriados conforme necess√°rio
                ];
                
                let diasUteis = 0;
                const dataAtual = new Date(dataInicial);
                
                while (dataAtual <= dataFinal) {
                    const diaSemana = dataAtual.getDay(); // 0 = domingo, 6 = s√°bado
                    const dataStr = dataAtual.toISOString().split('T')[0];
                    
                    // Conta apenas se n√£o for fim de semana e n√£o for feriado
                    if (diaSemana !== 0 && diaSemana !== 6 && !feriados.includes(dataStr)) {
                        diasUteis++;
                    }
                    
                    dataAtual.setDate(dataAtual.getDate() + 1);
                }
                
                console.log(`üìÖ Dias √∫teis entre ${dataInicial.toLocaleDateString()} e ${dataFinal.toLocaleDateString()}: ${diasUteis} dias`);
                return diasUteis;
            }


            function timeStringToMinutes(timeStr) {
                 // *** CORRE√á√ÉO: Trata fra√ß√µes decimais do Excel (formato de tempo) ***
                if (!timeStr && timeStr !== 0) {
                    return 0;
                }
                
                // Se √© um n√∫mero (fra√ß√£o decimal do Excel)
                if (typeof timeStr === 'number') {
                    // Excel representa tempo como fra√ß√£o de 1 dia (1 = 24 horas)
                    const totalMinutes = timeStr * 1440; // 1440 minutos em 1 dia (mant√©m decimais)
                    return totalMinutes;
                }
                
                // Converte para string e limpa
                const cleanStr = String(timeStr).trim();
                
                // Verifica se √© uma string que representa n√∫mero decimal
                if (!isNaN(parseFloat(cleanStr))) {
                    const decimal = parseFloat(cleanStr);
                    if (decimal < 1 && decimal > 0) {
                        // √â uma fra√ß√£o de dia (formato Excel)
                        const totalMinutes = decimal * 1440;
                        return totalMinutes;
                    }
                }
                
                // Formato HH:MM:SS ou HH:MM
                const parts = cleanStr.split(':');
                if (parts.length >= 2) {
                     const hours = parseInt(parts[0], 10);
                     const minutes = parseInt(parts[1], 10);
                     let seconds = 0;
                     
                     // Se tem segundos (HH:MM:SS)
                     if (parts.length >= 3) {
                         seconds = parseInt(parts[2], 10);
                     }
                     
                     // Check if all parts are valid numbers
                     if (!isNaN(hours) && !isNaN(minutes) && hours >= 0 && minutes >= 0 && minutes < 60) {
                         // Converte tudo para minutos decimais (incluindo segundos)
                         const result = (hours * 60) + minutes + (seconds / 60);
                         return result;
                     }
                }

                return 0;
            }

            function minutesToHoursAndMinutes(totalMinutes) {
                if (totalMinutes === null || totalMinutes === undefined || isNaN(totalMinutes) || totalMinutes < 0) return '00:00';
                const hours = Math.floor(totalMinutes / 60);
                const minutes = Math.round(totalMinutes % 60);
                 // Handle potential rounding to 60 minutes
                 if (minutes === 60) {
                     return `${String(hours + 1).padStart(2, '0')}:00`;
                 }
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            }


            // --- Dashboard Functions ---

            // Fun√ß√£o buscarDadosDashboard removida - Dashboard exclu√≠do


            // Fun√ß√£o renderDashboard removida - Dashboard exclu√≠do


            // Fun√ß√µes openDowntimeModal e handleDowntimeSubmit removidas - Dashboard exclu√≠do


            // --- Initial Setup ---
             // Select elements safely after DOM is loaded
            tabs = {
                importacao: { btn: document.getElementById('tab-btn-importacao'), content: document.getElementById('tab-content-importacao') },
                operacao: { btn: document.getElementById('tab-btn-operacao'), content: document.getElementById('tab-content-operacao') },
                absenteismo: { btn: document.getElementById('tab-btn-absenteismo'), content: document.getElementById('tab-content-absenteismo') },
                movimentacoes: { btn: document.getElementById('tab-btn-movimentacoes'), content: document.getElementById('tab-content-movimentacoes') },
                regras: { btn: document.getElementById('tab-btn-regras'), content: document.getElementById('tab-content-regras') },
            };

            expedicaoElements = {
                dropZone: document.getElementById('expedicao-drop-zone'),
                fileInput: document.getElementById('expedicao-file-input'),
                fileLabel: document.getElementById('expedicao-file-label'),
                fileInfo: document.getElementById('expedicao-file-info'),
                fileInfoP: document.querySelector('#expedicao-file-info p'),
                removeBtn: document.getElementById('expedicao-remove-file-btn'),
                loader: document.getElementById('expedicao-loader'),
            };

            absenteismoElements = {
                dropZone: document.getElementById('absenteismo-drop-zone'),
                fileInput: document.getElementById('absenteismo-file-input'),
                fileLabel: document.getElementById('absenteismo-file-label'),
                filesList: document.getElementById('absenteismo-files-list'),
                filesContainer: document.getElementById('absenteismo-files-container'),
                removeAllBtn: document.getElementById('absenteismo-remove-all-btn'),
                processBtn: document.getElementById('process-absenteismo-files-btn'),
                loader: document.getElementById('absenteismo-loader'),
                previewContainer: document.getElementById('absenteismo-preview-container'),
                previewList: document.getElementById('absenteismo-preview-list'),
                saveBtn: document.getElementById('save-absenteismo-btn'),
                feedback: document.getElementById('absenteismo-feedback'),
                dateFilter: document.getElementById('absenteismo-date-filter'),
                tableContainer: document.getElementById('absenteismo-table-container'),
                placeholder: document.getElementById('absenteismo-placeholder'),
            };

            movimentacoesElements = {
                dropZone: document.getElementById('empilhadeira-drop-zone'),
                fileInput: document.getElementById('empilhadeira-file-input'),
                fileLabel: document.getElementById('empilhadeira-file-label'),
                fileInfo: document.getElementById('empilhadeira-file-info'),
                fileInfoP: document.querySelector('#empilhadeira-file-info p'),
                removeBtn: document.getElementById('empilhadeira-remove-file-btn'),
                loader: document.getElementById('empilhadeira-loader'),
                dashboardContent: document.getElementById('movimentacoes-dashboard-content'),
                placeholder: document.getElementById('movimentacoes-placeholder'),
                quickFilter: document.getElementById('operator-quick-filter'), // Quick filter for hiding/showing operators
            };

            operacaoElements = {
                chartsContainer: document.getElementById('operacao-charts-container'),
                placeholder: document.getElementById('operacao-placeholder'),
                turnoFilter: document.getElementById('mov-turno-filter') // ADICIONADO
            };



            regrasElements = {
                downtimeForm: document.getElementById('form-regra-downtime'),
                motivoInput: document.getElementById('motivo-downtime'),
                tempoInput: document.getElementById('tempo-downtime'),
                downtimeFeedback: document.getElementById('downtime-feedback'),
                downtimeListContainer: document.getElementById('regras-downtime-list-container'),
                metaForm: document.getElementById('form-meta'),
                metaAtividadeInput: document.getElementById('meta-atividade-nome'),
                metaValorInput: document.getElementById('meta-atividade-valor'),
                metaUnidadeInput: document.getElementById('meta-atividade-unidade'),
                metaFeedback: document.getElementById('meta-feedback'),
                metaListContainer: document.getElementById('regras-meta-list-container'),
                // Operator filter elements
                operatorCheckboxes: document.getElementById('operator-checkboxes'),
                selectAllOperators: document.getElementById('select-all-operators'),
                saveOperatorFilterBtn: document.getElementById('save-operator-filter-btn'),
                operatorFilterFeedback: document.getElementById('operator-filter-feedback'),
            };

            // Setup Tab Switching - Ensure elements exist
            Object.keys(tabs).forEach(tabKey => {
                if (tabs[tabKey] && tabs[tabKey].btn) {
                    tabs[tabKey].btn.addEventListener('click', () => switchTab(tabKey));
                } else {
                     console.warn(`Button for tab "${tabKey}" not found.`);
                }
            });

            // Setup Sub-Tab Switching for Operations
            function setupSubTabs() {
                const subTabButtons = document.querySelectorAll('.sub-tab-btn');
                const subTabContents = document.querySelectorAll('.sub-tab-content');

                subTabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const targetId = button.getAttribute('data-target');
                        
                        // Remove active class from all sub-tab buttons
                        subTabButtons.forEach(btn => btn.classList.remove('active'));
                        
                        // Add active class to clicked button
                        button.classList.add('active');
                        
                        // Hide all sub-tab contents
                        subTabContents.forEach(content => content.classList.add('hidden'));
                        
                        // Show target sub-tab content
                        const targetContent = document.getElementById(targetId);
                        if (targetContent) {
                            targetContent.classList.remove('hidden');
                        }
                    });
                });
            }

            // Initialize sub-tabs
            setupSubTabs();

            // Setup File Inputs - Checks are inside setupFileInput

            setupFileInput(expedicaoElements, handleExpedicaoFile);
            setupMultipleFileInput(absenteismoElements); // Fun√ß√£o espec√≠fica para m√∫ltiplos arquivos
            setupFileInput(movimentacoesElements, handleMovimentacoesFile);


            // Setup Button Clicks & Form Submits - Add checks for element existence
             if(absenteismoElements.saveBtn) absenteismoElements.saveBtn.addEventListener('click', saveAbsenteismoToFirestore);
             if(absenteismoElements.dateFilter) absenteismoElements.dateFilter.addEventListener('change', () => loadAbsenteismoHistory());
             if(regrasElements.downtimeForm) regrasElements.downtimeForm.addEventListener('submit', saveRegraDowntime);
             if(regrasElements.metaForm) regrasElements.metaForm.addEventListener('submit', saveMeta);
             if(regrasElements.downtimeListContainer) regrasElements.downtimeListContainer.addEventListener('click', deleteRule);
             if(regrasElements.metaListContainer) regrasElements.metaListContainer.addEventListener('click', deleteRule);
             // Dashboard removido - event listener removido
             if(operacaoElements.turnoFilter) operacaoElements.turnoFilter.addEventListener('change', calcularIndicadoresOperacao); // ADICIONADO
             
             // Operator filter event listeners
             if(regrasElements.saveOperatorFilterBtn) regrasElements.saveOperatorFilterBtn.addEventListener('click', saveOperatorFilter);
             if(regrasElements.selectAllOperators) {
                regrasElements.selectAllOperators.addEventListener('change', (e) => {
                    const checkboxes = document.querySelectorAll('.operator-checkbox');
                    checkboxes.forEach(cb => cb.checked = e.target.checked);
                });
             }

            // Movimentacoes Sub-tab switching - Check container exists
             if(movimentacoesElements.dashboardContent) {
                movimentacoesElements.dashboardContent.addEventListener('click', (e) => {
                    if (e.target.classList.contains('mov-sub-tab')) {
                        const month = e.target.dataset.month;
                        const target = e.target.dataset.target;
                        if (!month || !target) return; // Exit if data attributes are missing

                        document.querySelectorAll(`.mov-sub-tab-${month}`).forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');

                        document.querySelectorAll(`.mov-sub-content-${month}`).forEach(content => content.classList.add('hidden'));
                        const targetContent = document.getElementById(`mov-content-${month}-${target}`);
                         if(targetContent) targetContent.classList.remove('hidden');
                    }
                });
            }

            // Dashboard removido - event listeners removidos
             // Dashboard removido - event listener removido


            // Set default dates if elements exist
            try {
                const today = new Date();
                // Format YYYY-MM-DD, considering timezone offset
                const offset = today.getTimezoneOffset();
                const todayLocal = new Date(today.getTime() - (offset*60*1000));
                const todayString = todayLocal.toISOString().split('T')[0];

                if(absenteismoElements.dateFilter) absenteismoElements.dateFilter.value = todayString;
                // Dashboard removido - c√≥digo limpo
            } catch (e) {
                console.error("Error setting default dates:", e);
                 // Fallback if date setting fails
                 if(absenteismoElements.dateFilter) absenteismoElements.dateFilter.value = '';
                 // Dashboard removido - c√≥digo limpo
            }

            // --- Fun√ß√µes de Gerenciamento de Dados de Absente√≠smo ---
            
            async function deleteAbsenteismoByPeriod(collectionPath, periodo) {
                try {
                    const q = query(collection(db, collectionPath));
                    const querySnapshot = await getDocs(q);
                    const docsToDelete = [];
                    
                    querySnapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.mesAno === periodo) {
                            docsToDelete.push(doc.id);
                        }
                    });
                    
                    console.log(`üóëÔ∏è Excluindo ${docsToDelete.length} registros do per√≠odo ${periodo}`);
                    
                    for (const docId of docsToDelete) {
                        await deleteDoc(doc(db, collectionPath, docId));
                    }
                    
                    return docsToDelete.length;
                } catch (error) {
                    console.error(`Erro ao deletar dados do per√≠odo ${periodo}:`, error);
                    throw error;
                }
            }

            async function clearAllAbsenteismoData() {
                if (!confirm('‚ö†Ô∏è ATEN√á√ÉO: Isso ir√° excluir TODOS os dados de absente√≠smo permanentemente!\n\nTem certeza que deseja continuar?')) {
                    return;
                }
                
                // Segunda confirma√ß√£o para evitar exclus√£o acidental
                if (!confirm('üö® CONFIRMA√á√ÉO FINAL: Todos os dados de absente√≠smo ser√£o perdidos!\n\nDigite "CONFIRMO" para continuar.')) {
                    return;
                }
                
                try {
                    const absenteismoPath = 'dados_absenteismo';
                    console.log('üóëÔ∏è Iniciando limpeza completa do hist√≥rico de absente√≠smo...');
                    
                    // Aguardar um pouco para garantir que opera√ß√µes anteriores foram finalizadas
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Buscar todos os documentos
                    const q = query(collection(db, absenteismoPath));
                    const querySnapshot = await getDocs(q);
                    
                    const totalDocs = querySnapshot.size;
                    console.log(`üìä Total de documentos encontrados: ${totalDocs}`);
                    
                    if (totalDocs === 0) {
                        showFeedback('Nenhum dado de absente√≠smo encontrado para excluir.', "info", 3000);
                        // For√ßar rec√°lculo mesmo sem dados para limpar cache
                        calcularIndicadores();
                        return;
                    }
                    
                    // Excluir todos os documentos em lotes menores para garantir efetividade
                    let deletedCount = 0;
                    const batchSize = 50; // Lotes menores para garantir sucesso
                    const docs = querySnapshot.docs;
                    
                    for (let i = 0; i < docs.length; i += batchSize) {
                        const batch = writeBatch(db);
                        const currentBatch = docs.slice(i, i + batchSize);
                        
                        currentBatch.forEach(doc => {
                            batch.delete(doc.ref);
                            deletedCount++;
                        });
                        
                        await batch.commit();
                        console.log(`‚úÖ Lote ${Math.floor(i/batchSize) + 1} deletado: ${currentBatch.length} documentos`);
                    }
                    
                    console.log(`‚úÖ ${deletedCount} registros exclu√≠dos com sucesso`);
                    showFeedback(`‚úÖ Hist√≥rico completo de absente√≠smo limpo! ${deletedCount} registros exclu√≠dos.`, "success", 5000);
                    
                    // Aguardar um pouco antes de recalcular para garantir que dados foram realmente deletados
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Atualizar interface
                    await loadAbsenteismoDataList();
                    await calcularIndicadoresOperacao();
                    
                } catch (error) {
                    console.error('‚ùå Erro ao limpar hist√≥rico de absente√≠smo:', error);
                    showFeedback('‚ùå Erro ao limpar dados. Tente novamente.', "error", 5000);
                }
            }
            
            async function loadAbsenteismoDataList() {
                const dataList = document.getElementById('absenteismo-data-list');
                dataList.innerHTML = '<div class="text-center text-gray-400 text-sm py-4">Carregando dados...</div>';
                
                try {
                    const absenteismoPath = 'dados_absenteismo';
                    const allData = await getFirestoreCollection(absenteismoPath);
                    
                    if (allData.length === 0) {
                        dataList.innerHTML = '<div class="text-center text-gray-400 text-sm py-4">Nenhum dado de absente√≠smo encontrado.</div>';
                        return;
                    }
                    
                    // Agrupar dados por per√≠odo (mesAno)
                    const groupedData = {};
                    allData.forEach(item => {
                        const periodo = item.mesAno || 'Indefinido';
                        if (!groupedData[periodo]) {
                            groupedData[periodo] = [];
                        }
                        groupedData[periodo].push(item);
                    });
                    
                    // Renderizar lista
                    const periodos = Object.keys(groupedData).sort().reverse(); // Mais recente primeiro
                    
                    if (periodos.length === 0) {
                        dataList.innerHTML = '<div class="text-center text-gray-400 text-sm py-4">Nenhum per√≠odo encontrado.</div>';
                        return;
                    }
                    
                    dataList.innerHTML = periodos.map(periodo => {
                        const dados = groupedData[periodo];
                        const dataExemplo = dados[0]?.dataRelatorio || dados[0]?.data || '';
                        const totalRegistros = dados.length;
                        
                        return `
                            <div class="bg-gray-700 p-4 rounded-lg border border-gray-600">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <h3 class="text-lg font-medium text-gray-200">${formatPeriodName(periodo)}</h3>
                                        <p class="text-sm text-gray-400">
                                            ${totalRegistros} registros ‚Ä¢ Data base: ${formatDate(dataExemplo)}
                                        </p>
                                        <p class="text-xs text-gray-500 mt-1">
                                            Colaboradores: ${[...new Set(dados.map(d => d.colaborador))].length}
                                        </p>
                                    </div>
                                    <div class="flex gap-2">
                                        <button onclick="downloadAbsenteismoData('${periodo}')" 
                                                class="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs rounded">
                                            üì• Baixar
                                        </button>
                                        <button onclick="deleteAbsenteismoPeriod('${periodo}')" 
                                                class="px-3 py-1 bg-red-600 hover:bg-red-700 text-white text-xs rounded">
                                            üóëÔ∏è Excluir
                                        </button>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                } catch (error) {
                    console.error('Erro ao carregar lista de dados:', error);
                    dataList.innerHTML = '<div class="text-center text-red-400 text-sm py-4">Erro ao carregar dados.</div>';
                }
            }
            
            function formatPeriodName(periodo) {
                if (periodo === 'Indefinido') return periodo;
                const [ano, mes] = periodo.split('-');
                const meses = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 
                              'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
                return `${meses[parseInt(mes) - 1]} ${ano}`;
            }
            
            function formatDate(dateStr) {
                if (!dateStr) return 'N/A';
                try {
                    const date = new Date(dateStr);
                    return date.toLocaleDateString('pt-BR');
                } catch {
                    return dateStr;
                }
            }
            
            async function deleteAbsenteismoPeriod(periodo) {
                if (!confirm(`Tem certeza que deseja excluir todos os dados de ${formatPeriodName(periodo)}?`)) {
                    return;
                }
                
                try {
                    const absenteismoPath = 'dados_absenteismo';
                    const allData = await getFirestoreCollection(absenteismoPath);
                    const dataToDelete = allData.filter(item => item.mesAno === periodo);
                    
                    console.log(`üóëÔ∏è Excluindo ${dataToDelete.length} registros do per√≠odo ${periodo}`);
                    
                    // Deletar documentos do Firestore
                    for (const item of dataToDelete) {
                        await deleteDoc(doc(db, absenteismoPath, item.id));
                    }
                    
                    showFeedback(`Dados de ${formatPeriodName(periodo)} exclu√≠dos com sucesso!`, "success", 3000);
                    
                    // Recarregar lista e recalcular indicadores
                    await loadAbsenteismoDataList();
                    await calcularIndicadoresOperacao();
                    
                } catch (error) {
                    console.error('Erro ao excluir dados:', error);
                    showFeedback('Erro ao excluir dados. Tente novamente.', "error", 5000);
                }
            }
            
            async function downloadAbsenteismoData(periodo) {
                try {
                    const absenteismoPath = 'dados_absenteismo';
                    const allData = await getFirestoreCollection(absenteismoPath);
                    const dataToDownload = allData.filter(item => item.mesAno === periodo);
                    
                    // Converter para CSV
                    const headers = ['Data', 'Colaborador', 'Cargo', 'Local', 'Horas Previstas', 'Horas Normais', 'Total Absente√≠smo'];
                    const csvContent = [
                        headers.join(','),
                        ...dataToDownload.map(item => [
                            item.data || '',
                            item.colaborador || '',
                            item.cargo || '',
                            item.locaisDeTrabalho || '',
                            item.horasPrevistas || '',
                            item.horasNormaisTrabalhadas || '',
                            item.totalAbsenteismo || ''
                        ].map(field => `"${field}"`).join(','))
                    ].join('\\n');
                    
                    // Download
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `absenteismo_${periodo}.csv`;
                    link.click();
                    
                } catch (error) {
                    console.error('Erro ao baixar dados:', error);
                    showFeedback('Erro ao baixar dados.', "error", 3000);
                }
            }
            
            // Event listeners para o painel de gerenciamento
            document.getElementById('refresh-absenteismo-list-btn')?.addEventListener('click', loadAbsenteismoDataList);
            document.getElementById('clear-all-absenteismo-btn')?.addEventListener('click', clearAllAbsenteismoData);
            
            // Carregar lista inicial
            setTimeout(loadAbsenteismoDataList, 1000);

            // Initialize Firebase connection
            initializeFirebase().then(() => {
                console.log("‚úÖ Firebase inicializa√ß√£o completa!");
            }).catch(error => {
                console.error("‚ùå Erro na inicializa√ß√£o do Firebase:", error);
            });
        });

    </script>

</body>

</html>

